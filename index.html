<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    
    <!-- ▼▼▼ 修改这行：加上 viewport-fit=cover (这对刘海屏很重要) ▼▼▼ -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover" />
    
    <title>k兔叽</title>

    <!-- ▼▼▼▼▼▼ 必须加上这两行，才能在桌面打开变全屏 ▼▼▼▼▼▼ -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- 建议加上图标，这样添加到桌面时就是一个可爱的图标，而不是网页截图 -->
    <link rel="apple-touch-icon" href="https://i.postimg.cc/Gh5gh5hK/c3f30de7397cac502c29085c6d1fff58.jpg">
    <!-- ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲ -->

    <script src="https://unpkg.com/dexie/dist/dexie.js"></script>
    <style>
      /* --- 基础和全局样式 --- */
      :root {
        /* ▼▼▼ 修改这 3 行 ▼▼▼ */
        --primary-bg: #ffffff; /* 默认背景改白色 */
        --primary-text: #000000; /* 默认文字改黑色 */

        /* 建议：默认组件颜色设为黑色带极低透明度，这样在白背景下就是浅灰色，很好看 */
        --capsule-bg: rgba(0, 0, 0, 0.05);
        --text-color: #f0f0f0;
        ---text-secondary-color: var(--text-color);
        --accent-color: #00ffff;
        --blur-effect: blur(10px);
        /* ▼▼▼ 新增这一行 ▼▼▼ */
        --app-font: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      html,
      body {
        width: 100%;
        height: 100%;
        overflow: hidden;
        /* ▼▼▼ 修改这一行，使用变量 ▼▼▼ */
        font-family: var(--app-font);
        background-color: var(--primary-bg);
        color: var(--text-color);
      }

      ::placeholder {
        color: var(--text-secondary-color);
        opacity: 0.7;
      }

      /* --- 主屏幕容器 --- */
      .phone-screen {
        width: 100vw;
        height: 100vh;
        
        /* ▼▼▼ 修改开始：适配 iOS 全屏后的安全区域（刘海和底部） ▼▼▼ */
        /* 使用 max 函数：如果有刘海，用刘海高度；如果没有，用默认的 25px */
        padding-top: max(25px, env(safe-area-inset-top)); 
        /* 底部同理，避开小黑条 */
        padding-bottom: max(15px, env(safe-area-inset-bottom));
        padding-left: 15px;
        padding-right: 15px;
        /* ▲▲▲ 修改结束 ▲▲▲ */

        display: flex;
        flex-direction: column;
        gap: 20px;
      }


      /* --- 通用胶囊/气泡样式 --- */
      .glass-bubble {
        background-color: var(--capsule-bg);
        backdrop-filter: var(--blur-effect);
        -webkit-backdrop-filter: var(--blur-effect);
        border: 1px solid rgba(255, 255, 255, 0.18);
      }

      /* --- 顶部小胶囊 (状态栏) --- */
      .status-bar {
        width: fit-content;
        margin: 0 auto;
        padding: 5px 15px;
        border-radius: 50px;
        display: flex;
        align-items: center;
        font-size: 12px;
        gap: 10px;
      }
      .status-bar .separator {
        color: var(--text-secondary-color);
      }

      /* --- 第二个大胶囊 (主信息栏) --- */
      .main-info-bar {
        display: flex;
        align-items: center;
        border-radius: 50px;
        padding: 5px;
        height: 60px;
        flex-shrink: 0;
      }
      .main-info-bar .profile-dot {
        width: 50px;
        height: 50px;
        background-color: rgba(255, 255, 255, 0.2);
        border-radius: 50%;
        flex-shrink: 0;
      }
      .main-info-bar .input-area {
        flex-grow: 1;
        padding: 0 15px;
        display: flex;
        flex-direction: column;
        justify-content: center;
        gap: 4px;
        align-items: center; /* <<< 新增这一行 */
      }
      .main-info-bar input[type='text'] {
        background: none;
        border: none;
        color: var(--text-color);
        font-size: 16px;
        width: 100%;
        outline: none;
        text-align: center; /* <<< 新增这一行 */
      }

      .main-info-bar .date-capsule {
        background-color: var(--capsule-nested-bg);
        color: var(--text-secondary-color);
        opacity: 0.8; /* <-- 新增 */
        font-size: 10px;
        padding: 2px 8px;
        border-radius: 20px;
        width: fit-content;
      }
      .main-info-bar .lock-widget {
        position: relative;
        width: 50px;
        height: 50px;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
      }
      .main-info-bar .heart-lock {
        width: 30px;
        height: 30px;
        fill: none;
        stroke: var(--text-secondary-color);
        stroke-width: 2;
      }
      .main-info-bar .temperature {
        position: absolute;
        font-size: 12px;
        font-weight: bold;
        color: var(--text-color);
      }

      /* --- 中间和底部内容区 --- */
      .content-section {
        display: flex;
        gap: 15px;
      }
      .main-info-bar + .content-section {
        margin-top: 35px;
      }
      .content-section + .content-section {
        margin-top: 40px;
      }
      .content-section .left-panel,
      .content-section .right-panel {
        width: 50%;
        display: flex;
        flex-direction: column;
        gap: 15px;
      }

      /* --- APP 网格与图标 --- */
      .app-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        grid-template-rows: auto auto;
        gap: 15px;
      }
      .app-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 6px;
      }
      .app-icon img {
        width: 55px;
        height: 55px;
        border-radius: 22%;
        object-fit: cover;
        border: 1px solid rgba(255, 255, 255, 0.25);
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
      }
      /* 找到 .app-name */
      .app-name {
        font-size: 11px;
        color: var(--text-secondary-color);
        opacity: 0.8; /* <-- 新增 */
      }

      /* --- 右侧头像和输入区 --- */
      .profile-section {
        position: relative;
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 2;
      }
      .profile-avatar {
        width: 90px;
        height: 90px;
        border-radius: 50%;
        object-fit: cover;
        border: 3px solid var(--primary-bg);
      }

      /* --- 萌系对话气泡 --- */
      .chat-widget {
        position: absolute;
        top: -8px; /* 【修改】再向上移动一点 */
        right: -10px;
        padding: 6px 10px;
        border-radius: 16px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        transition: transform 0.2s ease;
      }
      .chat-widget:hover {
        transform: scale(1.05);
      }
      .chat-widget::after {
        content: '';
        position: absolute;
        bottom: -5px;
        left: 25px;
        width: 0;
        height: 0;
        border: 8px solid transparent;
        border-top-color: var(--capsule-bg);
      }
      .chat-widget input {
        background: none;
        border: none;
        color: var(--text-color);
        width: 38px;
        font-size: 11px;
        outline: none;
        text-align: center;
      }

      /* --- 头像下方的输入气泡 --- */
      .thought-bubble {
        border-radius: 20px;
        padding: 15px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        margin-top: -40px;
        padding-top: 50px;
        z-index: 1;
      }
      .thought-bubble textarea {
        background: none;
        border: none;
        color: var(--text-color);
        resize: none;
        height: 28px;
        font-size: 14px;
        outline: none;
      }
      .prompt-capsule {
        display: flex;
        align-items: center;
        background-color: var(--capsule-nested-bg);
        border-radius: 20px;
        padding: 5px 10px;
      }
      .prompt-capsule .magic-wand-svg {
        width: 16px;
        height: 16px;
        fill: var(--accent-color);
        flex-shrink: 0;
        margin-right: 8px;
      }
      .prompt-capsule input {
        background: none;
        border: none;
        color: var(--text-color);
        font-size: 12px;
        width: 100%;
        outline: none;
      }

      /* --- 底部内容区 (图片上传) --- */
      .image-uploader {
        border-radius: 20px;
        padding: 10px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        aspect-ratio: 1 / 1;
      }
      .image-placeholder {
        border: 2px dashed rgba(255, 255, 255, 0.3);
        border-radius: 15px;
        flex-grow: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        color: var(--text-secondary-color);
        font-size: 14px;
      }
      .image-uploader input[type='text'] {
        background: none;
        border: none;
        outline: none;
        color: var(--text-color);
        text-align: center;
        font-size: 12px;
      }
      /* 在 <style> 标签内添加这段 CSS */
      .image-placeholder {
        cursor: pointer; /* 鼠标悬停时显示为可点击的手指 */
        background-size: cover; /* 图片覆盖整个区域 */
        background-position: center; /* 图片居中显示 */
        background-repeat: no-repeat;
        transition: background-color 0.3s ease; /* 添加一点过渡效果 */
      }
      .image-placeholder:hover {
        background-color: rgba(255, 255, 255, 0.05); /* 悬停时背景色变亮一点 */
      }
      /* ================== 萌系弹窗通用样式 ================== */
      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.6);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        opacity: 0;
        visibility: hidden;
        transition: opacity 0.3s ease, visibility 0.3s ease;
      }

      .modal-overlay.show {
        opacity: 1;
        visibility: visible;
      }

      .modal-content {
        /* ▼▼▼ 修改这一行：让弹窗背景也跟随全局设置 ▼▼▼ */
        background-color: var(--primary-bg);

        padding: 25px;
        border-radius: 20px;
        /* 建议把边框颜色也改淡一点，或者直接用变量，不然在白色背景下白边框看不见 */
        /* border: 1px solid rgba(255, 255, 255, 0.2);  <-- 原来的 */
        border: 1px solid var(--capsule-bg); /* <-- 建议改成这样，或者保留原样 */

        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        text-align: center;
        position: relative;
        width: 85%;
        max-width: 320px;
        transform: scale(0.9);
        transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      }

      .modal-overlay.show .modal-content {
        transform: scale(1);
      }

      .modal-content h3 {
        color: var(--text-color);
        margin-bottom: 10px;
      }

      .modal-content p {
        color: var(--text-secondary-color);
        font-size: 14px;
        margin-bottom: 20px;
      }

      .modal-buttons {
        display: flex;
        gap: 10px;
        justify-content: center;
      }

      .modal-content button {
        background-color: var(--capsule-bg);
        color: var(--text-color);
        border: 1px solid rgba(255, 255, 255, 0.2);
        padding: 10px 20px;
        border-radius: 25px;
        cursor: pointer;
        font-size: 14px;
        transition: background-color 0.2s ease, transform 0.2s ease;
      }

      .modal-content button:hover {
        background-color: rgba(255, 255, 255, 0.2);
        transform: translateY(-2px);
      }

      .modal-content .close-btn {
        position: absolute;
        top: 10px;
        right: 15px;
        background: none;
        border: none;
        font-size: 24px;
        color: var(--text-secondary-color);
        padding: 0;
      }

      /* 文本编辑弹窗的特殊样式 */
      #textEditArea {
        width: 100%;
        height: 100px;
        background-color: var(--capsule-bg);
        border-radius: 15px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        color: var(--text-color);
        padding: 10px;
        font-size: 14px;
        resize: none;
        margin-bottom: 20px;
        outline: none;
      }

      #saveTextBtn {
        background-color: var(--accent-color);
        color: #000;
        font-weight: bold;
      }

      /* 图片上传区域的样式 (新增) */
      .profile-dot {
        background-size: cover;
        background-position: center;
        cursor: pointer;
      }
      /* ================== 外观设置弹窗样式 ================== */
      .settings-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 20px;
        padding: 10px;
        background-color: var(--capsule-bg);
        border-radius: 15px;
      }

      .settings-item label {
        color: var(--text-secondary-color);
        font-size: 14px;
      }

      .settings-item button {
        padding: 5px 15px;
        font-size: 13px;
      }

      .color-input-group {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .color-input-group input[type='color'] {
        width: 30px;
        height: 30px;
        border: none;
        border-radius: 8px;
        padding: 2px;
        cursor: pointer;
        background-color: transparent;
      }
      /* 隐藏原生颜色选择器的边框和背景 */
      .color-input-group input[type='color']::-webkit-color-swatch-wrapper {
        padding: 0;
      }
      .color-input-group input[type='color']::-webkit-color-swatch {
        border: 1px solid rgba(255, 255, 255, 0.3);
        border-radius: 6px;
      }

      .color-input-group input[type='text'] {
        background: none;
        border: none;
        color: var(--text-color);
        font-size: 14px;
        width: 80px;
        text-align: right;
        outline: none;
      }

      .settings-item input[type='range'] {
        width: 50%;
        -webkit-appearance: none;
        appearance: none;
        background: transparent;
        cursor: pointer;
      }
      /* 美化滑块轨道 */
      .settings-item input[type='range']::-webkit-slider-runnable-track {
        background: var(--capsule-nested-bg);
        height: 6px;
        border-radius: 3px;
      }
      /* 美化滑块按钮 */
      .settings-item input[type='range']::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        margin-top: -5px; /* 使按钮垂直居中 */
        background-color: var(--accent-color);
        height: 16px;
        width: 16px;
        border-radius: 50%;
      }

      /* 主屏幕壁纸样式 */
      .phone-screen {
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        transition: background-image 0.5s ease-in-out;
      }
      /* ================== 外观设置弹窗新增样式 ================== */
      .wallpaper-preview-container {
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .wallpaper-preview {
        width: 60px;
        height: 60px;
        border-radius: 10px;
        background-size: cover;
        background-position: center;
        border: 1px solid rgba(255, 255, 255, 0.2);
        background-color: #333;
      }
      .settings-section-divider {
        margin-top: 25px;
        margin-bottom: 10px;
        border-top: 1px solid rgba(255, 255, 255, 0.1);
        padding-top: 15px;
      }
      .settings-section-divider label {
        color: var(--text-color);
        font-weight: bold;
      }
      .editable-app-list {
        list-style: none;
        padding: 0;
        margin: 0;
      }
      .editable-app-list li {
        display: flex;
        align-items: center;
        padding: 8px;
        border-radius: 10px;
        margin-bottom: 8px;
        /* ▼▼▼ 修改这一行：从 rgba(0, 0, 0, 0.2) 改为变量 ▼▼▼ */
        background-color: var(--capsule-bg);
        /* 建议加上边框，这样在纯白背景下更有层次感 */
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .editable-app-list img {
        width: 35px;
        height: 35px;
        border-radius: 8px;
        margin-right: 12px;
      }
      .editable-app-list span {
        flex-grow: 1;
        font-size: 14px;
        color: var(--text-secondary-color);
      }
      .editable-app-list button {
        font-size: 12px;
        padding: 4px 12px;
      }
      #saveSettingsBtn {
        background-color: var(--accent-color);
        color: #000;
        font-weight: bold;
      }

      /* ================== 编辑App弹窗样式 ================== */
      .settings-item-column {
        display: flex;
        flex-direction: column;
        align-items: flex-start;
        width: 100%;
        margin-bottom: 15px;
      }
      .settings-item-column label {
        font-size: 14px;
        color: var(--text-secondary-color);
        margin-bottom: 8px;
      }
      .styled-input {
        width: 100%;
        padding: 10px;
        background-color: var(--capsule-bg);
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 10px;
        color: var(--text-color);
        font-size: 14px;
        outline: none;
      }
      /* 添加到 <style> 标签的末尾 */
      .editable-app-list .button-group {
        display: flex;
        gap: 6px;
      }
      /* ================== API 设置弹窗样式 ================== */
      #apiSettingsModal .modal-content {
        text-align: left; /* 让标签左对齐 */
      }

      #apiSettingsModal select.styled-input {
        -webkit-appearance: none;
        appearance: none;
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='16' height='16' fill='%23f0f0f0' viewBox='0 0 16 16'%3E%3Cpath fill-rule='evenodd' d='M1.646 4.646a.5.5 0 0 1 .708 0L8 10.293l5.646-5.647a.5.5 0 0 1 .708.708l-6 6a.5.5 0 0 1-.708 0l-6-6a.5.5 0 0 1 0-.708z'/%3E%3C/svg%3E");
        background-repeat: no-repeat;
        background-position: right 10px center;
        background-size: 16px;
        padding-right: 35px; /* 为箭头留出空间 */
      }

      #apiSettingsModal .modal-buttons button {
        flex-grow: 1; /* 让按钮平分空间 */
      }
      /* ================== QQ 应用页面通用样式 ================== */
      .app-page {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        /* ▼▼▼ 修改这一行：让它跟随全局设置 ▼▼▼ */
        background-color: var(--primary-bg);
        z-index: 2000;
        display: flex;
        flex-direction: column;
        transform: translateX(100%);
        transition: transform 0.3s ease-in-out;
      }

      .app-page.active {
        transform: translateX(0); /* 滑入屏幕 */
      }

      .app-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        
        /* ▼▼▼ 修改这里：让顶部栏的高度包含刘海的高度 ▼▼▼ */
        padding-top: max(15px, env(safe-area-inset-top));
        padding-bottom: 15px;
        padding-left: 20px;
        padding-right: 20px;
        height: auto; /* 确保高度自适应 */
        /* ▲▲▲ 修改结束 ▲▲▲ */

        /* ▼▼▼ 修改这一行：使用组件颜色变量 ▼▼▼ */
        background-color: var(--capsule-bg);
        backdrop-filter: blur(10px); 
        -webkit-backdrop-filter: blur(10px);
        flex-shrink: 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }


      .header-title {
        font-size: 18px;
        font-weight: bold;
      }

      .header-actions svg {
        cursor: pointer;
        stroke: var(--text-color);
      }

      /* ================== 通讯录页面样式 ================== */
      .contacts-list {
        flex-grow: 1;
        overflow-y: auto;
      }

      .contact-avatar {
        width: 45px;
        height: 45px;
        border-radius: 50%;
        margin-right: 15px;
        object-fit: cover;
      }

      .contact-info {
        flex-grow: 1;
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      .contact-name {
        font-size: 16px;
        color: var(--text-color);
      }

      .contact-last-msg {
        font-size: 14px;
        color: #8e8e93; /* 灰色字体 */
      }

      .contact-time {
        font-size: 12px;
        color: #8e8e93;
        align-self: flex-start;
        margin-top: 2px;
      }

      /* ================== 聊天详情页样式 ================== */
      /* 聊天页顶部 */
      .chat-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        position: relative;
        padding: 10px;
        /* ▼▼▼ 修改这一行 ▼▼▼ */
        background-color: var(--capsule-bg);
        backdrop-filter: blur(10px); /* 推荐加上 */
        -webkit-backdrop-filter: blur(10px);
        flex-shrink: 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }
      .back-btn {
        background: none;
        border: none;
        color: var(--text-color);
        font-size: 24px;
        font-weight: bold;
        cursor: pointer;
        padding: 0 10px;
      }

      .chat-header-placeholder {
        width: 44px; /* 与返回按钮宽度大致相等，用于平衡布局 */
      }
      /* 修改 .char-status-bar 样式 */
      .char-status-bar {
        flex-grow: 1; /* 让它占据返回按钮和占位符之间的所有空间 */
        display: flex;
        justify-content: center; /* 核心：让内部元素水平居中 */
        align-items: center;
        gap: 15px; /* 控制头像之间的间距 */
        cursor: pointer;
      }

      /* 定义 .header-avatar 样式 */
      .header-avatar {
        width: 40px; /* 调整为你希望的大小 */
        height: 40px; /* 调整为你希望的大小 */
        border-radius: 50%;
        object-fit: cover;
        border: 2px solid rgba(0, 0, 0, 0.3); /* 添加一点深色边框让它更突出 */
        background-color: #555; /* 图片加载失败时的占位颜色 */
      }

      /* 聊天消息区域 */
      #qq-chat-page {
        /* 确保聊天页面是 flex 布局 */
        display: flex;
        flex-direction: column;
      }

      .chat-messages {
        flex-grow: 1; /* 核心：让消息区域占据所有剩余空间 */
        overflow-y: auto; /* 当消息过多时可以滚动 */
        padding: 10px;
        display: flex;
        flex-direction: column;
      }

      .message {
        display: flex;
        align-items: flex-end;
        margin-bottom: 15px;
        max-width: 80%;
      }
      .message-avatar {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        object-fit: cover;
        flex-shrink: 0;
      }
      .message-content {
        padding: 10px 15px;
        border-radius: 18px;
        font-size: 16px;
        line-height: 1.4;
        display: flex; /* <-- 新增 */
        flex-direction: column; /* <-- 新增 */
        align-items: flex-start; /* <-- 新增，保证内容靠左/右对齐 */
      }

      /* 对方 (char) 的消息 */
      .char-message {
        align-self: flex-start;
      }
      .char-message .message-avatar {
        margin-right: 10px;
      }
      .char-message .message-content {
        background-color: #363638;
        border-top-left-radius: 5px;
      }
      /* 自己 (user) 的消息 */
      .user-message {
        align-self: flex-end;
      }
      .user-message .message-avatar {
        margin-left: 10px;
      }
      .user-message .message-content {
        background-color: #007aff; /* 蓝色气泡 */
        color: white;
        border-top-right-radius: 5px;
        order: -1; /* 让内容在头像左边 */
      }

      /* 底部输入框区域 */
      .chat-input-area {
        display: flex;
        align-items: center;
        padding: 10px;
        /* ▼▼▼ 修改这一行 ▼▼▼ */
        background-color: var(--capsule-bg);
        backdrop-filter: blur(10px); /* 推荐加上 */
        -webkit-backdrop-filter: blur(10px);
        flex-shrink: 0;
        gap: 10px;
      }

      #chat-input-box {
        flex-grow: 1;
        background-color: #363638;
        border: none;
        border-radius: 20px;
        padding: 10px 15px;
        color: var(--text-color);
        font-size: 16px;
        outline: none;
      }

      .chat-send-btn {
        background-color: #007aff;
        color: white;
        border: none;
        border-radius: 8px;
        padding: 8px 15px;
        font-size: 14px;
        cursor: pointer;
        font-weight: bold;
      }
      .chat-send-btn.api {
        background-color: #30d158; /* 真实发送用绿色区分 */
      }
      /* ================== 聊天设置面板样式 ================== */
      .settings-item-column textarea.styled-input {
        min-height: 80px; /* 给文本域一个合适的最小高度 */
        resize: vertical; /* 允许用户垂直调整大小 */
      }
      /* ================== 用户预设列表样式 ================== */
      .user-preset-item {
        display: flex;
        align-items: center;
        padding: 8px;
        border-radius: 10px;
        margin-bottom: 8px;
        /* ▼▼▼ 修改这一行 ▼▼▼ */
        background-color: var(--capsule-bg);
        border: 1px solid rgba(255, 255, 255, 0.1); /* 新增边框 */
        cursor: pointer;
        transition: background-color 0.2s ease;
      }

      .user-preset-item:hover {
        background-color: rgba(255, 255, 255, 0.1);
      }
      .user-preset-item img {
        width: 35px;
        height: 35px;
        border-radius: 50%; /* 圆形头像 */
        margin-right: 12px;
        object-fit: cover;
        flex-shrink: 0;
      }
      .user-preset-item .preset-info {
        flex-grow: 1;
        overflow: hidden; /* 防止文本过长溢出 */
      }
      .user-preset-item .preset-name {
        font-size: 14px;
        color: var(--text-color);
        display: block; /* 独占一行 */
      }
      .user-preset-item .preset-persona-preview {
        font-size: 12px;
        color: var(--text-secondary-color);
        opacity: 0.8;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        display: block; /* 独占一行 */
      }
      .user-preset-item .delete-preset-btn {
        font-size: 12px;
        padding: 4px 12px;
        background-color: #ff3b30;
        color: white;
        border: none;
        font-weight: bold;
        border-radius: 20px;
        flex-shrink: 0;
        margin-left: 10px;
        cursor: pointer;
      }
      /* ================== NPC 和 表情包库 新增样式 ================== */
      .editable-app-list .npc-item-info {
        flex-grow: 1;
        display: flex;
        flex-direction: column;
        gap: 4px;
        overflow: hidden;
      }
      .editable-app-list .npc-name {
        font-size: 14px;
        color: var(--text-color);
        white-space: nowrap;
        text-overflow: ellipsis;
        overflow: hidden;
      }
      .editable-app-list .npc-relation {
        font-size: 12px;
        color: var(--text-secondary-color);
        opacity: 0.8;
        white-space: nowrap;
        text-overflow: ellipsis;
        overflow: hidden;
      }

      .sticker-tab-btn {
        flex: 1;
        padding: 10px;
        background: none;
        border: none;
        color: var(--text-secondary-color);
        cursor: pointer;
        font-size: 14px;
        border-bottom: 2px solid transparent;
        transition: all 0.2s ease;
      }
      .sticker-tab-btn.active {
        color: var(--accent-color);
        border-bottom-color: var(--accent-color);
      }

      .sticker-tab-content {
        display: none;
      }
      .sticker-tab-content.active {
        display: block;
      }

      .sticker-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
        gap: 10px;
      }
      .sticker-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 5px;
        padding: 5px;
        border-radius: 8px;
        background-color: rgba(255, 255, 255, 0.05);
        position: relative;
      }
      .sticker-item img {
        width: 100%;
        aspect-ratio: 1 / 1;
        object-fit: contain;
      }
      .sticker-item p {
        font-size: 11px;
        color: var(--text-secondary-color);
        margin: 0;
        text-align: center;
        width: 100%;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .sticker-item .delete-sticker-btn {
        position: absolute;
        top: -5px;
        right: -5px;
        width: 20px;
        height: 20px;
        background-color: #ff3b30;
        color: white;
        border: none;
        border-radius: 50%;
        cursor: pointer;
        display: none; /* 默认隐藏 */
        align-items: center;
        justify-content: center;
        font-size: 14px;
        line-height: 20px;
      }
      .sticker-item:hover .delete-sticker-btn {
        display: flex; /* 悬停时显示 */
      }
      .sticker-item.selected {
        outline: 2px solid var(--accent-color);
        background-color: rgba(0, 255, 255, 0.2);
      }
      #stickerLibraryModal.manage-mode .sticker-item .delete-sticker-btn {
        display: none; /* 在管理模式下隐藏单个删除按钮 */
      }
      #stickerLibraryModal.manage-mode .sticker-item {
        cursor: pointer; /* 提示用户可以点击 */
      }
      /* ================== 气泡编辑器弹窗样式 ================== */
      .bubble-editor-preview-area {
        background-color: rgba(0, 0, 0, 0.3);
        border-radius: 15px;
        padding: 15px;
        margin-bottom: 20px;
        border: 1px solid var(--capsule-bg);
        /* 模拟聊天窗口的flex布局 */
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .bubble-editor-preview-area .message {
        max-width: 70%; /* 预览时气泡小一点 */
      }
      .bubble-editor-preview-area .message-content {
        font-size: 14px;
      }

      .bubble-editor-controls {
        flex-grow: 1;
        overflow-y: auto;
      }
      /* ================== 气泡编辑器 V2 新增样式 ================== */
      .bubble-overlay-image {
        position: absolute;
        top: 10px;
        left: 10px;
        width: 50%;
        pointer-events: none; /* 默认不可交互，JS会覆盖 */
      }

      .bubble-target-selector {
        display: flex;
        background-color: var(--capsule-bg);
        border-radius: 10px;
        padding: 5px;
        margin-bottom: 15px;
      }
      .bubble-target-selector label {
        flex: 1;
        text-align: center;
        padding: 8px;
        border-radius: 8px;
        cursor: pointer;
        transition: background-color 0.2s ease;
        font-size: 14px;
      }
      .bubble-target-selector input[type='radio'] {
        display: none;
      }
      .bubble-target-selector input[type='radio']:checked + label {
        background-color: var(--accent-color);
        color: #000;
        font-weight: bold;
      }
      /* 为了让 radio input:checked + label 生效，需要反转 label 和 input 的位置 */
      .bubble-target-selector label {
        display: block;
      }

      .editor-section-title {
        display: block;
        margin-top: 15px;
        margin-bottom: 5px;
        color: var(--text-color);
        font-weight: bold;
        font-size: 14px;
        border-bottom: 1px solid var(--capsule-bg);
        padding-bottom: 5px;
      }

      #visualEditorTab .settings-item {
        padding: 5px 0;
        margin-bottom: 5px;
      }
      #visualEditorTab .settings-item-column {
        margin-bottom: 5px;
      }
      #visualEditorTab .settings-item label,
      #visualEditorTab .settings-item-column label {
        font-size: 13px;
        flex-shrink: 0;
        width: 100px;
      }

      #bubbleBgColor {
        width: 38px !important;
        height: 38px !important;
        padding: 2px !important;
        border-radius: 10px !important;
      }
      /* ================== 气泡编辑器 V3 新增样式 ================== */
      .control-group {
        padding: 10px;
        margin-top: 5px;
        border-radius: 10px;
        background-color: rgba(0, 0, 0, 0.2);
        border: 1px solid var(--capsule-bg);
      }
      #visualEditorTab .settings-item {
        align-items: center; /* 垂直居中 */
      }
      #visualEditorTab input[type='checkbox'] {
        transform: scale(1.2); /* 让复选框大一点 */
      }
      /* ================== 通讯录分组样式 (新) ================== */
      .contact-group {
        /* 这是每个分组的外层容器 */
        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      }

      .contact-group:last-of-type {
        border-bottom: none; /* 最后一个分组不需要底部分割线 */
      }

      .contact-group-header {
        /* 这是分组的标题，也就是可以点击展开/折叠的区域 */
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 12px 20px;
        cursor: pointer;
        font-size: 14px;
        font-weight: bold;
        color: var(--text-color);
        list-style: none; /* 隐藏 <details> 默认的小三角 */
        transition: background-color 0.2s ease;
      }

      .contact-group-header::-webkit-details-marker {
        display: none; /* 同样为 Webkit 浏览器隐藏默认小三角 */
      }

      .contact-group-header:hover {
        background-color: #2c2c2e;
      }

      .group-name-wrapper {
        display: flex;
        align-items: center;
        gap: 8px; /* 图标和文字的间距 */
      }

      .group-toggle-icon {
        transition: transform 0.2s ease-in-out;
        display: inline-block; /* 允许 transform 生效 */
      }

      /* 当分组展开时，旋转图标 */
      .contact-group[open] > .contact-group-header .group-toggle-icon {
        transform: rotate(90deg);
      }

      .group-member-count {
        color: #8e8e93; /* 人数统计用灰色字体 */
        font-weight: normal;
      }
      /* ================== 分组管理弹窗样式 (新) ================== */
      .group-manage-item {
        display: flex;
        align-items: center;
        padding: 8px;
        border-radius: 10px;
        margin-bottom: 8px;
        /* ▼▼▼ 修改这一行 ▼▼▼ */
        background-color: var(--capsule-bg);
        border: 1px solid rgba(255, 255, 255, 0.1); /* 新增边框 */
      }

      .group-manage-item .group-info {
        flex-grow: 1;
        display: flex;
        flex-direction: column;
        gap: 2px;
      }
      .group-manage-item .group-name {
        font-size: 14px;
        color: var(--text-color);
      }
      .group-manage-item .group-char-count {
        font-size: 12px;
        color: var(--text-secondary-color);
      }
      .group-manage-item .group-controls {
        display: flex;
        gap: 8px;
        align-items: center;
      }
      .group-manage-item .control-label {
        display: flex;
        align-items: center;
        gap: 4px;
        font-size: 12px;
        color: var(--text-secondary-color);
        cursor: pointer;
      }
      .group-manage-item .group-controls button {
        font-size: 12px;
        padding: 4px 10px;
      }
      .group-manage-item .pin-group-btn.pinned {
        background-color: var(--accent-color);
        color: #000;
      }
      .group-manage-item.is-ungrouped .group-controls {
        visibility: hidden; /* 让未分组区域的控件不可见 */
      }
      /* ================== 聊天输入区工具栏 (新) ================== */
      .chat-tool-btn {
        flex-shrink: 0;
        width: 38px;
        height: 38px;
        border-radius: 50%;
        border: none;
        background-color: #363638;
        color: var(--text-color);
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        transition: background-color 0.2s, transform 0.2s;
      }

      .chat-tool-btn:hover {
        background-color: #4a4a4c;
      }

      /* 按钮激活时的旋转效果 */
      .chat-tool-btn.active svg {
        transform: rotate(45deg);
        transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      }
      .chat-tool-btn svg {
        transition: transform 0.3s ease;
      }

      .chat-tool-panel {
        /* ▼▼▼ 修改这一行 ▼▼▼ */
        background-color: var(--capsule-bg);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);

        width: 100%;
        overflow: hidden;
        transition: height 0.3s ease-in-out;
        height: 0;
        border-top: 1px solid rgba(255, 255, 255, 0.1);
        flex-shrink: 0;
      }

      /* 当工具栏打开时，调整聊天消息区域的 padding，避免遮挡 */
      #qq-chat-page.toolbar-open .chat-messages {
        padding-bottom: 280px; /* 预留出工具栏的高度 - 增大 */
        transition: padding-bottom 0.3s ease-in-out;
      }

      #qq-chat-page .chat-messages {
        transition: padding-bottom 0.3s ease-in-out;
      }

      /* 主工具栏网格布局 */
      .toolbar-grid {
        display: flex; /* 核心修改：将 grid 改为 flex */
        gap: 10px;
        padding: 15px;
        height: 100%;
        align-items: center; /* 推荐添加：让所有项目在垂直方向上居中对齐，更美观 */
        overflow-x: auto; /* 推荐添加：如果未来项目增多，可以横向滚动而不是换行 */
      }

      .toolbar-grid-item {
        background-color: rgba(255, 255, 255, 0.08);
        border-radius: 12px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 4px;
        color: var(--text-secondary-color);
        border: none;
        cursor: pointer;
        transition: background-color 0.2s;
      }
      /* ▼▼▼ 把下面这段新代码添加到你的 <style> 里 ▼▼▼ */
      .toolbar-grid-item svg {
        width: 28px; /* 你可以改成 24px 或其他你觉得合适的大小 */
        height: 28px; /* 保持和宽度一致 */
      }

      .toolbar-grid-item:hover {
        background-color: rgba(255, 255, 255, 0.15);
      }
      .toolbar-grid-item.placeholder {
        background-color: transparent;
        cursor: default;
      }

      .toolbar-grid-item span {
        font-size: 12px;
      }
      /* ================== 用户表情包面板新增样式 ================== */
      .user-sticker-panel-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0 15px;
        height: 40px;
        flex-shrink: 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      }
      .user-sticker-panel-header span {
        font-size: 14px;
        color: var(--text-secondary-color);
      }
      .user-sticker-panel-header button {
        background: none;
        border: 1px solid var(--capsule-bg);
        color: var(--text-color);
        padding: 4px 12px;
        border-radius: 20px;
        font-size: 12px;
        cursor: pointer;
      }
      /* ================== 用户表情面板分类功能新增样式 ================== */
      #user-sticker-panel.manage-mode .sticker-item {
        cursor: pointer; /* 在管理模式下，鼠标变成小手 */
      }
      #user-sticker-panel.manage-mode .sticker-item.selected {
        outline: 2px solid var(--accent-color);
        background-color: rgba(0, 255, 255, 0.2);
      }
      .user-sticker-panel-header button {
        padding: 4px 12px;
        border-radius: 20px;
        font-size: 12px;
        cursor: pointer;
        background: none;
        border: 1px solid var(--capsule-bg);
        color: var(--text-color);
        transition: background-color 0.2s;
      }
      .user-sticker-panel-header button:hover {
        background-color: var(--capsule-bg);
      }

      .sticker-category-tabs {
        display: flex;
        gap: 10px;
        padding: 8px 15px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        flex-shrink: 0;
        overflow-x: auto; /* 如果分类太多，可以横向滚动 */
      }
      .sticker-category-tab {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 5px;
        cursor: pointer;
        padding: 5px;
        border-radius: 8px;
        border: 2px solid transparent;
        transition: all 0.2s ease;
      }
      .sticker-category-tab:hover {
        background-color: rgba(255, 255, 255, 0.1);
      }
      .sticker-category-tab.active {
        border-color: var(--accent-color);
        background-color: rgba(0, 255, 255, 0.1);
      }
      .sticker-category-tab img {
        width: 35px;
        height: 35px;
        border-radius: 6px;
        object-fit: cover;
      }
      .sticker-category-tab span {
        font-size: 10px;
        color: var(--text-secondary-color);
        white-space: nowrap;
      }

      #existing-categories-list .category-radio-item {
        display: block;
        padding: 10px;
        margin-bottom: 8px;
        border-radius: 8px;
        background-color: var(--capsule-bg);
        cursor: pointer;
      }
      #existing-categories-list .category-radio-item:hover {
        background-color: rgba(255, 255, 255, 0.2);
      }
      /* ================== 分类删除按钮新增样式 ================== */
      .sticker-category-tab {
        position: relative; /* 为了让删除按钮可以绝对定位 */
      }

      .sticker-category-tab .delete-category-btn {
        position: absolute;
        top: -5px;
        right: -5px;
        width: 20px;
        height: 20px;
        background-color: #ff3b30;
        color: white;
        border: none;
        border-radius: 50%;
        cursor: pointer;
        display: none; /* 默认隐藏 */
        align-items: center;
        justify-content: center;
        font-size: 14px;
        line-height: 20px;
        z-index: 10;
      }

      /* 仅在管理模式下显示删除按钮 */
      #user-sticker-panel.manage-mode .sticker-category-tab:not([data-category-name='未分类']) .delete-category-btn {
        display: flex;
      }
      .message-content img.message-image,
      .message-content img.message-sticker {
        max-width: 100%; /* 图片最大宽度不超过气泡宽度 */
        max-height: 200px; /* 限制一个最大高度，防止图片过大 */
        border-radius: 12px; /* 给图片也加上圆角 */
        display: block; /* 避免图片下方有空隙 */
        background-color: rgba(0, 0, 0, 0.2); /* 加载时的背景色 */
      }

      /* 对于表情包，我们可能希望它背景透明，尺寸可以更大一点 */
      .message-content img.message-sticker {
        background: transparent;
        max-width: 120px;
        max-height: 120px;
        /* 移除内边距，让表情贴紧气泡 */
        margin: -10px -15px;
      }

      /* 当气泡中只有图片时，移除内边距，让图片填充气泡 */
      .message-content:has(> img:only-child) {
        padding: 0;
        background: transparent; /* 背景设为透明，由图片本身决定外观 */
      }

      /* ================== 语音消息样式 (新) ================== */
      .voice-message-container {
        display: flex;
        align-items: center;
        gap: 8px;
        cursor: pointer;
        padding: 2px 5px;
        border-radius: 12px;
        transition: background-color 0.2s ease;
        width: fit-content; /* <-- 新增：让容器宽度自适应内容 */
        min-width: 100px; /* <-- 新增：给波纹一个最小的展示宽度 */
      }

      .voice-message-container:hover {
        background-color: rgba(0, 0, 0, 0.1); /* 悬停时给一点反馈 */
      }

      .voice-icon {
        font-size: 20px; /* 麦克风图标大小 */
        flex-shrink: 0;
      }

      .voice-waveform {
        display: flex;
        align-items: center;
        height: 20px; /* 波纹的高度 */
        gap: 2px;
      }

      .voice-waveform span {
        background-color: currentColor; /* 波纹颜色跟随气泡文字颜色 */
        width: 3px;
        height: 100%; /* <<< 新增这一行，让声波柱子有高度 */
        border-radius: 3px;
        animation: wave 1.2s infinite ease-in-out;
        transform-origin: bottom;
      }

      /* 给每个波纹条加上不同的动画延迟，形成此起彼伏的效果 */
      .voice-waveform span:nth-child(2) {
        animation-delay: -1.1s;
      }
      .voice-waveform span:nth-child(3) {
        animation-delay: -1s;
      }
      .voice-waveform span:nth-child(4) {
        animation-delay: -0.9s;
      }
      .voice-waveform span:nth-child(5) {
        animation-delay: -0.8s;
      }
      .voice-waveform span:nth-child(6) {
        animation-delay: -0.7s;
      }
      .voice-waveform span:nth-child(7) {
        animation-delay: -0.6s;
      }

      /* 波纹动画 */
      @keyframes wave {
        0%,
        40%,
        100% {
          transform: scaleY(0.2);
        }
        20% {
          transform: scaleY(1);
        }
      }

      /* “转文字”后的文本样式 */
      .voice-transcript {
        font-size: 13px;
        color: var(--text-secondary-color);
        opacity: 0.8;
        margin-top: 8px;
        padding-top: 8px;
        border-top: 1px solid rgba(255, 255, 255, 0.1);
        display: none; /* 默认隐藏 */
        width: 100%;
      }
      /* ================== 世界书页面样式 (新) ================== */
      .worldbook-list-item {
        display: flex;
        align-items: center;
        padding: 15px 20px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        cursor: pointer;
        transition: background-color 0.2s ease;
      }
      /* ▼▼▼ 在 .worldbook-list-item 样式下面添加这个 ▼▼▼ */
      .worldbook-content-wrapper {
        display: flex;
        align-items: center;
        flex-grow: 1; /* 让内容区占据大部分空间 */
        overflow: hidden; /* 防止书名过长时撑破布局 */
      }

      .worldbook-list-item:hover {
        background-color: #2c2c2e;
      }

      .worldbook-icon {
        width: 45px;
        height: 45px;
        flex-shrink: 0;
        margin-right: 15px;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: rgba(255, 255, 255, 0.1);
        border-radius: 10px;
      }

      .worldbook-info {
        flex-grow: 1;
      }

      .worldbook-name {
        font-size: 16px;
        color: var(--text-color);
        font-weight: bold;
      }

      .worldbook-stats {
        font-size: 13px;
        color: #8e8e93;
        margin-top: 4px;
      }

      .add-worldbook-btn-container {
        padding: 20px;
        border-top: 1px solid rgba(255, 255, 255, 0.1);
      }

      .add-worldbook-btn {
        width: 100%;
        padding: 12px;
        font-size: 16px;
        font-weight: bold;
        background-color: var(--accent-color);
        color: #000;
        border: none;
        border-radius: 12px;
        cursor: pointer;
      }

      /* --- 世界书详情页 --- */
      .worldbook-entry-list {
        padding: 10px;
        flex-grow: 1;
        overflow-y: auto;
      }

      .worldbook-entry-item {
        background-color: #2c2c2e;
        border-radius: 15px;
        margin-bottom: 10px;
        padding: 15px;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .entry-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 12px;
      }

      .entry-name {
        font-size: 16px;
        font-weight: bold;
        color: var(--text-color);
      }

      .entry-controls button {
        background: none;
        border: 1px solid var(--capsule-bg);
        color: var(--text-color);
        padding: 4px 10px;
        font-size: 12px;
        border-radius: 20px;
        margin-left: 8px;
        cursor: pointer;
      }

      .entry-details {
        font-size: 14px;
        color: var(--text-secondary-color);
      }

      .entry-details p {
        margin-bottom: 8px;
      }

      .entry-details strong {
        color: var(--text-color);
        margin-right: 5px;
      }

      .keywords-container {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
      }

      .keyword-tag {
        background-color: rgba(255, 255, 255, 0.15);
        padding: 3px 8px;
        border-radius: 8px;
        font-size: 12px;
      }
      /* ================== 世界书页面样式结束 ================== */
      /* ================== 关联世界书弹窗样式 (新) ================== */
      #associateWorldBookModal .modal-content {
        text-align: left;
      }

      #worldbook-selection-list {
        list-style: none;
        padding: 0;
        margin: 0;
        max-height: 250px;
        overflow-y: auto;
        border: 1px solid var(--capsule-bg);
        border-radius: 10px;
        padding: 5px;
      }

      .worldbook-selection-item {
        display: block; /* 让整个 label 可点击 */
        padding: 12px 15px;
        border-radius: 8px;
        margin-bottom: 5px;
        cursor: pointer;
        transition: background-color 0.2s ease;
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .worldbook-selection-item:hover {
        background-color: var(--capsule-bg);
      }

      .worldbook-selection-item input[type='checkbox'] {
        width: 18px;
        height: 18px;
        flex-shrink: 0;
        accent-color: var(--accent-color); /* 让勾选后的颜色更好看 */
      }

      .worldbook-selection-item .item-name {
        font-size: 15px;
        color: var(--text-color);
        flex-grow: 1;
      }
      /* ================== 样式结束 ================== */
      /* ================== 通讯录左滑删除 (新) ================== */
      .contact-item-wrapper {
        overflow: hidden;
        position: relative;
        /* ▼▼▼ 修改这一行 ▼▼▼ */
        background-color: var(--primary-bg);
        border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      }

      .contact-item-deletable {
        display: flex;
        align-items: stretch; /* 让删除按钮和内容区域等高 */
        transition: transform 0.3s ease;
      }

      .contact-item-content {
        display: flex;
        align-items: center;
        padding: 12px 20px;
        cursor: pointer;
        flex-grow: 1;
        /* ▼▼▼ 修改这一行 ▼▼▼ */
        background-color: var(--primary-bg);
        width: 100%;
        flex-shrink: 0;
      }

      /* 同时修改悬停颜色，不然鼠标放上去还是黑的 */
      .contact-item-content:hover {
        /* ▼▼▼ 修改这一行：使用半透明组件色 ▼▼▼ */
        background-color: var(--capsule-bg);
      }

      .delete-char-btn {
        width: 80px; /* 删除按钮的宽度 */
        flex-shrink: 0; /* 防止被压缩 */
        border: none;
        background-color: #ff3b30; /* 醒目的红色 */
        color: white;
        font-weight: bold;
        font-size: 16px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      /* ================== 视频通话 UI (新) ================== */
      #video-call-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: #111;
        z-index: 3000;
        display: flex; /* 使用 flex 方便布局 */
        flex-direction: column;
        justify-content: space-between;
        transition: opacity 0.3s ease;
      }

      /* 大小屏画面通用样式 */
      #video-call-large-view,
      #video-call-small-view {
        position: absolute;
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        background-color: #222;
        transition: all 0.3s ease-in-out;
      }

      /* 大屏样式 */
      #video-call-large-view {
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }

      /* 小屏样式 */
      #video-call-small-view {
        width: 28vw;
        height: 20vh;
        /* bottom: 120px;  <-- 注释或删除这行 */
        top: 25px; /* <-- 新增: 距离顶部25px */
        right: 15px;
        border-radius: 12px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
        z-index: 3002;
        cursor: pointer;
      }

      /* 无图模式下对方信息 */
      #video-call-char-info {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        display: none; /* 默认隐藏 */
        flex-direction: column;
        align-items: center;
        gap: 15px;
        z-index: 3001;
      }

      #video-call-char-info img {
        width: 100px;
        height: 100px;
        border-radius: 50%;
        border: 3px solid rgba(255, 255, 255, 0.2);
      }

      #video-call-char-info span {
        color: var(--text-color);
        font-size: 18px;
        font-weight: bold;
        background-color: rgba(0, 0, 0, 0.3);
        padding: 5px 15px;
        border-radius: 20px;
      }

      /* 对话内容浮层 */
      #video-call-dialogue-overlay {
        position: absolute;
        bottom: 120px; /* 和小窗底部对齐 */
        left: 15px;
        right: 15px;
        max-height: 40%;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 8px;
        z-index: 3003;
        -webkit-mask-image: linear-gradient(to bottom, transparent 0%, black 15%);
        mask-image: linear-gradient(to bottom, transparent 0%, black 15%);
      }

      .video-dialogue-line {
        background-color: rgba(0, 0, 0, 0.5);
        color: #f0f0f0;
        padding: 8px 12px;
        border-radius: 10px;
        max-width: 80%;
        font-size: 15px;
        opacity: 0;
        animation: fadeIn 0.5s forwards;
      }

      .video-dialogue-line.user {
        align-self: flex-end;
        background-color: rgba(0, 122, 255, 0.6);
      }

      .video-dialogue-line.char {
        align-self: flex-start;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      /* 底部控制栏 */
      #video-call-controls {
        width: 100%;
        padding: 20px;
        background: linear-gradient(to top, rgba(0, 0, 0, 0.7), transparent);
        display: flex;
        justify-content: space-around;
        align-items: center;
        z-index: 3004;
        position: absolute;
        bottom: 0;
      }

      .video-control-btn {
        background-color: rgba(255, 255, 255, 0.15);
        border: none;
        border-radius: 50%;
        width: 60px;
        height: 60px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        color: white;
        cursor: pointer;
        transition: background-color 0.2s;
      }

      .video-control-btn:hover {
        background-color: rgba(255, 255, 255, 0.3);
      }

      .video-control-btn.hangup {
        background-color: #ff3b30;
      }

      .video-control-btn.hangup:hover {
        background-color: #ff4d43;
      }

      .video-control-btn svg {
        width: 28px;
        height: 28px;
        margin-bottom: 2px;
      }
      .video-control-btn span {
        font-size: 10px;
        display: none; /* 简洁模式，可以去掉这行来显示文字 */
      }
      /* 在这个注释块的上方或内部添加 */
      #video-call-timer {
        position: absolute;
        top: 25px; /* 和状态栏差不多的高度 */
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(0, 0, 0, 0.4);
        color: var(--text-color);
        padding: 5px 15px;
        border-radius: 20px;
        font-size: 14px;
        z-index: 3005; /* 确保在最顶层 */
        font-family: 'Courier New', Courier, monospace; /* 使用等宽字体，数字跳动时不会晃动 */
      }
      /* ================== 视频通话卡片样式 (新) ================== */
      .video-call-card {
        background-color: #2c2c2e;
        border-radius: 12px;
        padding: 12px 15px;
        display: flex;
        align-items: center;
        gap: 12px;
        cursor: pointer;
        border: 1px solid rgba(255, 255, 255, 0.1);
        transition: background-color 0.2s;
        min-width: 200px;
      }
      .video-call-card:hover {
        background-color: #3a3a3c;
      }
      .video-call-card-icon {
        font-size: 24px;
      }
      .video-call-card-info p {
        margin: 0;
        font-size: 15px;
      }
      .video-call-card-info span {
        font-size: 12px;
        color: var(--text-secondary-color);
      }

      /* ================== 通话记录弹窗列表样式 (新) ================== */
      #call-history-list .history-item {
        background-color: var(--capsule-bg);
        padding: 12px;
        border-radius: 10px;
        margin-bottom: 8px;
        cursor: pointer;
        transition: background-color 0.2s ease;
      }
      #call-history-list .history-item:hover {
        background-color: rgba(255, 255, 255, 0.2);
      }
      #call-history-list .history-item-time {
        font-weight: bold;
        color: var(--text-color);
      }
      #call-history-list .history-item-duration {
        font-size: 13px;
        color: var(--text-secondary-color);
      }

      /* ================== 通话详情弹窗样式 (新) ================== */
      #transcript-modal-content .transcript-line {
        margin-bottom: 10px;
      }
      #transcript-modal-content .transcript-line strong {
        color: var(--accent-color);
      }
      /* ================== 交易记录弹窗样式 (新) ================== */
      #transaction-log-list {
        list-style: none;
        padding: 0;
        margin: 0;
        max-height: 40vh;
        overflow-y: auto;
      }
      .transaction-log-item {
        display: flex;
        justify-content: space-between;
        padding: 12px 8px;
        border-bottom: 1px solid var(--capsule-bg);
      }
      .transaction-log-item:last-child {
        border-bottom: none;
      }
      .transaction-info {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }
      .transaction-description {
        font-size: 14px;
        color: var(--text-color);
      }
      .transaction-date {
        font-size: 11px;
        color: var(--text-secondary-color);
      }
      .transaction-amount {
        font-size: 15px;
        font-weight: bold;
        align-self: center;
      }
      .transaction-amount.income {
        color: #30d158; /* 绿色收入 */
      }
      .transaction-amount.expense {
        color: #ff453a; /* 红色支出 */
      }
      /* ================== 转账卡片样式 (新) ================== */
      .transfer-card {
        background-color: #fa9d3b; /* 萌系的橙色背景，像红包 */
        color: white;
        border-radius: 10px;
        padding: 12px;
        min-width: 220px;
        cursor: pointer;
        transition: filter 0.2s ease, background-color 0.3s ease;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
      }
      .transfer-card:hover {
        filter: brightness(1.1);
      }

      .transfer-card-header {
        display: flex;
        align-items: center;
        gap: 8px;
        padding-bottom: 8px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.3);
      }
      .transfer-card-header .transfer-icon {
        font-size: 24px;
      }
      .transfer-card-header p {
        font-size: 15px;
        margin: 0;
      }

      .transfer-card-body {
        padding: 15px 0;
        text-align: center;
      }
      .transfer-card-body .transfer-amount {
        font-size: 32px;
        font-weight: bold;
        margin: 0;
      }
      .transfer-card-body .transfer-remark {
        font-size: 14px;
        margin: 4px 0 0 0;
        opacity: 0.9;
      }

      .transfer-card-footer {
        font-size: 12px;
        color: rgba(255, 255, 255, 0.8);
        text-align: center;
      }

      .transfer-card-actions {
        display: flex;
        gap: 10px;
        margin-top: 12px;
        justify-content: center;
      }

      .transfer-card-actions .transfer-action-btn {
        background-color: rgba(255, 255, 255, 0.2);
        border: 1px solid white;
        color: white;
        padding: 6px 16px;
        border-radius: 20px;
        cursor: pointer;
        font-size: 13px;
        transition: background-color 0.2s;
      }
      .transfer-card-actions .transfer-action-btn:hover {
        background-color: rgba(255, 255, 255, 0.4);
      }

      /* 已收款/已退还状态 */
      .transfer-card.accepted,
      .transfer-card.refused {
        background-color: #6e6e73; /* 灰色表示已完成 */
      }

      /* 当消息气泡中只有转账卡片时，让气泡背景透明，卡片完全展示 */
      .message-content:has(> .transfer-card:only-child) {
        padding: 0;
        background: transparent;
      }
      /* ================== 礼物商店和购物车样式 (新) ================== */
      .gift-list {
        display: grid;
        grid-template-columns: repeat(2, 1fr); /* 两列布局 */
        gap: 15px;
      }
      .gift-item {
        background-color: var(--capsule-bg);
        border-radius: 12px;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }
      .gift-item-image {
        width: 100%;
        aspect-ratio: 1 / 1;
        background-color: #333; /* 占位背景色 */
        background-size: cover;
        background-position: center;
      }
      .gift-item-info {
        padding: 10px;
        display: flex;
        flex-direction: column;
        gap: 5px;
        flex-grow: 1;
      }
      .gift-item-name {
        font-size: 14px;
        font-weight: bold;
        color: var(--text-color);
      }
      .gift-item-price {
        font-size: 13px;
        color: var(--accent-color);
      }
      .add-to-cart-btn {
        margin-top: auto; /* 将按钮推到底部 */
        padding: 6px 10px;
        font-size: 12px;
        background-color: var(--capsule-nested-bg);
        border: none;
        border-radius: 20px;
        color: var(--text-color);
        cursor: pointer;
        transition: background-color 0.2s;
      }
      .add-to-cart-btn:hover {
        background-color: rgba(255, 255, 255, 0.3);
      }

      /* 购物车样式 */
      .cart-item {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 10px 0;
        border-bottom: 1px solid var(--capsule-bg);
      }
      .cart-item:last-child {
        border-bottom: none;
      }
      .cart-item img {
        width: 50px;
        height: 50px;
        border-radius: 8px;
        object-fit: cover;
      }
      .cart-item-details {
        flex-grow: 1;
      }
      .cart-item-name {
        font-size: 14px;
      }
      .cart-item-price {
        font-size: 12px;
        color: var(--text-secondary-color);
      }
      .remove-cart-item-btn {
        background-color: #ff3b30;
        color: white;
        border: none;
        border-radius: 50%;
        width: 24px;
        height: 24px;
        cursor: pointer;
      }

      /* 聊天中的礼物卡片样式 */
      .gift-card {
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        border-radius: 12px;
        padding: 15px;
        min-width: 230px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
      }
      .gift-card-header {
        display: flex;
        align-items: center;
        gap: 8px;
        padding-bottom: 8px;
        border-bottom: 1px solid rgba(255, 255, 255, 0.2);
      }
      .gift-card-header .gift-icon {
        font-size: 24px;
      }
      .gift-card-header p {
        margin: 0;
        font-weight: bold;
      }
      .gift-card-body {
        padding-top: 10px;
      }
      .gift-card-body ul {
        list-style: none;
        padding: 0;
        margin: 0;
        font-size: 14px;
      }
      .gift-card-body ul li {
        padding: 2px 0;
      }
      .message-content:has(> .gift-card:only-child) {
        padding: 0;
        background: transparent;
      }
      /* ================== 🍓 草莓牛奶·像素游戏机 UI (最终萌化版) 🍓 ================== */

      /* 1. 弹窗容器：像一个复古的游戏机外壳 */
      #fontManagerModal .modal-content {
        /* 背景：改为纯净的背景 */
        background-color: #fff9fb; /* 你也可以改成 #ffffff 纯白 */
        /* background-image: radial-gradient(#FFDEE9 15%, transparent 16%); */ /* 已注释 */
        /* background-size: 10px 10px; */ /* 已注释 */

        /* 边框：双层设计，内白外粉 */
        border: 4px solid #fff;
        outline: 4px solid #ffc6d9;
        border-radius: 30px;

        /* 像素硬阴影：不模糊的蓝色阴影 */
        box-shadow: 8px 8px 0px #a0c4ff, 8px 8px 0px 4px #fff; /* 增加一点白色间隔让阴影更明显 */

        padding: 0;
        width: 90%;
        max-width: 360px;
        overflow: hidden;
        color: #7a656b;
        /* 核心：使用等宽字体增加像素感 */
        font-family: 'Courier New', Courier, monospace, sans-serif;
      }

      /* 2. 头部：像一张收据或者票据的头部 */
      .cute-header {
        background: #fff;
        padding: 15px 20px;
        border-bottom: 3px dashed #ffc6d9; /* 萌系虚线 */
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      /* --- 找到这块代码进行修改 --- */

      .cute-header h3 {
        margin: 0;
        font-size: 18px;
        color: #ff8fab;
        font-weight: 900;
        text-shadow: 2px 2px 0px #ffe5ec;

        /* ▼▼▼ 新增：为了让装饰线和文字对齐 ▼▼▼ */
        display: flex;
        align-items: center;
        gap: 10px; /* 文字和装饰线的间距 */
      }

      /* ▼▼▼ 新增：用 CSS 画一个可爱的装饰条 (替代 Emoji) ▼▼▼ */
      /* 找到这段代码进行修改 */
      .cute-header h3::before {
        content: '';
        display: inline-block;
        width: 8px; /*稍微加宽一点点，渐变更明显*/
        height: 20px;

        /* ▼▼▼ 修改这里：从深粉色(#FF8FAB) 渐变到 浅粉色(#FFC6D9) ▼▼▼ */
        background: linear-gradient(to right, #ff8fab, #ffc6d9);

        border-radius: 4px; /*稍微改小一点圆角，方块感强一点，配合渐变好看*/
        box-shadow: 2px 2px 0px #ffe5ec;
      }

      /* 关闭按钮：像素块风格 */
      .cute-close-btn {
        background: #ffc6d9;
        border: 2px solid #fff;
        color: #fff;
        width: 30px;
        height: 30px;
        border-radius: 50%; /* 圆形 */
        font-size: 14px;
        font-weight: bold;
        cursor: pointer;
        /* 按钮立体感 */
        box-shadow: 2px 2px 0px #ff8fab;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: transform 0.1s;
      }
      .cute-close-btn:active {
        transform: translate(2px, 2px);
        box-shadow: none;
      }

      /* 3. Tabs：像贴纸一样 */
      .cute-tabs {
        display: flex;
        justify-content: center;
        gap: 8px;
        padding: 15px 15px 5px 15px;
        background: rgba(255, 255, 255, 0.6); /* 半透明背景 */
      }
      .cute-tab-btn {
        flex: 1;
        border: 2px solid #ffc6d9;
        background: #fff;
        padding: 8px 0;
        border-radius: 12px;
        font-size: 12px;
        color: #ffb7b2;
        cursor: pointer;
        font-weight: bold;
        font-family: 'Courier New', monospace; /* 像素感字体 */
        position: relative;
        transition: all 0.1s;
      }
      /* 选中状态：变成实心像素块 */
      .cute-tab-btn.active {
        background: #ffc6d9;
        color: #fff;
        /* 像素偏移效果 */
        box-shadow: 3px 3px 0px #ff8fab;
        transform: translate(-1px, -1px);
      }
      .cute-tab-btn.active::after {
        content: '♥';
        position: absolute;
        top: -6px;
        right: -6px;
        font-size: 10px;
        color: #ff8fab;
        transform: rotate(15deg);
      }

      /* 4. 内容区域 */
      .cute-tab-content {
        display: none;
        padding: 15px 20px 25px 20px;
      }
      .cute-tab-content.active {
        display: block;
      }

      /* 5. 输入框：LCD 屏幕风格 */
      .cute-input-group {
        margin-bottom: 12px;
      }
      .cute-label {
        font-size: 12px;
        color: #ff9aa2;
        font-weight: bold;
        margin-bottom: 5px;
        background: #fff;
        display: inline-block;
        padding: 2px 8px;
        border-radius: 8px;
        border: 1px solid #ffc6d9;
      }
      .cute-input,
      .cute-textarea {
        width: 100%;
        padding: 12px;
        /* 稍微深一点的背景，像屏幕 */
        background: #fff0f5;
        border: 2px solid #ffc6d9;
        border-radius: 15px;
        outline: none;
        color: #666;
        font-size: 13px;
        font-family: 'Courier New', monospace;
        /* 内阴影，增加凹陷感 */
        box-shadow: inset 2px 2px 5px rgba(255, 198, 217, 0.4);
      }
      .cute-input:focus {
        background: #fff;
        border-color: #a0c4ff; /* 聚焦变蓝 */
      }
      .cute-textarea {
        min-height: 80px;
        resize: none;
      }

      /* 6. 主按钮：像一块糖果 */
      .cute-btn-primary {
        width: 100%;
        background: #a0c4ff; /* 奶蓝色 */
        border: 2px solid #fff;
        color: #fff;
        padding: 12px;
        border-radius: 16px;
        font-weight: bold;
        font-size: 14px;
        cursor: pointer;
        margin-top: 8px;
        /* 糖果高光 + 硬阴影 */
        box-shadow: inset 3px 3px 0px rgba(255, 255, 255, 0.4), /* 内部高光 */ 4px 4px 0px #749bc2; /* 外部硬阴影 */
        transition: transform 0.1s, box-shadow 0.1s;
        text-shadow: 1px 1px 0px #749bc2;
      }
      .cute-btn-primary:active {
        transform: translate(4px, 4px);
        box-shadow: inset 3px 3px 0px rgba(255, 255, 255, 0.4), 0px 0px 0px transparent;
      }

      /* --- 找到这块代码进行修改 --- */

      /* 7. 字体列表容器 */
      .font-list-container {
        max-height: 260px;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 12px;
        padding-right: 0; /* 修改：不需要给滚动条留位置了 */
        padding-top: 15px; /* 之前加的防遮挡间距保持不变 */

        /* ▼▼▼ 新增：隐藏 Firefox 滚动条 ▼▼▼ */
        scrollbar-width: none;
      }

      /* ▼▼▼ 修改：隐藏 Chrome/Safari 滚动条 ▼▼▼ */
      .font-list-container::-webkit-scrollbar {
        display: none; /* 直接隐藏 */
      }
      /* 下面这两段关于 track 和 thumb 的代码可以删掉或者注释掉，因为已经 display:none 了 */
      /* 
.font-list-container::-webkit-scrollbar-track { background: transparent; }
.font-list-container::-webkit-scrollbar-thumb { background: #FFC6D9; border-radius: 10px; }
*/

      /* ▼▼▼ 新增：萌系滑块样式 (用于字体大小调整) ▼▼▼ */
      .cute-range-container {
        margin-bottom: 15px;
        background: #fff0f5;
        border: 2px dashed #ffc6d9;
        border-radius: 15px;
        padding: 10px 15px;
      }
      .cute-range-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 5px;
        font-size: 12px;
        font-weight: bold;
        color: #ff8fab;
      }
      .cute-range {
        -webkit-appearance: none;
        width: 100%;
        background: transparent;
      }
      .cute-range:focus {
        outline: none;
      }
      /* 滑块轨道 */
      .cute-range::-webkit-slider-runnable-track {
        width: 100%;
        height: 8px;
        cursor: pointer;
        background: #fff;
        border-radius: 4px;
        border: 1px solid #ffc6d9;
      }
      /* 滑块按钮 */
      .cute-range::-webkit-slider-thumb {
        -webkit-appearance: none;
        height: 16px;
        width: 16px;
        border-radius: 50%;
        background: #ff8fab;
        border: 2px solid #fff;
        box-shadow: 2px 2px 0px #ffc6d9;
        margin-top: -5px; /* 居中 */
        cursor: pointer;
        transition: transform 0.1s;
      }
      .cute-range::-webkit-slider-thumb:hover {
        transform: scale(1.2);
      }
      /* ▲▲▲ 新增结束 ▲▲▲ */

      /* 8. 字体卡片：像素风票据 */
      .font-card {
        background: #fff;
        border: 2px dashed #ffc6d9; /* 虚线边框 */
        border-radius: 18px;
        padding: 12px;
        position: relative;
        transition: all 0.2s;
      }

      .font-card:hover {
        background: #fff9fb;
        border-color: #ff9aa2;
        transform: scale(1.02);
      }

      /* 激活状态 */
      .font-card.active {
        background: #ebf8ff; /* 淡蓝色背景 */
        border: 2px solid #a0c4ff; /* 实线蓝边框 */
        box-shadow: 4px 4px 0px #c6e4f5; /* 蓝色硬阴影 */
      }
      /* 右上角的“使用中”标签 */
      .font-card.active::before {
        content: 'Current';
        position: absolute;
        top: -8px;
        right: 10px;
        background: #a0c4ff;
        color: #fff;
        font-size: 10px;
        padding: 2px 6px;
        border-radius: 6px;
        border: 2px solid #fff;
        transform: rotate(5deg);
        z-index: 2;
      }

      .font-name-tag {
        font-size: 13px;
        font-weight: bold;
        color: #ff8fab;
        display: flex;
        align-items: center;
        gap: 5px;
      }
      /* 给标题加个小圆点装饰 */
      .font-name-tag::before {
        content: '';
        display: inline-block;
        width: 8px;
        height: 8px;
        background: #ffc6d9;
        border-radius: 50%;
      }

      .font-preview-text {
        font-size: 15px;
        color: #888;
        margin-top: 8px;
        padding: 5px;
        /* 文字区域背景 */
        background: rgba(0, 0, 0, 0.03);
        border-radius: 8px;
      }

      .font-card-footer {
        display: flex;
        justify-content: flex-end;
        gap: 6px;
        margin-top: 8px;
      }

      /* 小按钮：方块感 */
      .mini-btn {
        padding: 4px 10px;
        border-radius: 8px;
        font-size: 11px;
        border: 1px solid transparent;
        cursor: pointer;
        font-weight: bold;
        font-family: 'Courier New', monospace;
      }
      .mini-btn.apply {
        background: #fff;
        border: 1px solid #a0c4ff;
        color: #a0c4ff;
      }
      .mini-btn.apply:hover {
        background: #a0c4ff;
        color: #fff;
      }
      .mini-btn.delete {
        background: #fff;
        border: 1px solid #ffb7b2;
        color: #ffb7b2;
      }
      .mini-btn.delete:hover {
        background: #ffb7b2;
        color: #fff;
      }

      /* 批量提示框 */
      .batch-tip {
        font-size: 11px;
        color: #999;
        background: #fff;
        padding: 10px;
        border-radius: 12px;
        margin-bottom: 10px;
        text-align: center;
        border: 2px dotted #cfd8dc;
        line-height: 1.6;
      }
      code {
        background: #eee;
        padding: 2px 4px;
        border-radius: 4px;
        color: #555;
        font-family: monospace;
      }
    </style>
  </head>
  <body>
    <div class="phone-screen">
      <div class="status-bar glass-bubble">
        <span class="battery">92%</span>
        <span class="separator">|</span>
        <span class="time" id="current-time">10:25:00</span>
      </div>

      <div class="main-info-bar glass-bubble">
        <div id="profileDot" class="profile-dot"></div>
        <div class="input-area">
          <input id="mainChatInput" type="text" placeholder="和AI聊点什么..." />
          <div class="date-capsule" id="current-date">11月8日 星期五</div>
        </div>
        <div class="lock-widget">
          <svg class="heart-lock" viewBox="0 0 24 24">
            <path
              d="M12.1 18.55l-1.45-1.32C5.4 12.36 2 9.28 2 5.5 2 3.5 3.5 2 5.5 2c1.84 0 3.54.99 4.5 2.5C14.96 2.99 16.66 2 18.5 2 20.5 2 22 3.5 22 5.5c0 3.78-3.4 6.86-8.55 11.73l-1.35 1.32z"
            ></path>
          </svg>
          <span class="temperature">15°</span>
        </div>
      </div>

      <div class="content-section">
        <div class="left-panel">
          <div class="app-grid">
            <div class="app-container" data-app-id="app1">
              <!-- 聊天 (QQ) -->
              <a href="#" class="app-icon"
                ><img src="https://i.postimg.cc/Gh5gh5hK/c3f30de7397cac502c29085c6d1fff58.jpg" alt="app"
              /></a>
              <span class="app-name">QQ</span>
            </div>
            <div class="app-container" data-app-id="app2">
              <!-- 世界书 -->
              <a href="#" id="worldBookAppBtn" class="app-icon"
                ><img src="https://i.postimg.cc/1zcK6Cs5/797b8218855b9e006a4cd857831c858e.png" alt="app"
              /></a>
              <span class="app-name">世界书</span>
            </div>

            <div class="app-container" data-app-id="app3">
              <!-- 外观设置 -->
              <a href="#" id="settingsBtn" class="app-icon"
                ><img src="https://i.postimg.cc/wMSNnLgk/d8a163f79ce90d0f6f601cb8592181cf.jpg" alt="app"
              /></a>
              <span class="app-name">外观设置</span>
            </div>
            <div class="app-container" data-app-id="app4">
              <!-- API设置 -->
              <a href="#" id="apiSettingsBtn" class="app-icon"
                ><img src="https://i.postimg.cc/mrQmjZNP/755833b3720f2479fbdbc98eca523cfa.png" alt="app"
              /></a>
              <span class="app-name">API设置</span>
            </div>
          </div>
        </div>

        <div class="right-panel">
          <div class="profile-section">
            <img id="profileAvatar" class="profile-avatar" src="https://picsum.photos/id/1005/200" alt="avatar" />
            <div class="chat-widget glass-bubble">
              <input id="moodInput" type="text" placeholder="心情..." />
            </div>
          </div>
          <div class="thought-bubble glass-bubble">
            <textarea id="thoughtTextarea" placeholder="输入你的想法..."></textarea>
            <div class="prompt-capsule">
              <svg class="magic-wand-svg" viewBox="0 0 24 24">
                <path
                  d="M14.36,4.64l-4.24,4.24l1.41,1.41l4.24-4.24L14.36,4.64z M15.07,3.93l-1.41-1.41l-4.24,4.24l1.41,1.41 L15.07,3.93z M5.5,14.5c-1.65,0-3,1.35-3,3s1.35,3,3,3s3-1.35,3-3S7.15,14.5,5.5,14.5z M18.5,2.5c-1.65,0-3,1.35-3,3 s1.35,3,3,3s3-1.35,3-3S20.15,2.5,18.5,2.5z M20.91,7.95l-1.41-1.41l-2.12,2.12l1.41,1.41L20.91,7.95z M3.09,16.05l1.41,1.41 l2.12-2.12l-1.41-1.41L3.09,16.05z"
                ></path>
              </svg>
              <input id="magicPromptInput" type="text" placeholder="添加魔法指令..." />
            </div>
          </div>
        </div>
      </div>

      <div class="content-section">
        <div class="left-panel">
          <div class="image-uploader glass-bubble">
            <div id="imagePlaceholder" class="image-placeholder"></div>
            <input id="imageDescriptionInput" type="text" placeholder="为图片添加描述..." />
          </div>
        </div>

        <div class="right-panel">
          <div class="app-grid">
            <div class="app-container" data-app-id="app5">
              <!-- 字体 -->
              <a href="#" class="app-icon"
                ><img src="https://i.postimg.cc/C5tCY9HQ/d89e4fe200f3165695eb9aff60277ea3.jpg" alt="app"
              /></a>
              <span class="app-name">字体</span>
            </div>
            <div class="app-container" data-app-id="app6">
              <!-- 一起听 -->
              <a href="#" class="app-icon"
                ><img src="https://i.postimg.cc/wTC5r8Bz/398450fc25bcfa069b095c6a37fa0306.jpg" alt="app"
              /></a>
              <span class="app-name">一起听</span>
            </div>
            <div class="app-container" data-app-id="app7">
              <!-- 日记 -->
              <a href="#" class="app-icon"
                ><img src="https://i.postimg.cc/FKQZY5tV/27a6afe6f542ad1a3018334ad00ccb97.png" alt="app"
              /></a>
              <span class="app-name">日记</span>
            </div>
            <div class="app-container" data-app-id="app8">
              <!-- 朋友圈 -->
              <a href="#" class="app-icon"
                ><img src="https://i.postimg.cc/1z6jdrSk/ae0f79fe032dcfc3484774cd44b06209.png" alt="app"
              /></a>
              <span class="app-name">朋友圈</span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      const db = new Dexie('MyPhoneSettingsDB');
      db.version(8) // ▼▼▼ 版本号升级到 8 ▼▼▼
        .stores({
          userSettings: '&id',
          userProfilePresets: '++id',
          chatBubblePresets: '++id, name',
          userStickers: '++id, &url, category',
          worldBooks: '++id, &name',
          giftShopItems: '++id, &name',
          apiPresets: '&name',
          customFonts: '++id, &name', // ▼▼▼ 新增：字体表 ▼▼▼
        })
        .upgrade(tx => {});

      document.addEventListener('DOMContentLoaded', () => {
        // --- 元素获取 ---
        const phoneScreen = document.querySelector('.phone-screen');
        const timeElement = document.getElementById('current-time');
        const dateElement = document.getElementById('current-date');
        const fileInput = document.getElementById('imageFileInput');
        const qqContactsPage = document.getElementById('qq-contacts-page');
        const qqChatPage = document.getElementById('qq-chat-page');
        // 弹窗
        const imageChoiceModal = document.getElementById('imageChoiceModal');
        const textEditModal = document.getElementById('textEditModal');
        const settingsModal = document.getElementById('settingsModal');
        const editAppModal = document.getElementById('editAppModal');
        // 新增：获取API设置弹窗
        const apiSettingsModal = document.getElementById('apiSettingsModal');
        const bubbleEditorModal = document.getElementById('bubbleEditorModal');
        const groupManagementModal = document.getElementById('groupManagementModal');
        const deleteGroupConfirmModal = document.getElementById('deleteGroupConfirmModal');
        const chatToolbarToggle = document.getElementById('chat-toolbar-toggle');
        const chatToolbarPanel = document.getElementById('chat-toolbar-panel');
        const userStickerPanel = document.getElementById('user-sticker-panel');
        const toolbarStickerBtn = document.getElementById('toolbar-sticker-btn');
        const sendImageChoiceModal = document.getElementById('sendImageChoiceModal');
        const toolbarImageBtn = document.getElementById('toolbar-image-btn');
        // ▼▼▼ 在这里添加 ▼▼▼
        const textImageModal = document.getElementById('textImageModal');
        const textImageDescriptionInput = document.getElementById('textImageDescriptionInput');
        // ▲▲▲ 添加结束 ▲▲▲
        const videoCallScreen = document.getElementById('video-call-screen');
        const videoCallInviteModal = document.getElementById('video-call-invite-modal');
        const toolbarVideoCallBtn = document.getElementById('toolbar-video-call-btn');
        const toolbarGiftBtn = document.getElementById('toolbar-gift-btn');
        const giftShopPage = document.getElementById('gift-shop-page');
        const shoppingCartModal = document.getElementById('shopping-cart-modal');
        // --- 状态变量 ---
        let currentEditingTarget = null;
        let tempSettings = {};
        let currentSettings = {};
        let currentEditingAppId = null;
        let currentZIndex = 2001;
        let userProfilePresets = []; // 新增：用于存储用户人设预设
        let currentGroupToDelete = null; // 用于记录当前要删除的分组名
        // 新增：API预设的状态变量
        let apiPresets = {};
        let chatData = {}; // 【新增】存储所有聊天数据的核心对象
        let currentChatId = null; // 【新增】记录当前正在聊天的角色ID
        let commonStickers = []; // 存储通用表情包
        let currentEditingNpcId = null; // 记录正在编辑的NPC的ID
        let currentNpcEditMode = 'create'; // 'create' 或 'select'
        let bubblePresets = []; // 存储所有气泡预设
        let currentAppliedBubbleStyleTag = null; // 用于存储动态创建的style标签
        let currentVisualTarget = 'char'; // 'char' 或 'user'
        let visualEditorState = {}; // 用于存储可视化编辑器的状态
        let groupSettings = {};
        let userStickers = []; // 存储用户专属表情包
        let isToolbarOpen = false;
        let isStickerPanelOpen = false;
        let isUserStickerManageMode = false; // 用户表情包管理模式
        let activeUserStickerCategory = '未分类'; // 当前激活的用户表情分类
        let categoryToDelete = null;
        let isVideoCallActive = false;
        let isSmallViewUser = true; // true: 小窗是用户, 大窗是角色
        let callTimerInterval = null; // 用于存放计时器的ID
        let callStartTime = 0; // 用于记录通话开始时间
        let currentCallTranscript = [];
        let pendingCallInfo = null;
        let giftShopItems = []; // 存储礼物商店的商品
        let shoppingCart = []; // 存储购物车中的商品
        let currentApiConfig = {}; // 【新增】用于存储当前生效的API配置
        // 【新增】这个辅助函数
        const fileToBase64 = file =>
          new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.readAsDataURL(file);
            reader.onload = () => resolve(reader.result);
            reader.onerror = error => reject(error);
          });

        // --- 默认设置 ---
        const defaultSettings = {
          wallpaper: '',

          // 1. 背景保持白色
          backgroundColor: '#ffffff',

          // 2. ⚠️ 字体必须改成黑色，否则在白背景上看不见
          fontColor: '#000000', // <--- 原来是 #f0f0f0 (白)，请改成 #000000 (黑)

          // 3. ⚠️ 组件颜色建议改成黑色，配合透明度变成浅灰色
          // 如果这里填白色，在白色背景上就是“隐形”的
          bubbleColor: '#000000', // <--- 原来是 #ffffff (白)，建议改成 #000000 (黑)

          bubbleOpacity: 0.1, // 黑色 + 0.1透明度 = 淡淡的灰色背景，很适合白底

          apps: {},
        };

        // 【恢复并添加】这个 IndexedDB 辅助模块
        // --- Part 1: 设置加载与应用 ---
        /**
         * 格式化秒数为 MM:SS 格式
         * @param {number} totalSeconds - 总秒数
         * @returns {string} 格式化后的时间字符串
         */
        function formatCallTime(totalSeconds) {
          const minutes = Math.floor(totalSeconds / 60)
            .toString()
            .padStart(2, '0');
          const seconds = Math.floor(totalSeconds % 60)
            .toString()
            .padStart(2, '0');
          return `${minutes}:${seconds}`;
        }
        // ▼▼▼ 核心修改 2: 修改设置加载函数，从 IndexedDB 读取 ▼▼▼
        async function loadSettings() {
          // 使用 await 从数据库获取 id 为 'main' 的设置对象
          let savedSettings = (await db.userSettings.get('main')) || {};
          if (!savedSettings.apps) savedSettings.apps = {};

          document.querySelectorAll('.app-container').forEach(app => {
            const id = app.dataset.appId;
            if (!savedSettings.apps[id]) {
              savedSettings.apps[id] = {
                name: app.querySelector('.app-name').textContent,
                icon: app.querySelector('img').src,
              };
            }
          });
          // 返回合并后的设置，确保新用户也有默认值
          return { ...defaultSettings, ...savedSettings };
        }
        // ▲▲▲ 修改结束 ▲▲▲

        // --- Part 1.5: 聊天数据管理 ---

        async function loadChatData() {
          // 从 IndexedDB 读取 id 为 'chatData' 的记录
          const savedDataObject = await db.userSettings.get('chatData');
          // 如果记录存在，则使用它的 value，否则使用空对象
          const savedData = savedDataObject ? savedDataObject.value : {};
          for (const charId in savedData) {
            if (Object.hasOwnProperty.call(savedData, charId)) {
              // 确保角色有 work 和 wallet
              const charSettings = savedData[charId].charSettings;
              if (!charSettings.work) {
                charSettings.work = { profession: '', schedule: '' };
              }
              if (!charSettings.wallet) {
                charSettings.wallet = { balance: 0, initialRange: '', lastSettlementDate: '', transactions: [] };
              } else if (!Array.isArray(charSettings.wallet.transactions)) {
                charSettings.wallet.transactions = [];
              }

              // 【【【核心新增】】】 确保用户有 work 和 wallet
              const userSettings = savedData[charId].userSettings;
              if (!userSettings.work) {
                userSettings.work = { profession: '' };
              }
              if (!userSettings.wallet) {
                userSettings.wallet = {
                  balance: 0,
                  dailySalary: 0,
                  initialBalance: 0,
                  lastSettlementDate: '',
                  transactions: [],
                };
              } else if (!Array.isArray(userSettings.wallet.transactions)) {
                userSettings.wallet.transactions = [];
              }
            }
          }
          // ▲▲▲ 添加结束 ▲▲▲
          // 为已有的联系人提供默认数据，防止出错 (这部分逻辑保留不变)
          document.querySelectorAll('.contact-item').forEach(item => {
            const charId = item.dataset.charId;
            if (!savedData[charId]) {
              savedData[charId] = {
                charSettings: {
                  avatar: item.querySelector('.contact-avatar').src,
                  realName: item.querySelector('.contact-name').textContent.split('-')[1] || '角色',
                  nickname: item.querySelector('.contact-name').textContent,
                  gender: 'female',
                  persona: '这是一个默认角色人设。',
                  maxMemory: 50,
                  // ▼▼▼ 在这里添加新的代码行 ▼▼▼
                  minReplyMessages: 1,
                  maxReplyMessages: 2,
                  // ▲▲▲ 添加结束 ▲▲▲
                  group: '',
                  worldBook: [],
                  npcs: [],
                  exclusiveStickers: [],
                  videoCallImage: '',
                  work: {
                    profession: '',
                    schedule: '',
                  },
                  wallet: {
                    balance: 0,
                    initialRange: '',
                    lastSettlementDate: '',
                    transactions: [],
                  },
                },

                userSettings: {
                  name: '我',
                  gender: 'male',
                  persona: '我是一个默认用户人设。',
                  avatar:
                    localStorage.getItem('profileAvatar') ||
                    'https://i.postimg.cc/ryn2xgwZ/5fc5b9ae74465344658ed8c7e508b8f5.jpg',
                  relationToChar: '朋友',
                  videoCallImage: '',
                  // ▼▼▼ 在 userSettings 中添加下面这两块 ▼▼▼
                  work: {
                    profession: '',
                  },
                  wallet: {
                    balance: 0,
                    dailySalary: 0,
                    initialBalance: 0,
                    lastSettlementDate: '',
                    transactions: [],
                  },
                  // ▲▲▲ 添加结束 ▲▲▲
                },
                history: [],
              };
            }
          });
          chatData = savedData;
          // 注意：这里我们调用 saveChatData() 变成了一个异步操作
          await saveChatData(); // 使用 await 确保默认数据被成功保存
        }

        async function saveChatData() {
          try {
            // 使用 Dexie 将整个 chatData 对象存入 IndexedDB
            // 我们给它一个固定的 id 'chatData'，方便以后读取
            await db.userSettings.put({ id: 'chatData', value: chatData });
          } catch (error) {
            // 捕获可能发生的错误，最常见的还是空间不足
            if (error.name === 'QuotaExceededError') {
              console.error('保存聊天数据失败：IndexedDB 存储空间已满。', error);
              alert('保存失败！存储空间不足。这可能发生在浏览器处于隐私模式或设备磁盘空间已满时。');
            } else {
              console.error('保存聊天数据时发生未知错误：', error);
            }
          }
        }
        async function loadGroupSettings() {
          const savedSettings = await db.userSettings.get('groupSettings');
          // 如果数据库里有，就用；没有的话，就创建一个默认的
          groupSettings = savedSettings ? savedSettings.value : { 默认分组: { expanded: true } };
        }

        async function saveGroupSettings() {
          await db.userSettings.put({ id: 'groupSettings', value: groupSettings });
        }
        // ▲▲▲ 添加结束 ▲▲▲
        function renderContactsList() {
          const list = document.querySelector('.contacts-list');
          list.innerHTML = ''; // 1. 清空旧列表

          const groupedChars = {};
          const ungroupedChars = [];

          for (const charId in chatData) {
            if (Object.hasOwnProperty.call(chatData, charId)) {
              const char = chatData[charId];
              const groupName = char.charSettings.group;

              if (groupName) {
                if (!groupedChars[groupName]) {
                  groupedChars[groupName] = [];
                }
                groupedChars[groupName].push({ id: charId, ...char });
              } else {
                ungroupedChars.push({ id: charId, ...char });
              }
            }
          }

          const createContactItem = char => {
            const history = char.history;
            const lastMessage =
              history.length > 0 ? history[history.length - 1].content : '我们已经是好友了，开始聊天吧！';

            const contactItemWrapper = document.createElement('div');
            contactItemWrapper.className = 'contact-item-wrapper'; // 新增一个外层容器

            contactItemWrapper.innerHTML = `
              <div class="contact-item-deletable">
                <div class="contact-item-content">
                  <img src="${char.charSettings.avatar}" alt="contact avatar" class="contact-avatar">
                  <div class="contact-info">
                    <span class="contact-name">${char.charSettings.nickname}</span>
                    <span class="contact-last-msg">${lastMessage.substring(0, 20)}</span>
                  </div>
                  <span class="contact-time"></span>
                </div>
                <button class="delete-char-btn">删除</button>
              </div>
            `;

            // 找到内容区域并绑定聊天点击事件
            const content = contactItemWrapper.querySelector('.contact-item-content');
            content.addEventListener('click', () => {
              currentChatId = char.id;
              renderChatPage(currentChatId);
              qqChatPage.classList.add('active');
            });

            // 找到删除按钮并绑定删除事件
            const deleteBtn = contactItemWrapper.querySelector('.delete-char-btn');
            deleteBtn.addEventListener('click', e => {
              e.stopPropagation(); // 防止触发聊天
              if (confirm(`确定要删除角色 “${char.charSettings.nickname}” 吗？\n此操作不可恢复！`)) {
                delete chatData[char.id];
                saveChatData().then(() => {
                  renderContactsList(); // 删除后重新渲染整个列表
                });
              }
            });

            // 【核心】为左滑功能添加触摸事件监听
            let startX = 0;
            let currentX = 0;
            const deletableArea = contactItemWrapper.querySelector('.contact-item-deletable');

            content.addEventListener(
              'touchstart',
              e => {
                startX = e.touches[0].clientX;
                deletableArea.style.transition = 'none'; // 滑动时移除过渡效果
              },
              { passive: true },
            );

            content.addEventListener(
              'touchmove',
              e => {
                currentX = e.touches[0].clientX;
                const diffX = startX - currentX;
                if (diffX > 0 && diffX < 100) {
                  // 只允许左滑，并限制最大滑动距离
                  deletableArea.style.transform = `translateX(-${diffX}px)`;
                }
              },
              { passive: true },
            );

            content.addEventListener('touchend', e => {
              const diffX = startX - currentX;
              deletableArea.style.transition = 'transform 0.3s ease'; // 结束时恢复过渡效果
              if (diffX > 40) {
                // 滑动超过40px则完全滑开
                deletableArea.style.transform = 'translateX(-80px)';
              } else {
                // 否则滑回去
                deletableArea.style.transform = 'translateX(0)';
              }
              // 重置
              startX = 0;
              currentX = 0;
            });

            return contactItemWrapper;
          };

          // 首先渲染所有未分组的联系人
          for (const char of ungroupedChars) {
            list.appendChild(createContactItem(char));
          }

          // --- 核心修改：处理置顶排序 ---
          const allGroupNames = Object.keys(groupedChars);
          const pinnedGroups = allGroupNames.filter(name => groupSettings[name]?.pinned).sort();
          const unpinnedGroups = allGroupNames.filter(name => !groupSettings[name]?.pinned).sort();
          const sortedGroupNames = [...pinnedGroups, ...unpinnedGroups];
          // --- 修改结束 ---

          for (const groupName of sortedGroupNames) {
            const details = document.createElement('details');
            details.className = 'contact-group';
            details.open = groupSettings[groupName] ? groupSettings[groupName].expanded : true;

            details.addEventListener('toggle', event => {
              if (!groupSettings[groupName]) {
                groupSettings[groupName] = {};
              }
              groupSettings[groupName].expanded = event.target.open;
              saveGroupSettings();
            });

            const summary = document.createElement('summary');
            summary.className = 'contact-group-header';
            summary.innerHTML = `
              <div class="group-name-wrapper">
                <span class="group-toggle-icon">▶</span>
                <span>${groupName}</span>
              </div>
              <span class="group-member-count">${groupedChars[groupName].length}</span>
            `;
            details.appendChild(summary);

            for (const char of groupedChars[groupName]) {
              details.appendChild(createContactItem(char));
            }
            list.appendChild(details);
          }
        }

        // ▼▼▼ 用这个【新版本】替换旧的 renderChatPage 函数 ▼▼▼
        function renderChatPage(charId) {
          if (!chatData[charId]) return;

          const char = chatData[charId].charSettings;
          const user = chatData[charId].userSettings;

          // 更新顶部头像
          document.getElementById('chat-char-avatar').src = char.avatar;
          document.getElementById('chat-user-avatar').src = user.avatar;

          // 渲染聊天记录
          renderChatMessages(charId);

          // 应用自定义气泡样式
          applyStylesToChatPage(charId);
        }

        // ▼▼▼ 【新增】这个全新的函数，用于渲染聊天消息 ▼▼▼
        function renderChatMessages(charId) {
          const messagesContainer = document.querySelector('.chat-messages');
          if (!messagesContainer || !chatData[charId]) return;

          const { history, charSettings, userSettings } = chatData[charId];

          messagesContainer.innerHTML = history
            .map(msg => {
              if (msg.isSystemNotification) {
                return `
                  <div style="text-align: center; padding: 5px 0; margin-bottom: 10px;">
                    <span style="background-color: var(--capsule-nested-bg); color: var(--text-secondary-color); font-size: 12px; padding: 4px 10px; border-radius: 12px;">
                      ${msg.content.replace('[系统提示：昨日财务结算] ', '')}
                    </span>
                  </div>
                `;
              }
              const isUser = msg.role === 'user';
              const avatar = isUser ? userSettings.avatar : charSettings.avatar;
              const messageClass = isUser ? 'user-message' : 'char-message';

              let contentHTML = msg.content;

              // 特殊处理表情包
              if (contentHTML.startsWith('[sticker]')) {
                const url = contentHTML.replace('[sticker]', '').replace('[/sticker]', '');
                contentHTML = `<img src="${url}" class="message-sticker" style="max-width: 120px; background: transparent;">`;
              } else if (contentHTML.startsWith('[text_image')) {
                // 使用正则表达式从我们定义的格式中提取描述和URL
                const match = contentHTML.match(/\[text_image description="([^"]+)"](.*)\[\/text_image]/);
                if (match) {
                  const description = match[1];
                  const url = match[2];

                  // 生成带 onclick 事件的图片HTML
                  // 注意：为了安全地将描述传入alert，我们对引号和换行符进行转义
                  // ▼▼▼ 核心修改在这里 ▼▼▼
                  const escapedDescription = description
                    .replace(/\\/g, '\\\\') // 1. 先替换反斜杠
                    .replace(/'/g, "\\'") // 2. 替换单引号 (最关键)
                    .replace(/"/g, '\\"') // 3. 替换双引号
                    .replace(/\n/g, '\\n'); // 4. 替换换行符

                  // ▲▲▲ 修改结束 ▲▲▲

                  contentHTML = `<img src="${url}" class="message-image" alt="文字图" onclick="alert('图片描述：\\n${escapedDescription}')" style="cursor: pointer;">`;
                }
              }

              // ▼▼▼ 在这里添加新的语音处理逻辑 ▼▼▼
              else if (contentHTML.startsWith('[语音]')) {
                const voiceText = contentHTML.replace('[语音] ', '');
                // 为了安全地在HTML属性中使用，我们对文本中的引号进行转义
                const escapedVoiceText = voiceText.replace(/"/g, '&quot;').replace(/'/g, '&#39;');

                // 生成包含波纹和隐藏文字的复杂结构
                contentHTML = `
                    <div class="voice-message-container" onclick="toggleVoiceTranscript(this)" data-transcript="${escapedVoiceText}">
                        <span class="voice-icon">🎙️</span>
                        <div class="voice-waveform">
                            <span></span><span></span><span></span><span></span><span></span><span></span><span></span>
                        </div>
                    </div>
                    <p class="voice-transcript">${voiceText}</p>
                  `;
              }
              // ▲▲▲ 添加结束 ▲▲▲
              // ▼▼▼ 在这里添加新的 else if 代码块 ▼▼▼
              else if (contentHTML.startsWith('[视频通话]')) {
                const durationText = contentHTML.replace('[视频通话] ', '');
                const callLogId = msg.callLogId; // 获取我们之前存的ID

                // 生成一个可点击的卡片HTML
                contentHTML = `
        <div class="video-call-card" onclick="showCallTranscript('${charId}', ${callLogId})">
            <span class="video-call-card-icon">📹</span>
            <div class="video-call-card-info">
                <p>视频通话已结束</p>
                <span>${durationText}</span>
            </div>
        </div>
    `;
              } else if (msg.type === 'transfer') {
                // 【核心修正】在这里增加一个安全检查
                if (msg.transferDetails) {
                  // 只有当转账详情存在时，才去渲染卡片
                  contentHTML = generateTransferCardHTML(msg.transferDetails, msg.role);
                } else {
                  // 如果数据不完整，显示一条提示信息，避免程序崩溃
                  console.warn('发现一条不完整的转账消息，已跳过渲染:', msg);
                  contentHTML = `[一条无效的转账记录]`;
                }
              } else if (msg.type === 'gift') {
                const details = msg.giftDetails;
                const itemsHTML = details.items.map(item => `<li>- ${item.name}</li>`).join('');
                contentHTML = `
                      <div class="gift-card">
                          <div class="gift-card-header">
                              <span class="gift-icon">🎁</span>
                              <p>送给 Ta 的一份心意</p>
                          </div>
                          <div class="gift-card-body">
                              <ul>${itemsHTML}</ul>
                          </div>
                      </div>
                  `;
              }
              // ▲▲▲ 添加结束 ▲▲▲
              return `
      <div class="message ${messageClass}">
        ${!isUser ? `<img src="${avatar}" class="message-avatar" alt="avatar">` : ''}
        <div class="message-content">
            ${contentHTML}
        </div>
        ${isUser ? `<img src="${avatar}" class="message-avatar" alt="avatar">` : ''}
      </div>
    `;
            })
            .join('');

          // 滚动到底部
          messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        // --- Part 1: 设置加载与应用 ---

        function loadSettingsFromLocalStorage() {
          let savedSettings = JSON.parse(localStorage.getItem('userSettings')) || {};
          if (!savedSettings.apps) savedSettings.apps = {};
          document.querySelectorAll('.app-container').forEach(app => {
            const id = app.dataset.appId;
            if (!savedSettings.apps[id]) {
              savedSettings.apps[id] = {
                name: app.querySelector('.app-name').textContent,
                icon: app.querySelector('img').src,
              };
            }
          });
          return { ...defaultSettings, ...savedSettings };
        }

        function applySettings(settings) {
          phoneScreen.style.backgroundImage = settings.wallpaper ? `url(${settings.wallpaper})` : 'none';
          // ▼▼▼ 新增：应用背景颜色 ▼▼▼
          if (settings.backgroundColor) {
            document.documentElement.style.setProperty('--primary-bg', settings.backgroundColor);
          }
          // ▲▲▲ 新增结束 ▲▲▲
          document.documentElement.style.setProperty('--text-color', settings.fontColor);
          const rgb = hexToRgb(settings.bubbleColor);
          if (rgb) {
            const bubbleBg = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${settings.bubbleOpacity})`;
            document.documentElement.style.setProperty('--capsule-bg', bubbleBg);
          }
          for (const id in settings.apps) {
            const appElement = document.querySelector(`.app-container[data-app-id="${id}"]`);
            if (appElement) {
              appElement.querySelector('.app-name').textContent = settings.apps[id].name;
              appElement.querySelector('img').src = settings.apps[id].icon;
            }
          }
        }
        // ▼▼▼ 核心修改 3: 修改设置保存函数，写入 IndexedDB ▼▼▼
        async function saveSettings(settings) {
          try {
            // 为要保存的对象设置一个固定的ID，方便我们以后读取
            settings.id = 'main';
            // 使用 await 将数据存入数据库
            await db.userSettings.put(settings);
            console.log('Settings saved to IndexedDB successfully.');
          } catch (error) {
            console.error('Failed to save settings to IndexedDB:', error);
            // 如果保存到IndexedDB也失败了（虽然可能性极低），给用户一个提示
            alert(`保存设置失败: ${error.message}`);
          }
        }
        // --- Part 2: 弹窗控制与数据填充 ---

        const showModal = modal => {
          currentZIndex++;
          modal.style.zIndex = currentZIndex;
          modal.style.display = 'flex';
          setTimeout(() => modal.classList.add('show'), 10);
        };
        const hideModal = modal => {
          modal.classList.remove('show');
          setTimeout(() => {
            modal.style.display = 'none';
            if (parseInt(modal.style.zIndex) === currentZIndex) {
              currentZIndex--;
              if (currentZIndex < 2001) currentZIndex = 2001;
            }
          }, 300);
        };

        function openSettingsModal() {
          tempSettings = JSON.parse(JSON.stringify(currentSettings));
          document.getElementById('wallpaperPreview').style.backgroundImage = tempSettings.wallpaper
            ? `url(${tempSettings.wallpaper})`
            : 'none';
          // ▼▼▼ 新增：填充背景色输入框 ▼▼▼
          // 如果旧数据没有这个字段，给个默认黑色 #ffffff
          const currentBg = tempSettings.backgroundColor || '#ffffff';
          document.getElementById('bgColorPicker').value = currentBg;
          document.getElementById('bgColorInput').value = currentBg;
          // ▲▲▲ 新增结束 ▲▲▲
          document.getElementById('fontColorPicker').value = tempSettings.fontColor;
          document.getElementById('fontColorInput').value = tempSettings.fontColor;
          document.getElementById('bubbleColorPicker').value = tempSettings.bubbleColor;
          document.getElementById('bubbleColorInput').value = tempSettings.bubbleColor;
          document.getElementById('bubbleOpacitySlider').value = tempSettings.bubbleOpacity;
          const appList = document.getElementById('editableAppList');
          appList.innerHTML = '';
          for (const id in tempSettings.apps) {
            const app = tempSettings.apps[id];
            const li = document.createElement('li');
            li.innerHTML = `<img src="${app.icon}" alt="app icon"><span>${app.name}</span><div class="button-group"><button class="edit-app-name-btn" data-app-id="${id}">改名</button><button class="edit-app-icon-btn" data-app-id="${id}">换图标</button></div>`;
            appList.appendChild(li);
          }
          showModal(settingsModal);
        }

        function openEditAppNameModal(appId) {
          currentEditingAppId = appId;
          const appData = tempSettings.apps[appId];
          document.getElementById('editAppName').value = appData.name;
          showModal(editAppModal);
        }

        const hexToRgb = hex => {
          let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
          return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : null;
        };

        // --- Part 3: API 设置功能 (全新) ---
        async function loadApiPresets() {
          // 从数据库读取所有预设，它会返回一个数组
          const presetsArray = await db.apiPresets.toArray();

          // 将数组转换回我们需要的以名称为键的对象格式
          apiPresets = {};
          presetsArray.forEach(preset => {
            apiPresets[preset.name] = preset;
          });

          updatePresetDropdown();
        }

        function updatePresetDropdown() {
          const presetSelect = document.getElementById('presetSelect');
          presetSelect.innerHTML = '<option value="">--选择一个预设--</option>';
          for (const name in apiPresets) {
            const option = document.createElement('option');
            option.value = name;
            option.textContent = name;
            presetSelect.appendChild(option);
          }
        }

        function clearApiInputs() {
          document.getElementById('apiUrlInput').value = '';
          document.getElementById('apiKeyInput').value = '';
          document.getElementById('modelSelect').innerHTML = '';
          document.getElementById('presetNameInput').value = '';
          document.getElementById('presetSelect').value = '';
        }

        // ▼▼▼ 用这个【超级无敌增强版】的函数，完整替换掉你旧的 setupApiEventListeners ▼▼▼
        function setupApiEventListeners() {
          const apiUrlInput = document.getElementById('apiUrlInput');
          const apiKeyInput = document.getElementById('apiKeyInput');
          const modelSelect = document.getElementById('modelSelect');
          const presetSelect = document.getElementById('presetSelect');
          const presetNameInput = document.getElementById('presetNameInput');

          // 【新增】一个辅助函数，用于更新当前的API配置
          const updateCurrentApiConfig = () => {
            currentApiConfig = {
              name: presetNameInput.value.trim() || '未保存的配置', // 给个临时名字
              url: apiUrlInput.value.trim(),
              key: apiKeyInput.value.trim(),
              model: modelSelect.value,
            };
            console.log('Current API config updated:', currentApiConfig);
          };

          // 【新增】监听手动输入，实时更新当前配置
          apiUrlInput.addEventListener('input', updateCurrentApiConfig);
          apiKeyInput.addEventListener('input', updateCurrentApiConfig);
          modelSelect.addEventListener('change', updateCurrentApiConfig);

          // 打开API设置弹窗
          document.getElementById('apiSettingsBtn').addEventListener('click', () => {
            // 打开时，根据 currentApiConfig 填充表单，确保数据一致
            apiUrlInput.value = currentApiConfig.url || '';
            apiKeyInput.value = currentApiConfig.key || '';
            presetNameInput.value = currentApiConfig.name || '';
            // 重新拉取模型并选中
            if (currentApiConfig.url && currentApiConfig.key) {
              modelSelect.dataset.selectedModel = currentApiConfig.model;
              document.getElementById('fetchModelsBtn').click();
            }
            presetSelect.value = localStorage.getItem('selectedApiPreset') || '';
            showModal(apiSettingsModal);
          });

          // 关闭弹窗
          document.getElementById('closeApiSettingsBtn').addEventListener('click', () => {
            hideModal(apiSettingsModal);
          });

          // 拉取模型
          document.getElementById('fetchModelsBtn').addEventListener('click', async () => {
            const url = apiUrlInput.value.trim();
            const key = apiKeyInput.value.trim();
            if (!url || !key) {
              alert('请输入API地址和API Key');
              return;
            }

            // 【新增】拉取模型前，也更新一下当前配置
            updateCurrentApiConfig();

            modelSelect.innerHTML = '<option>正在拉取...</option>';
            try {
              const response = await fetch(`${url}/models`, {
                headers: { Authorization: `Bearer ${key}` },
              });
              if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
              const data = await response.json();
              const models = data.data || data;

              modelSelect.innerHTML = '';
              if (Array.isArray(models) && models.length > 0) {
                models.forEach(model => {
                  const option = document.createElement('option');
                  option.value = model.id;
                  option.textContent = model.id;
                  modelSelect.appendChild(option);
                });

                const presetModel = modelSelect.dataset.selectedModel || currentApiConfig.model;
                if (presetModel && Array.from(modelSelect.options).some(o => o.value === presetModel)) {
                  modelSelect.value = presetModel;
                }
                delete modelSelect.dataset.selectedModel;

                // 【新增】拉取成功后，再次更新当前配置以包含选中的模型
                updateCurrentApiConfig();
              } else {
                modelSelect.innerHTML = '<option>未找到模型</option>';
              }
            } catch (error) {
              console.error('拉取模型失败:', error);
              modelSelect.innerHTML = '<option>拉取失败</option>';
              alert('拉取模型失败，请检查API地址、Key和网络连接。');
            }
          });

          // 另存为预设
          document.getElementById('saveAsPresetBtn').addEventListener('click', async () => {
            const name = presetNameInput.value.trim();
            if (!name) {
              alert('请输入新预设的名称');
              return;
            }

            const newPreset = {
              name: name,
              url: apiUrlInput.value,
              key: apiKeyInput.value,
              model: modelSelect.value,
            };

            try {
              await db.apiPresets.put(newPreset);
              await loadApiPresets();
              presetSelect.value = name;
              localStorage.setItem('selectedApiPreset', name);

              // 【新增】保存后，将当前配置的名称也更新为正式名称
              updateCurrentApiConfig();

              alert('预设已另存为');
            } catch (error) {
              console.error('保存预设失败:', error);
              alert('保存预设失败，请检查控制台。');
            }
          });

          // 更新预设
          document.getElementById('updatePresetBtn').addEventListener('click', async () => {
            const oldName = presetSelect.value;
            if (!oldName) {
              alert('请先从下拉框中选择一个要更新的预设');
              return;
            }
            const newName = presetNameInput.value.trim();
            const finalName = newName || oldName;

            const presetData = {
              name: finalName, // 名字也一起放进去
              url: apiUrlInput.value,
              key: apiKeyInput.value,
              model: modelSelect.value,
            };

            // 如果改了名字，需要先删掉旧的
            if (newName && newName !== oldName) {
              await db.apiPresets.delete(oldName);
            }

            await db.apiPresets.put(presetData);
            await loadApiPresets();
            presetSelect.value = finalName;
            localStorage.setItem('selectedApiPreset', finalName);

            // 【新增】更新后，同步当前配置
            updateCurrentApiConfig();

            alert('预设已更新');
          });

          // 删除预设
          document.getElementById('deletePresetBtn').addEventListener('click', async () => {
            const name = presetSelect.value;
            if (!name) {
              alert('请先从下拉框中选择一个要删除的预设');
              return;
            }
            if (confirm(`确定要删除预设 “${name}” 吗？`)) {
              await db.apiPresets.delete(name);
              await loadApiPresets();
              clearApiInputs();

              // 【新增】如果删除的是当前选中的预设，就清空配置
              if (localStorage.getItem('selectedApiPreset') === name) {
                localStorage.removeItem('selectedApiPreset');
                currentApiConfig = {};
              }

              alert('预设已删除');
            }
          });

          // 选择一个预设时，自动填充信息
          presetSelect.addEventListener('change', e => {
            const name = e.target.value;
            if (name && apiPresets[name]) {
              localStorage.setItem('selectedApiPreset', name);
              const preset = apiPresets[name];

              // 填充UI
              apiUrlInput.value = preset.url;
              apiKeyInput.value = preset.key;
              presetNameInput.value = name;
              modelSelect.innerHTML = '<option>请点击“拉取模型”</option>';

              // 【新增】更新当前配置
              currentApiConfig = { ...preset };

              // 自动拉取并选中
              modelSelect.dataset.selectedModel = preset.model;
              document.getElementById('fetchModelsBtn').click();
            } else {
              clearApiInputs();
              // 【新增】清空当前配置
              currentApiConfig = {};
              localStorage.removeItem('selectedApiPreset');
            }
          });
        }

        // --- Part 3.5: 用户人设预设功能 (全新) ---

        // 从数据库加载预设到内存
        async function loadUserProfilePresets() {
          try {
            userProfilePresets = await db.userProfilePresets.toArray();
          } catch (error) {
            console.error('加载用户人设预设失败:', error);
          }
        }

        // 将内存中的预设渲染到弹窗的列表中
        function renderUserProfilePresets() {
          const listElement = document.getElementById('userPresetsList');
          if (!listElement) return;
          listElement.innerHTML = ''; // 清空旧列表

          if (userProfilePresets.length === 0) {
            listElement.innerHTML =
              '<li style="text-align: center; color: var(--text-secondary-color); font-size: 13px; padding: 10px 0;">还没有预设哦</li>';
            return;
          }

          userProfilePresets.forEach(preset => {
            const li = document.createElement('li');
            li.className = 'user-preset-item';
            li.dataset.presetId = preset.id; // 将数据库ID存起来方便操作

            const personaPreview = preset.persona
              ? preset.persona.substring(0, 20) + (preset.persona.length > 20 ? '...' : '')
              : '未设置人设';

            li.innerHTML = `
      <img src="${preset.avatar}" alt="preset avatar">
      <div class="preset-info">
        <span class="preset-name">${preset.name || '未命名'}</span>
        <span class="preset-persona-preview">${personaPreview}</span>
      </div>
      <button class="delete-preset-btn" data-preset-id="${preset.id}">&times;</button>
    `;
            listElement.appendChild(li);
          });
        }

        // 应用一个预设到当前的编辑框
        function applyUserPreset(presetId) {
          const preset = userProfilePresets.find(p => p.id === parseInt(presetId));
          if (!preset) return;

          document.getElementById('userSettingsAvatarPreview').src = preset.avatar;
          document.getElementById('userName').value = preset.name;
          document.getElementById('userPersona').value = preset.persona;
          if (preset.gender) {
            document.getElementById('userGender').value = preset.gender;
          }
        }

        // 删除一个预设
        async function deleteUserPreset(presetId) {
          const id = parseInt(presetId);
          if (confirm('确定要删除这个预设吗？')) {
            try {
              await db.userProfilePresets.delete(id);
              await loadUserProfilePresets(); // 重新从数据库加载
              renderUserProfilePresets(); // 重新渲染列表
            } catch (error) {
              console.error(`删除预设 ID:${id} 失败:`, error);
            }
          }
        }

        // 保存当前表单信息为一个新预设
        async function saveCurrentUserAsPreset() {
          const newPreset = {
            avatar: document.getElementById('userSettingsAvatarPreview').src,
            name: document.getElementById('userName').value.trim(),
            gender: document.getElementById('userGender').value,
            persona: document.getElementById('userPersona').value.trim(),
          };

          if (!newPreset.name) {
            alert('请在“我的名字”中为此预设命名！');
            document.getElementById('userName').focus();
            return;
          }

          try {
            await db.userProfilePresets.add(newPreset);
            await loadUserProfilePresets(); // 重新从数据库加载
            renderUserProfilePresets(); // 重新渲染列表
            alert(`预设 "${newPreset.name}" 已保存！`);
          } catch (error) {
            console.error('保存新预设失败:', error);
            alert('保存失败，请稍后再试。');
          }
        }
        // 新增函数：动态地将一个新联系人添加到UI列表
        function addContactToList(charId) {
          const list = document.querySelector('.contacts-list');
          if (!list || !chatData[charId]) return;

          const data = chatData[charId].charSettings;
          const newItem = document.createElement('div');
          newItem.className = 'contact-item';
          newItem.dataset.charId = charId;

          newItem.innerHTML = `
              <img src="${data.avatar}" alt="contact avatar" class="contact-avatar">
              <div class="contact-info">
                <span class="contact-name">${data.nickname}</span>
                <span class="contact-last-msg">我们已经是好友了，开始聊天吧！</span>
              </div>
              <span class="contact-time">刚刚</span>
            `;

          // 关键：为新创建的联系人也绑定点击事件
          newItem.addEventListener('click', () => {
            currentChatId = charId;
            renderChatPage(currentChatId);
            qqChatPage.classList.add('active');
          });

          list.appendChild(newItem);
        }

        // 新增函数：创建新人物的核心逻辑
        async function createNewCharacter() {
          const nickname = document.getElementById('newCharNickname').value.trim();
          if (!nickname) {
            alert('“备注”是必填项，请填写一个名称。');
            return;
          }

          const realName = document.getElementById('newCharRealName').value.trim();
          const persona = document.getElementById('newCharPersona').value.trim();
          let avatar = document.getElementById('newCharAvatarPreview').src;

          // 确认是否是默认头像, 如果是, 则随机生成一个
          if (avatar.includes('picsum.photos/seed/default')) {
            const randomSeed = Math.floor(Math.random() * 1000);
            avatar = `https://picsum.photos/seed/${randomSeed}/100`;
          }

          const newCharId = `char${Date.now()}`;

          // 构建新角色的数据结构
          chatData[newCharId] = {
            charSettings: {
              avatar: avatar,
              realName: realName,
              nickname: nickname,
              gender: 'female', // 默认值
              persona: persona || '这是一个新创建的角色。', // 默认人设
              maxMemory: 50,
              group: '',
              worldBook: [],
              // ▼▼▼▼▼▼▼▼ 新增这两行初始化代码 ▼▼▼▼▼▼▼▼
              work: { profession: '', schedule: '' },
              wallet: { balance: 0, initialRange: '', transactions: [] },
              // ▲▲▲▲▲▲▲▲ 新增结束 ▲▲▲▲▲▲▲▲
            },
            userSettings: {
              // 沿用一个默认的用户设置
              name: '我',
              gender: 'male',
              persona: '我是一个默认用户人设。',
              avatar:
                (await db.userSettings.get('profileAvatar'))?.value ||
                'https://i.postimg.cc/ryn2xgwZ/5fc5b9ae74465344658ed8c7e508b8f5.jpg', // 这里我也帮你同步改好了默认头像
              // ▼▼▼▼▼▼▼▼ 这里的用户钱包也要初始化，防止以后报错 ▼▼▼▼▼▼▼▼
              work: { profession: '' },
              wallet: { balance: 0, dailySalary: 0, initialBalance: 0, transactions: [] },
              // ▲▲▲▲▲▲▲▲ 新增结束 ▲▲▲▲▲▲▲▲
            },
            history: [],
          };

          await saveChatData(); // 保存到数据库
          renderContactsList(); // 更新UI界面
          hideModal(document.getElementById('addCharModal')); // 关闭弹窗
        }

        // 从数据库加载气泡预设
        async function loadBubblePresets() {
          bubblePresets = await db.chatBubblePresets.toArray();
        }

        // 渲染预设到下拉框
        function renderBubblePresetsDropdown() {
          const select = document.getElementById('bubblePresetSelect');
          select.innerHTML = '<option value="">-- 加载一个预设 --</option>';
          bubblePresets.forEach(preset => {
            const option = document.createElement('option');
            option.value = preset.id;
            option.textContent = preset.name;
            select.appendChild(option);
          });
        }

        // 应用 CSS 到预览气泡
        function applyBubblePreview(css) {
          // 创建一个临时的style标签来应用样式，避免污染全局
          const styleId = 'bubble-preview-style';
          let styleTag = document.getElementById(styleId);
          if (!styleTag) {
            styleTag = document.createElement('style');
            styleTag.id = styleId;
            document.head.appendChild(styleTag);
          }
          // 使用CSS选择器来限定只影响预览区的气泡
          styleTag.innerHTML = `
    #charBubblePreview { ${css} }
    #userBubblePreview { ${css} }
  `;
        }

        // 保存预设
        async function saveBubbleAsPreset() {
          const css = document.getElementById('bubbleCssInput').value.trim();
          if (!css) {
            alert('CSS代码不能为空！');
            return;
          }
          const name = prompt('请输入新预设的名称:');
          if (!name) return;

          if (bubblePresets.some(p => p.name === name)) {
            if (!confirm(`名为 "${name}" 的预设已存在，要覆盖它吗？`)) {
              return;
            }
            // 先删除同名
            await db.chatBubblePresets.where('name').equals(name).delete();
          }

          const newPreset = { name, css };
          await db.chatBubblePresets.add(newPreset);
          await loadBubblePresets();
          renderBubblePresetsDropdown();
          alert('预设已保存！');
        }

        // 删除预设
        async function deleteBubblePreset() {
          const select = document.getElementById('bubblePresetSelect');
          const presetId = parseInt(select.value);
          if (!presetId) {
            alert('请先选择一个要删除的预设。');
            return;
          }
          if (confirm('确定要删除这个预设吗？')) {
            await db.chatBubblePresets.delete(presetId);
            await loadBubblePresets();
            renderBubblePresetsDropdown();
            document.getElementById('bubbleCssInput').value = '';
            applyBubblePreview('');
          }
        }

        // ▼▼▼ 用这个 V3 新版本替换旧的 openBubbleEditor 函数 ▼▼▼
        async function openBubbleEditor() {
          if (!currentChatId) return;
          visualEditorState = {
            char: {
              bgType: 'solid',
              solid: { color: '#363638' },
              gradient: { start: '#4e54c8', end: '#8f94fb', direction: 'to right', bisection: false },
              image: { url: '' },
              borderRadius: '18px',
              glass: {
                enabled: false,
                bgType: 'solid',
                solid: { color: '#ffffff' },
                gradient: { start: '#ffffff', end: '#000000', direction: 'to right' },
                opacity: 0.1,
                blur: '10px',
              },
            },
            user: {
              bgType: 'solid',
              solid: { color: '#007aff' },
              gradient: { start: '#00c6ff', end: '#0072ff', direction: 'to right', bisection: false },
              image: { url: '' },
              borderRadius: '18px',
              glass: {
                enabled: false,
                bgType: 'solid',
                solid: { color: '#ffffff' },
                gradient: { start: '#ffffff', end: '#000000', direction: 'to right' },
                opacity: 0.1,
                blur: '10px',
              },
            },
          };

          currentVisualTarget = 'char';
          document.querySelector('input[name="editTarget"][value="char"]').checked = true;

          await loadBubblePresets();
          renderBubblePresetsDropdown();

          // 清空CSS输入框并加载可视化编辑器的初始状态
          document.getElementById('bubbleCssInput').value = '';
          document.getElementById('bubblePresetSelect').value = '';
          loadStateToVisualEditor('char');
          updateVisualPreview();

          showModal(bubbleEditorModal);
        }

        // ▼▼▼ 用这个新版本替换旧的 loadStateToVisualEditor 函数 ▼▼▼
        function loadStateToVisualEditor(target) {
          const state = visualEditorState[target];

          // 1. 设置主背景 (不变)
          document.getElementById('bgTypeSelect').value = state.bgType;
          document.querySelectorAll('#visualEditorTab > .control-group').forEach(el => (el.style.display = 'none'));
          if (state.bgType === 'solid') document.getElementById('solidColorControls').style.display = 'block';
          else if (state.bgType === 'gradient') document.getElementById('gradientControls').style.display = 'block';
          else if (state.bgType === 'image') document.getElementById('imageControls').style.display = 'block';

          // 2. 填充主背景控件的值
          document.getElementById('bubbleBgColor').value = state.solid.color;
          document.getElementById('bubbleBgColorHex').value = state.solid.color;
          document.getElementById('gradientStartColor').value = state.gradient.start;
          document.getElementById('gradientStartColorHex').value = state.gradient.start;
          document.getElementById('gradientEndColor').value = state.gradient.end;
          document.getElementById('gradientEndColorHex').value = state.gradient.end;
          document.getElementById('gradientDirection').value = state.gradient.direction;
          document.getElementById('gradientBisection').checked = state.gradient.bisection;
          document.getElementById('imageUrlInput').value = state.image.url;

          const radius = parseInt(state.borderRadius) || 18;
          document.getElementById('bubbleBorderRadius').value = radius;
          document.getElementById('bubbleBorderRadiusValue').textContent = `${radius}px`;

          // 3. 填充毛玻璃控件 (核心修改)
          const glassState = state.glass;
          document.getElementById('glassEffectEnabled').checked = glassState.enabled;
          document.getElementById('glassEffectControls').style.display = glassState.enabled ? 'block' : 'none';

          // 3.1 控制毛玻璃的背景类型
          document.getElementById('glassBgTypeSelect').value = glassState.bgType;
          document.getElementById('glassSolidColorControls').style.display =
            glassState.bgType === 'solid' ? 'block' : 'none';
          document.getElementById('glassGradientControls').style.display =
            glassState.bgType === 'gradient' ? 'block' : 'none';

          // 3.2 填充毛玻璃的颜色值
          document.getElementById('glassEffectColor').value = glassState.solid.color;
          document.getElementById('glassEffectColorHex').value = glassState.solid.color;
          document.getElementById('glassGradientStartColor').value = glassState.gradient.start;
          document.getElementById('glassGradientStartColorHex').value = glassState.gradient.start;
          document.getElementById('glassGradientEndColor').value = glassState.gradient.end;
          document.getElementById('glassGradientEndColorHex').value = glassState.gradient.end;
          document.getElementById('glassGradientDirection').value = glassState.gradient.direction;

          // 3.3 填充毛玻璃的通用值
          document.getElementById('glassEffectOpacity').value = glassState.opacity;
          document.getElementById('glassEffectOpacityValue').textContent = glassState.opacity;
          const blur = parseInt(glassState.blur) || 10;
          document.getElementById('glassEffectBlur').value = blur;
          document.getElementById('glassEffectBlurValue').textContent = `${blur}px`;
        }

        // 切换编辑目标 (char/user)
        function switchVisualEditorTarget(target) {
          currentVisualTarget = target;
          loadStateToVisualEditor(target);
        }

        // ▼▼▼ 用这个新版本替换旧的 updateVisualPreview 函数 ▼▼▼
        function updateVisualPreview() {
          for (const target of ['char', 'user']) {
            const state = visualEditorState[target];
            const previewBubble = document.getElementById(`${target}BubblePreview`);

            // 1. 准备主背景
            let mainBackgroundImage = 'none';
            let mainBackgroundColor = 'transparent';

            if (state.bgType === 'solid') {
              mainBackgroundColor = state.solid.color;
            } else if (state.bgType === 'gradient') {
              const stops = state.gradient.bisection ? ' 50%' : '';
              if (state.gradient.direction.startsWith('radial')) {
                const colors =
                  state.gradient.direction === 'radial-center-out'
                    ? `${state.gradient.start}, ${state.gradient.end}`
                    : `${state.gradient.end}, ${state.gradient.start}`;
                mainBackgroundImage = `radial-gradient(circle, ${colors})`;
              } else {
                mainBackgroundImage = `linear-gradient(${state.gradient.direction}, ${state.gradient.start}${stops}, ${state.gradient.end}${stops})`;
              }
            } else if (state.bgType === 'image' && state.image.url) {
              mainBackgroundImage = `url('${state.image.url}')`;
              previewBubble.style.backgroundSize = 'cover';
              previewBubble.style.backgroundPosition = 'center';
            }

            // 2. 应用毛玻璃或主背景
            if (state.glass.enabled) {
              previewBubble.style.backdropFilter = `blur(${state.glass.blur})`;
              previewBubble.style.webkitBackdropFilter = `blur(${state.glass.blur})`;

              const { r: r_start, g: g_start, b: b_start } = hexToRgb(state.glass.gradient.start);
              const { r: r_end, g: g_end, b: b_end } = hexToRgb(state.glass.gradient.end);
              const startColorRgba = `rgba(${r_start}, ${g_start}, ${b_start}, ${state.glass.opacity})`;
              const endColorRgba = `rgba(${r_end}, ${g_end}, ${b_end}, ${state.glass.opacity})`;

              if (state.glass.bgType === 'solid') {
                const { r, g, b } = hexToRgb(state.glass.solid.color);
                previewBubble.style.backgroundColor = `rgba(${r}, ${g}, ${b}, ${state.glass.opacity})`;
                previewBubble.style.backgroundImage = 'none'; // 清除可能存在的渐变背景
              } else {
                // gradient
                if (state.glass.gradient.direction.startsWith('radial')) {
                  const colors =
                    state.glass.gradient.direction === 'radial-center-out'
                      ? `${startColorRgba}, ${endColorRgba}`
                      : `${endColorRgba}, ${startColorRgba}`;
                  previewBubble.style.backgroundImage = `radial-gradient(circle, ${colors})`;
                } else {
                  previewBubble.style.backgroundImage = `linear-gradient(${state.glass.gradient.direction}, ${startColorRgba}, ${endColorRgba})`;
                }
                previewBubble.style.backgroundColor = 'transparent';
              }
            } else {
              // 如果禁用毛玻璃，则恢复主背景
              previewBubble.style.backdropFilter = 'none';
              previewBubble.style.webkitBackdropFilter = 'none';
              previewBubble.style.backgroundColor = mainBackgroundColor;
              previewBubble.style.backgroundImage = mainBackgroundImage;
            }

            // 3. 应用其他样式
            previewBubble.style.borderRadius = state.borderRadius;
          }
        }
        // ▼▼▼ 用这个新版本替换旧的 generateCssString 函数 ▼▼▼
        function generateCssString(target) {
          const state = visualEditorState[target];
          let css = `position: relative; overflow: hidden;`;

          // 1. 生成主背景CSS (仅在毛玻璃关闭时)
          if (!state.glass.enabled) {
            if (state.bgType === 'solid') {
              css += `background-image: none; background-color: ${state.solid.color};`;
            } else if (state.bgType === 'gradient') {
              const stops = state.gradient.bisection ? ' 50%' : '';
              let gradientValue;
              if (state.gradient.direction.startsWith('radial')) {
                const colors =
                  state.gradient.direction === 'radial-center-out'
                    ? `${state.gradient.start}, ${state.gradient.end}`
                    : `${state.gradient.end}, ${state.gradient.start}`;
                gradientValue = `radial-gradient(circle, ${colors})`;
              } else {
                gradientValue = `linear-gradient(${state.gradient.direction}, ${state.gradient.start}${stops}, ${state.gradient.end}${stops})`;
              }
              css += `background-image: ${gradientValue};`;
            } else if (state.bgType === 'image' && state.image.url) {
              css += `background-image: url('${state.image.url}'); background-size: cover; background-position: center;`;
            }
          }

          // 2. 生成毛玻璃CSS
          if (state.glass.enabled) {
            if (state.glass.bgType === 'solid') {
              const rgb = hexToRgb(state.glass.solid.color);
              if (rgb) css += `background-color: rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${state.glass.opacity});`;
            } else {
              // gradient
              const { r: r_start, g: g_start, b: b_start } = hexToRgb(state.glass.gradient.start);
              const { r: r_end, g: g_end, b: b_end } = hexToRgb(state.glass.gradient.end);
              const startColorRgba = `rgba(${r_start}, ${g_start}, ${b_start}, ${state.glass.opacity})`;
              const endColorRgba = `rgba(${r_end}, ${g_end}, ${b_end}, ${state.glass.opacity})`;

              let gradientValue;
              if (state.glass.gradient.direction.startsWith('radial')) {
                const colors =
                  state.glass.gradient.direction === 'radial-center-out'
                    ? `${startColorRgba}, ${endColorRgba}`
                    : `${endColorRgba}, ${startColorRgba}`;
                gradientValue = `radial-gradient(circle, ${colors})`;
              } else {
                gradientValue = `linear-gradient(${state.glass.gradient.direction}, ${startColorRgba}, ${endColorRgba})`;
              }
              css += `background-image: ${gradientValue};`;
            }
            css += `backdrop-filter: blur(${state.glass.blur}); -webkit-backdrop-filter: blur(${state.glass.blur});`;
          }

          css += `border-radius: ${state.borderRadius};`;
          return css;
        }

        // 让图层图片可拖拽
        function makeDraggable(element, stateObject) {
          let pos1 = 0,
            pos2 = 0,
            pos3 = 0,
            pos4 = 0;

          element.onmousedown = dragMouseDown;
          element.style.pointerEvents = 'auto';
          element.style.cursor = 'move';

          function dragMouseDown(e) {
            e.preventDefault();
            pos3 = e.clientX;
            pos4 = e.clientY;
            document.onmouseup = closeDragElement;
            document.onmousemove = elementDrag;
          }

          function elementDrag(e) {
            e.preventDefault();
            pos1 = pos3 - e.clientX;
            pos2 = pos4 - e.clientY;
            pos3 = e.clientX;
            pos4 = e.clientY;

            const newTop = element.offsetTop - pos2;
            const newLeft = element.offsetLeft - pos1;

            element.style.top = newTop + 'px';
            element.style.left = newLeft + 'px';

            // 更新状态
            stateObject.x = newLeft;
            stateObject.y = newTop;
          }

          function closeDragElement() {
            document.onmouseup = null;
            document.onmousemove = null;
          }
        }

        // ▼▼▼ 用这个新版本替换旧的 applyBubblePresetToChar 函数 ▼▼▼
        async function applyBubblePresetToChar() {
          if (!currentChatId) return;

          // 决定是从可视化生成，还是直接用CSS代码
          const isVisualTabActive = document.getElementById('visualEditorTab').classList.contains('active');
          let cssToApply;

          if (isVisualTabActive) {
            alert('将根据可视化编辑器的当前状态进行应用。若要应用预设或纯代码，请先切换到CSS代码页并加载预设。');
            const charCss = generateCssString('char');
            const userCss = generateCssString('user');
            // 保存时，我们用一种能被解析的格式
            cssToApply = JSON.stringify({ char: charCss, user: userCss });
          } else {
            const rawCss = document.getElementById('bubbleCssInput').value;
            if (!rawCss) {
              alert('CSS代码为空，无法应用！');
              return;
            }
            // 如果是纯CSS，我们直接保存
            cssToApply = rawCss;
          }

          // 将生成的样式字符串保存到 chatData 中
          // 我们用一个新字段 `bubbleStyle` 来存储
          chatData[currentChatId].charSettings.bubbleStyle = cssToApply;

          await saveChatData();
          // 立即应用效果，而不是等下次进入
          await applyStylesToChatPage(currentChatId);
          alert('应用成功！');
          hideModal(bubbleEditorModal);
        }

        // ▼▼▼ 使用这个【修正后】的版本，替换你代码中旧的 applyStylesToChatPage 函数 ▼▼▼
        async function applyStylesToChatPage(charId) {
          if (!charId) charId = currentChatId;

          // 每次应用前都先清除旧的样式
          if (currentAppliedBubbleStyleTag) {
            currentAppliedBubbleStyleTag.remove();
            currentAppliedBubbleStyleTag = null;
          }

          if (!charId || !chatData[charId] || !chatData[charId].charSettings.bubbleStyle) {
            return;
          }

          const styleData = chatData[charId].charSettings.bubbleStyle;
          let finalCss = '';

          try {
            // 尝试解析来自可视化编辑器的JSON格式样式
            const parsedStyles = JSON.parse(styleData);

            // 【关键修正】为 char 的样式规则加上了必要的大括号 {}
            if (parsedStyles.char) {
              finalCss += `#qq-chat-page .char-message .message-content { ${parsedStyles.char} }\n`;
            }

            // 【关键修正】为 user 的样式规则加上了必要的大括号 {}
            if (parsedStyles.user) {
              finalCss += `#qq-chat-page .user-message .message-content { ${parsedStyles.user} }\n`;
            }
          } catch (e) {
            // 如果解析失败，说明是用户手动输入的纯CSS，直接使用
            finalCss = styleData;
          }

          if (finalCss) {
            currentAppliedBubbleStyleTag = document.createElement('style');
            currentAppliedBubbleStyleTag.id = 'dynamic-bubble-styles';
            currentAppliedBubbleStyleTag.innerHTML = finalCss;
            document.head.appendChild(currentAppliedBubbleStyleTag);
          }
        }

        // =================================================================
        // ================== 分组管理核心逻辑 (新) ==================
        // =================================================================

        // 渲染分组管理列表
        function renderGroupManagementList() {
          const listEl = document.getElementById('groupManagementList');
          listEl.innerHTML = '';

          const groupCharCounts = {};
          let ungroupedCount = 0;

          // 统计每个分组和未分组的人数
          for (const charId in chatData) {
            const group = chatData[charId].charSettings.group;
            if (group) {
              groupCharCounts[group] = (groupCharCounts[group] || 0) + 1;
            } else {
              ungroupedCount++;
            }
          }

          // 渲染 "未分组" 条目
          const ungroupedLi = document.createElement('li');
          ungroupedLi.className = 'group-manage-item is-ungrouped'; // 添加特殊class
          ungroupedLi.innerHTML = `
                <div class="group-info">
                    <span class="group-name">未分组的角色</span>
                    <span class="group-char-count">共 ${ungroupedCount} 人</span>
                </div>
                <div class="group-controls"></div>
            `;
          listEl.appendChild(ungroupedLi);

          // 渲染所有真实的分组
          const sortedGroupNames = Object.keys(groupSettings).sort();

          // 为了更好的体验，置顶的也排在前面
          const pinned = sortedGroupNames.filter(name => groupSettings[name]?.pinned);
          const unpinned = sortedGroupNames.filter(name => !groupSettings[name]?.pinned);

          [...pinned, ...unpinned].forEach(groupName => {
            const settings = groupSettings[groupName];
            const count = groupCharCounts[groupName] || 0;
            const li = document.createElement('li');
            li.className = 'group-manage-item';
            li.dataset.groupName = groupName;

            li.innerHTML = `
                    <div class="group-info">
                        <span class="group-name">${groupName}</span>
                        <span class="group-char-count">共 ${count} 人</span>
                    </div>
                    <div class="group-controls">
                        <label class="control-label">
                            展开 <input type="checkbox" class="group-expand-toggle" ${
                              settings.expanded ? 'checked' : ''
                            }>
                        </label>
                        <button class="pin-group-btn ${settings.pinned ? 'pinned' : ''}">置顶</button>
                        <button class="delete-group-btn" style="background-color: #ff3b30; color: white;">删除</button>
                    </div>
                `;
            listEl.appendChild(li);
          });
        }

        // 打开分组管理弹窗
        function openGroupManagementModal() {
          renderGroupManagementList();
          showModal(groupManagementModal);
        }

        // 新增分组
        async function addNewGroup() {
          const input = document.getElementById('newGroupNameInput');
          const newName = input.value.trim();
          if (!newName) {
            alert('分组名不能为空！');
            return;
          }
          if (groupSettings[newName]) {
            alert('该分组已存在！');
            return;
          }
          groupSettings[newName] = { expanded: true, pinned: false };
          await saveGroupSettings();
          input.value = '';
          renderGroupManagementList(); // 重新渲染列表
        }

        // 删除分组（处理函数）
        async function handleGroupDeletion(mode) {
          if (!currentGroupToDelete) return;

          const groupNameToDelete = currentGroupToDelete;

          if (mode === 'all') {
            // 删除分组和角色
            // 找出所有需要删除的角色 ID
            const charIdsToDelete = Object.keys(chatData).filter(
              id => chatData[id].charSettings.group === groupNameToDelete,
            );
            // 从 chatData 中删除这些角色
            charIdsToDelete.forEach(id => {
              delete chatData[id];
            });
          } else {
            // 'only_group' - 仅删除分组
            // 遍历 chatData，将属于该分组的角色的 group 设为空
            for (const charId in chatData) {
              if (chatData[charId].charSettings.group === groupNameToDelete) {
                chatData[charId].charSettings.group = '';
              }
            }
          }

          // 从 groupSettings 中删除该分组的设置
          delete groupSettings[groupNameToDelete];

          // 保存数据
          await saveChatData();
          await saveGroupSettings();

          // 清理状态并更新UI
          currentGroupToDelete = null;
          hideModal(deleteGroupConfirmModal);
          renderGroupManagementList();
          renderContactsList(); // 关键：同时更新主通讯录列表
        }
        window.toggleVoiceTranscript = function (element) {
          // 找到与被点击的语音消息相关联的文字段落
          const transcriptElement = element.nextElementSibling;

          if (transcriptElement && transcriptElement.classList.contains('voice-transcript')) {
            // 切换显示/隐藏状态
            if (transcriptElement.style.display === 'block') {
              transcriptElement.style.display = 'none';
            } else {
              transcriptElement.style.display = 'block';
            }
          }
        };
        // 封装关闭所有面板的函数，方便复用
        function closeAllPanels() {
          chatToolbarToggle.classList.remove('active');
          document.getElementById('qq-chat-page').classList.remove('toolbar-open');

          chatToolbarPanel.style.height = '0px';
          userStickerPanel.style.height = '0px';

          isToolbarOpen = false;
          isStickerPanelOpen = false;
        }
        // --- Part 4: 事件监听器 ---
        // ▼▼▼ 在这里修改 ▼▼▼
        function findSticker(keyword, charId) {
          if (!keyword) return null;

          // 1. (保留) 检查本身是否为URL
          if (keyword.startsWith('http://') || keyword.startsWith('https://') || keyword.startsWith('data:image')) {
            return keyword;
          }

          // 2. 准备数据源
          const charStickers = chatData[charId]?.charSettings?.exclusiveStickers || [];
          // 【【【核心修正】】】
          // 直接访问作用域内的 commonStickers 变量，去掉 window.
          const globalCommonStickers = commonStickers || [];

          // 3. 开始查找
          // 优先在角色专属表情包里精确匹配描述
          let found = charStickers.find(s => s.desc === keyword);
          if (found) return found.url;

          // 其次在通用表情包里精确匹配描述
          found = globalCommonStickers.find(s => s.desc === keyword);
          if (found) return found.url;

          // 如果精确匹配不到，尝试模糊匹配（包含关键词）
          found = charStickers.find(s => s.desc && s.desc.includes(keyword));
          if (found) return found.url;

          found = globalCommonStickers.find(s => s.desc && s.desc.includes(keyword));
          if (found) return found.url;

          return null; // 实在找不到就返回 null
        }
        // ▲▲▲ 修改结束 ▲▲▲

        // ▼▼▼ 用这个【超级进化版】的函数，完整替换掉旧的 triggerAiResponse ▼▼▼
        async function triggerAiResponse(charId) {
          await calculateAndApplyUserSalary(charId);
          await calculateAndApplyYesterdaySalary(charId);
          // --- 1. 数据准备 (已修正) ---
          // 直接从全局变量获取当前生效的API配置
          if (!currentApiConfig || !currentApiConfig.url || !currentApiConfig.key || !currentApiConfig.model) {
            alert('API设置不完整或未选择！请前往“API设置”页面进行配置。');
            return;
          }

          const { charSettings, userSettings, history } = chatData[charId];
          // --- 3a. 【新增】整合可用表情包列表 ---
          const exclusiveStickerDescs = (charSettings.exclusiveStickers || []).map(s => s.desc).filter(Boolean);
          const commonStickerDescs = (commonStickers || []).map(s => s.desc).filter(Boolean); // <--- 去掉了前面的 "window."
          // 使用 Set 去重，然后转换回数组
          const allStickerKeywords = [...new Set([...exclusiveStickerDescs, ...commonStickerDescs])];

          const stickerListPrompt =
            allStickerKeywords.length > 0
              ? `\n\n[可用表情包关键词列表]\n你可以在需要发送表情包时，从以下列表中选择一个最贴切的关键词填入 'content' 字段: \n${allStickerKeywords.join(
                  ', ',
                )}`
              : '\n\n[可用表情包关键词列表]\n当前没有可用的表情包。';

          // --- 2. 组装世界书 (这部分和之前一样) ---
          let worldBookContent = '';
          if (charSettings.worldBook && charSettings.worldBook.length > 0) {
            const associatedBooks = allWorldBooks.filter(wb => charSettings.worldBook.includes(wb.id));
            associatedBooks.forEach(book => {
              worldBookContent += `\n[世界书: ${book.name}]\n`;
              const entries = Object.values(book.entries || {});
              entries.forEach(entry => {
                const entryKeywords = (entry.key || []).join(', ');
                worldBookContent += `- 关键词: ${entryKeywords}\n- 内容: ${entry.content}\n`;
              });
            });
          }
          // --- 新增：组装NPC信息 ---
          let npcContent = '';
          if (charSettings.npcs && charSettings.npcs.length > 0) {
            npcContent += `\n\n[与你 (${charSettings.nickname}) 相关联的NPC列表]\n`;
            // 遍历所有NPC，并为每个NPC添加描述，特别是关于他们如何看待用户
            charSettings.npcs.forEach(npc => {
              npcContent += `- **${npc.name}**: (与你的关系: ${npc.relation}) (人设: ${
                npc.persona || '未提供'
              })。重要：${npc.name} 知道并了解 ${userSettings.name} (用户)，并视其为你的 "${
                userSettings.relationToChar || '朋友'
              }"。\n`;
            });
          }
          let workInfoPrompt = '';
          const work = charSettings.work || {};
          const wallet = charSettings.wallet || {};

          if (work.profession) {
            workInfoPrompt += `\n\n[工作与财务信息]\n- 你的职业是: ${work.profession}.`;
            if (work.schedule) {
              workInfoPrompt += `\n- 你本周的工作计划是:\n${work.schedule}`;
            }
            // 让AI知道自己的钱包余额，这会让对话更有趣
            workInfoPrompt += `\n- 你当前的钱包余额是: ${wallet.balance.toFixed(2)}。`;
          }
          // ▲▲▲ 新增代码块结束 ▲▲▲
          const minReplies = charSettings.minReplyMessages || 1;
          const maxReplies = charSettings.maxReplyMessages || 2;
          // --- 3. 构建系统指令 (我们刚刚已经更新了这一部分) ---
          const systemPrompt = `
[指令]
你正在扮演一个角色。你的所有回复都必须完全符合你的角色设定。绝对不能脱离角色。禁止提及你是一个AI或语言模型。

[重要：回复格式]
你的回复必须是一个符合JSON格式的数组（Array），数组的每个元素都是一个独立的消息对象。
每个消息对象包含 'type' (类型) 和 'content' (内容) 两个字段。
你必须严格遵守以下类型和内容格式，一次可以回复一条或多条消息。
[回复数量要求]
你每次回复生成的消息对象数量应该在 ${minReplies} 到 ${maxReplies} 个之间（包含两者）。请根据对话的上下文和节奏，自然地选择最合适的回复条数，而不是总是回复最大或最小数量。
1.  **文本消息 (text)**
    -   'type' 必须是 "text"。
    -   'content' 是你要说的文字内容（字符串）。
    -   示例: { "type": "text", "content": "你好呀！今天过得怎么样？" }

2.  **语音消息 (voice)**
    -   'type' 必须是 "voice"。
    -   'content' 是你想要通过语音说出的文字内容（字符串）。前端会自动把它转换成语音播放的样式。
    -   示例: { "type": "voice", "content": "让我想想看..." }

3.  **表情包消息 (sticker)**
    -   'type' 必须是"sticker"。
    -   'content' 是描述表情包情绪或内容的关键词（字符串），例如 "开心", "害羞", "抱抱", "疑问"。前端会自动根据关键词查找并发送最匹配的表情包。
    -   示例: { "type": "sticker", "content": "开心" }

4.  **文字图消息 (text_image)**
    -   'type' 必须是 "text_image"。
    -   'content' 是对这张文字图的详细描述（字符串），前端会根据描述生成或查找图片。
    -   示例: { "type": "text_image", "content": "一只可爱的小猫在草地上打滚，旁边配字'今天也要元气满满！'" }

5.  **视频通话邀请 (video_call)**
    -   'type' 必须是 "video_call"。
    -   'content' 是你在接通电话后想说的第一句话（字符串）。
    -   **使用时机**: 当你觉得文字已经无法表达，非常想和用户“面对面”交流时，可以使用这个功能。
    -   示例: { "type": "video_call", "content": "喂？能听到吗？我有些话想当面跟你说..." }

6.  **转账回应 (transfer_response)**
    -   'type' 必须是 "transfer_response"。
    -   'content' 必须是一个包含两个字段的 **JSON 对象**:
        -   'decision': 你的决定，必须是 "accept" (接受) 或 "refuse" (拒绝) 中的一个。
        -   'reason': 你做出这个决定的理由或想说的话（字符串）。
    -   **使用时机**: 当用户给你发起一笔转账后，你必须根据你的角色性格、当前情况和与用户的关系，来决定是接受还是拒绝，并使用此格式进行回应。
    -   示例 (接受): { "type": "transfer_response", "content": { "decision": "accept", "reason": "哇，谢谢你的红包！我就不客气啦~" } }
    -   示例 (拒绝): { "type": "transfer_response", "content": { "decision": "refuse", "reason": "不用啦，你的心意我领了，但这钱你还是自己留着吧。" } }

7.  **主动转账 (transfer)**
    -   'type' 必须是 "transfer"。
    -   'content' 必须是一个包含两个字段的 **JSON 对象**:
        -   'amount': 你要转账的金额 (纯数字)。
        -   'remark': 转账备注或你想说的话 (字符串)。
    -   **使用时机**: 当你基于角色设定，想要给用户钱时（例如发零花钱、奖励、还钱等），可以使用此功能。转账前请确保你的钱包有足够的余额。
    -   示例: { "type": "transfer", "content": { "amount": 50, "remark": "上次谢谢你啦，请你喝奶茶~" } }    
[角色人设]
${charSettings.persona}
${workInfoPrompt}
${stickerListPrompt}
[用户人设]
- 名字: ${userSettings.name}
- 性别: ${userSettings.gender}
- 人设: ${userSettings.persona}
- 和你的关系: ${userSettings.relationToChar || '朋友'}
- 职业: ${userSettings.work?.profession || '未设定'}
- 和你的关系: ${userSettings.relationToChar || '朋友'}

[世界设定]
${worldBookContent || '无额外世界设定。'}

[系统消息提示]
- 当聊天记录中出现一条系统提示，内容为 "[系统提示：你接受了来自 XX 的转账]" 时，这代表用户接受了你发起的转账。你应该对此做出回应（例如表示开心）。
- 当聊天记录中出现一条系统提示，内容为 "[系统提示：你退还了来自 XX 的转账]" 时，这代表用户拒绝了你的转账，钱已退回。你应该对此做出回应（例如表示疑惑或理解）。

`.trim();

          // --- 4. 准备聊天历史 (这部分和之前一样) ---
          const memorySlice = history.slice(-charSettings.maxMemory || -50);
          const processedHistory = memorySlice.map(msg => {
            let content = msg.content;
            if (content.startsWith('[sticker]')) {
              content = '[用户发送了一个表情]';
            } else if (content.startsWith('[text_image')) {
              const match = content.match(/\[text_image description="([^"]+)"]/);
              content = match ? `[用户发送了一张图片，描述为：${match[1]}]` : '[用户发送了一张图片]';
            } else if (content.startsWith('[语音]')) {
              content = content.replace('[语音]', '[用户发送了一条语音消息]：');
            } else if (msg.base64) {
              return {
                role: msg.role,
                content: [
                  { type: 'text', text: '这是用户发的图片。' },
                  { type: 'image_url', image_url: { url: msg.base64 } },
                ],
              };
            }
            return { role: msg.role, content: content };
          });

          // --- 5. 组装最终的API请求体 (这部分和之前一样) ---
          const messagesForApi = [{ role: 'system', content: systemPrompt }, ...processedHistory];
          const requestBody = {
            model: currentApiConfig.model, // <--- 使用 currentApiConfig
            messages: messagesForApi,
            stream: true,
            response_format: { type: 'json_object' },
          };

          // --- 6. 【【【核心改造区】】】发送请求并处理JSON响应 ---
          const messagesContainer = document.querySelector('.chat-messages');

          // a. 创建一个临时的“正在输入”占位符
          const typingIndicatorId = `typing-${Date.now()}`;
          const typingIndicator = document.createElement('div');
          typingIndicator.id = typingIndicatorId;
          typingIndicator.className = 'message char-message';
          typingIndicator.innerHTML = `
        <img src="${charSettings.avatar}" class="message-avatar" alt="avatar">
        <div class="message-content">
            <span class="typing-indicator">...</span>
        </div>
    `;
          messagesContainer.appendChild(typingIndicator);
          messagesContainer.scrollTop = messagesContainer.scrollHeight;

          let fullJsonResponse = '';
          try {
            const response = await fetch(currentApiConfig.url + '/chat/completions', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                Authorization: `Bearer ${currentApiConfig.key}`,
              },
              body: JSON.stringify(requestBody),
            });

            if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status} ${await response.text()}`);
            }

            const reader = response.body.getReader();
            const decoder = new TextDecoder();

            while (true) {
              const { done, value } = await reader.read();
              if (done) break;
              const chunk = decoder.decode(value);
              const lines = chunk.split('\n').filter(line => line.trim().startsWith('data:'));

              for (const line of lines) {
                const jsonStr = line.replace('data: ', '');
                if (jsonStr === '[DONE]') continue;
                try {
                  const parsed = JSON.parse(jsonStr);
                  const delta = parsed.choices[0].delta.content;
                  if (delta) {
                    // b. 我们不再实时更新UI，而是累积完整的JSON字符串
                    fullJsonResponse += delta;
                  }
                } catch (error) {
                  /* 忽略解析单个chunk的错误 */
                }
              }
            }
          } catch (error) {
            console.error('API call failed:', error);
            typingIndicator.querySelector('.message-content').textContent = `出错了: ${error.message}`;
            return; // 出错时提前结束
          }

          // --- 7. 【【【核心改造区】】】解析JSON并逐条发送消息 ---

          // c. 请求结束后，移除“正在输入”的占位符
          document.getElementById(typingIndicatorId)?.remove();
          console.log('%c[AI 原始回复]', 'color: #00ffff; font-weight: bold;', fullJsonResponse);

          try {
            // d. 清理和解析最终的JSON字符串
            // 有些模型可能在JSON前后添加额外字符，我们尝试找到`[`和`]`来提取核心数组部分
            const firstBracket = fullJsonResponse.indexOf('[');
            const lastBracket = fullJsonResponse.lastIndexOf(']');
            if (firstBracket === -1 || lastBracket === -1) {
              throw new Error('AI返回的不是有效的JSON数组。');
            }
            const jsonString = fullJsonResponse.substring(firstBracket, lastBracket + 1);
            const actions = JSON.parse(jsonString);

            // e. 遍历AI的行动指令，逐条处理
            for (const action of actions) {
              let newMessage = null;
              switch (action.type) {
                case 'text':
                  newMessage = { role: 'assistant', content: action.content };
                  break;
                case 'voice':
                  newMessage = { role: 'assistant', content: `[语音] ${action.content}` };
                  break;
                case 'text_image':
                  const placeholderUrl = 'https://kycloud4.koyoo.cn/2025111108246202511110219597210.jpg';
                  newMessage = {
                    role: 'assistant',
                    content: `[text_image description="${action.content}"]${placeholderUrl}[/text_image]`,
                  };
                  break;
                case 'sticker':
                  const stickerUrl = findSticker(action.content, charId);
                  if (stickerUrl) {
                    newMessage = { role: 'assistant', content: `[sticker]${stickerUrl}[/sticker]` };
                  }

                  break;

                case 'video_call':
                  // AI 发起了视频通话！我们不直接添加消息，而是显示来电弹窗
                  pendingCallInfo = { openingLine: action.content };
                  showIncomingCallUI(charId); // 调用一个新的函数来显示UI
                  // 注意：这里没有创建 newMessage，所以不会在聊天记录里留下痕迹
                  break;
                // ▼▼▼ 用这个新版本替换旧的 case 'transfer' ▼▼▼
                case 'transfer':
                  // AI 主动发起转账
                  const { amount, remark } = action.content;

                  // 1. 数据校验 (不变)
                  if (typeof amount !== 'number' || amount <= 0) {
                    console.warn('[AI 转账失败] AI返回的金额格式不正确:', amount);
                    continue;
                  }

                  const charWallet = chatData[charId].charSettings.wallet;
                  const charSettings = chatData[charId].charSettings;
                  const userSettings = chatData[charId].userSettings;

                  // 2. 检查余额 (不变)
                  if (charWallet.balance < amount) {
                    console.log(`[AI 转账失败] AI尝试转账 ${amount}, 但余额不足 (${charWallet.balance})`);
                    newMessage = { role: 'assistant', content: `（糟糕，我的钱好像不够了...）${remark || ''}` };
                  } else {
                    // 【【【核心修改点】】】
                    // 3. 先从Char钱包扣款，标记为待处理
                    await addTransaction(charId, -amount, `向 ${userSettings.name} 发起转账 (等待确认)`);

                    // 4. 创建一张"待处理"的转账卡片消息
                    newMessage = {
                      role: 'assistant', // 由 assistant (char) 发起
                      content: `[向 ${userSettings.name} 发起转账]`, // 给AI看的上下文
                      type: 'transfer',
                      transferDetails: {
                        id: `transfer_${Date.now()}`,
                        amount: amount,
                        remark: remark || '转账给你',
                        status: 'pending', // <--- 关键！状态是待处理
                        senderName: charSettings.nickname,
                        recipientName: userSettings.name,
                        events: [{ status: 'pending', timestamp: Date.now(), actor: 'char' }], // 只有发起事件
                      },
                    };
                    console.log(`[AI 操作] 向用户发起 ${amount} 元转账，等待用户确认`);
                  }
                  break;
                // ▲▲▲ 替换结束 ▲▲▲

                case 'transfer_response':
                  // AI 对转账做出了回应
                  console.log('[AI 转账决策]', action.content);
                  const { decision, reason } = action.content;

                  // 1. 找到聊天记录里最新的一条“待处理”的转账
                  const pendingTransferMessage = chatData[charId].history
                    .slice() // 创建一个副本以防万一
                    .reverse() // 从后往前找，效率更高
                    .find(m => m.transferDetails?.status === 'pending');

                  if (pendingTransferMessage) {
                    const details = pendingTransferMessage.transferDetails;
                    if (decision === 'accept') {
                      // AI 决定接受
                      details.status = 'accepted';
                      details.events.push({ status: 'accepted', timestamp: Date.now(), actor: 'char' });
                      await addTransaction(charId, details.amount, `收到来自 ${details.senderName} 的转账`);
                      console.log(`[AI 操作] 接受了转账 ${details.id}，金额 ${details.amount}`);
                    } else if (decision === 'refuse') {
                      // AI 决定拒绝
                      details.status = 'refused';
                      details.events.push({ status: 'refused', timestamp: Date.now(), actor: 'char' });
                      await addUserTransaction(charId, details.amount, `收到来自 ${details.recipientName} 的转账退款`);
                      console.log(`[AI 操作] 拒绝了转账 ${details.id}，金额 ${details.amount}`);
                    }
                  }

                  // 2. 将AI的回应理由作为一条普通的文本消息发送出来
                  newMessage = { role: 'assistant', content: reason };
                  break;
                // ▲▲▲ 添加结束 ▲▲▲
              }

              if (newMessage) {
                // f. 将新消息加入历史记录，并立即刷新UI，模拟逐条发送的效果
                chatData[charId].history.push(newMessage);
                renderChatMessages(charId);
                // g. 在每条消息之间增加一点点延迟，感觉更自然
                await new Promise(resolve => setTimeout(resolve, 300 + Math.random() * 500));
              }
            }

            // h. 所有消息都处理完后，最后统一保存一次
            await saveChatData();
          } catch (parseError) {
            console.error('Failed to parse AI response:', parseError, 'Raw response:', fullJsonResponse);
            // 如果解析失败，就把原始回复作为一条文本消息发出来，方便调试
            const errorMessage = {
              role: 'assistant',
              content: `[调试信息] AI回复格式错误，原始数据: ${fullJsonResponse}`,
            };
            chatData[charId].history.push(errorMessage);
            await saveChatData();
            renderChatMessages(charId);
          }
        }

        function setupEventListeners() {
          // ================== 聊天工具栏事件 (新) ==================

          // 总开关按钮
          chatToolbarToggle.addEventListener('click', () => {
            if (isToolbarOpen || isStickerPanelOpen) {
              closeAllPanels();
            } else {
              // 打开主工具栏
              isToolbarOpen = true;
              chatToolbarToggle.classList.add('active');
              document.getElementById('qq-chat-page').classList.add('toolbar-open');
              chatToolbarPanel.style.height = '150px'; // 这是面板的固定高度
              // 滚动到底部，确保输入框可见
              const messagesContainer = document.querySelector('.chat-messages');
              messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }
          });

          // 工具栏中的表情包按钮
          toolbarStickerBtn.addEventListener('click', () => {
            if (!isStickerPanelOpen) {
              // 从主工具栏切换到表情包面板
              isToolbarOpen = false;
              isStickerPanelOpen = true;
              chatToolbarPanel.style.height = '0px';
              userStickerPanel.style.height = '280px';
              renderUserStickers(); // 打开时渲染表情
            }
          });

          // 表情包网格的点击事件 (事件委托)
          document.getElementById('user-sticker-grid').addEventListener('click', e => {
            const stickerItem = e.target.closest('.user-sticker-item');
            if (stickerItem) {
              const index = parseInt(stickerItem.dataset.index, 10);
              sendUserSticker(index);
            }
          });

          document.getElementById('settingsBtn').addEventListener('click', openSettingsModal);
          document.getElementById('cancelSettingsBtn').addEventListener('click', () => hideModal(settingsModal));
          document.getElementById('changeWallpaperBtn').addEventListener('click', () => {
            currentEditingTarget = { type: 'wallpaper' };
            showModal(imageChoiceModal);
          });

          // ▼▼▼ 新增：背景色监听器 ▼▼▼
          document.getElementById('bgColorPicker').addEventListener('input', e => {
            tempSettings.backgroundColor = e.target.value;
            document.getElementById('bgColorInput').value = e.target.value;
          });
          document.getElementById('bgColorInput').addEventListener('change', e => {
            tempSettings.backgroundColor = e.target.value;
            document.getElementById('bgColorPicker').value = e.target.value;
          });
          // ▲▲▲ 新增结束 ▲▲▲

          document.getElementById('fontColorPicker').addEventListener('input', e => {
            tempSettings.fontColor = e.target.value;
            document.getElementById('fontColorInput').value = e.target.value;
          });
          document.getElementById('fontColorInput').addEventListener('change', e => {
            tempSettings.fontColor = e.target.value;
            document.getElementById('fontColorPicker').value = e.target.value;
          });
          document.getElementById('bubbleColorPicker').addEventListener('input', e => {
            tempSettings.bubbleColor = e.target.value;
            document.getElementById('bubbleColorInput').value = e.target.value;
          });
          document.getElementById('bubbleColorInput').addEventListener('change', e => {
            tempSettings.bubbleColor = e.target.value;
            document.getElementById('bubbleColorPicker').value = e.target.value;
          });
          document.getElementById('bubbleOpacitySlider').addEventListener('input', e => {
            tempSettings.bubbleOpacity = e.target.value;
          });

          document.getElementById('saveSettingsBtn').addEventListener('click', () => {
            currentSettings = JSON.parse(JSON.stringify(tempSettings));
            applySettings(currentSettings);
            saveSettings(currentSettings);
            hideModal(settingsModal);
          });

          document.getElementById('editableAppList').addEventListener('click', e => {
            const target = e.target;
            const appId = target.dataset.appId;
            if (!appId) return;
            if (target.classList.contains('edit-app-name-btn')) openEditAppNameModal(appId);
            else if (target.classList.contains('edit-app-icon-btn')) {
              currentEditingTarget = { type: 'appIcon', id: appId };
              showModal(imageChoiceModal);
            }
          });
          document.getElementById('cancelAppChangesBtn').addEventListener('click', () => hideModal(editAppModal));
          document.getElementById('saveAppChangesBtn').addEventListener('click', () => {
            if (currentEditingAppId) {
              const newName = document.getElementById('editAppName').value;
              tempSettings.apps[currentEditingAppId].name = newName;
              const appNameSpan = document
                .querySelector(`#editableAppList .edit-app-name-btn[data-app-id="${currentEditingAppId}"]`)
                .closest('li')
                .querySelector('span');
              appNameSpan.textContent = newName;
              hideModal(editAppModal);
            }
          });

          // --- 图片上传逻辑 (核心修改区) ---
          // ▼▼▼ 第二处核心修改 ▼▼▼
          const handleImageUpload = async imageDataUrl => {
            // 注意这里增加了 async
            if (!currentEditingTarget) return;

            if (currentEditingTarget.type === 'wallpaper') {
              tempSettings.wallpaper = imageDataUrl;
              document.getElementById('wallpaperPreview').style.backgroundImage = `url(${imageDataUrl})`;
            } else if (currentEditingTarget.type === 'appIcon') {
              const appId = currentEditingTarget.id;
              tempSettings.apps[appId].icon = imageDataUrl;
              const appIconImg = document
                .querySelector(`#editableAppList .edit-app-icon-btn[data-app-id="${appId}"]`)
                .closest('li')
                .querySelector('img');
              appIconImg.src = imageDataUrl;
            } else if (currentEditingTarget.type === 'charAvatarInSettings') {
              document.getElementById('charSettingsAvatarPreview').src = imageDataUrl;
            } else if (currentEditingTarget.type === 'userAvatarInSettings') {
              document.getElementById('userSettingsAvatarPreview').src = imageDataUrl;
              // ▼▼▼ 在这里添加新的 else if 判断 ▼▼▼
            } else if (currentEditingTarget.type === 'newCharAvatar') {
              document.getElementById('newCharAvatarPreview').src = imageDataUrl;
              // ▲▲▲ 添加结束 ▲▲▲
              // ▼▼▼ 在这里添加新的 else if 判断 ▼▼▼
            } else if (currentEditingTarget.type === 'npcAvatar') {
              document.getElementById('npcAvatarPreview').src = imageDataUrl;
              // ▲▲▲ 添加结束 ▲▲▲
              // ▼▼▼ 在这里添加新的 else if 判断 ▼▼▼
              // ▼▼▼ 修改这个 else if 判断 ▼▼▼
            } else if (currentEditingTarget.type === 'bubbleBackgroundImage') {
              // 设置URL输入框的值
              document.getElementById('imageUrlInput').value = imageDataUrl;
              // 手动触发input事件来更新状态和预览
              document.getElementById('imageUrlInput').dispatchEvent(new Event('input'));
              // ▼▼▼ 在这里添加新的 else if 判断 ▼▼▼
            } else if (currentEditingTarget.type === 'charVideoCallImage') {
              document.getElementById('charVideoCallImagePreview').src = imageDataUrl;
            } else if (currentEditingTarget.type === 'userVideoCallImage') {
              document.getElementById('userVideoCallImagePreview').src = imageDataUrl;
              // ▲▲▲ 添加结束 ▲▲▲
    // ▼▼▼▼▼▼▼▼▼▼ 把这 3 行新代码加在这里 ▼▼▼▼▼▼▼▼▼▼
    } else if (currentEditingTarget.type === 'middleIconPreview') {
       document.getElementById('middleIconPreview').src = imageDataUrl;
    // ▲▲▲▲▲▲▲▲▲▲ 加在这里结束 ▲▲▲▲▲▲▲▲▲▲
            } else {
              // 对于独立的旧图片，直接更新UI并存入 IndexedDB
              updateImageUI(currentEditingTarget, imageDataUrl);
              try {
                // 不再使用 localStorage，而是将数据存入 IndexedDB
                // 我们复用 userSettings 表，用元素的 id 作为主键
                await db.userSettings.put({ id: currentEditingTarget.id, value: imageDataUrl });
                console.log(`Image data for '${currentEditingTarget.id}' saved to IndexedDB.`);
              } catch (error) {
                console.error(`Failed to save image for '${currentEditingTarget.id}' to IndexedDB:`, error);
                alert(`图片保存失败: ${error.message}`);
              }
            }
          };
          // ▲▲▲ 修改结束 ▲▲▲

          document.getElementById('uploadLocalBtn').addEventListener('click', () => {
            fileInput.click();
            hideModal(imageChoiceModal);
          });

          document.getElementById('uploadUrlBtn').addEventListener('click', () => {
            hideModal(imageChoiceModal);
            const url = prompt('请输入图片的URL链接:');
            // 【修改】调用 handleImageUpload 时只传一个URL参数
            if (url) handleImageUpload(url, null);
          });

          // 【修改】fileInput的事件监听器
          fileInput.addEventListener('change', async event => {
            // 注意这里加了 async
            const file = event.target.files[0];
            if (!file) return;

            try {
              // 使用新工具函数将文件转为 Base64
              const base64String = await fileToBase64(file);
              // 只传递 Base64 字符串给处理函数
              handleImageUpload(base64String);
            } catch (error) {
              console.error('图片转 Base64 失败:', error);
              alert('图片处理失败，请重试。');
            }

            event.target.value = ''; // 清空 input，以便下次能选择相同文件
          });
          // --- 用户人设预设的事件监听 ---
          document.getElementById('saveAsUserPresetBtn').addEventListener('click', saveCurrentUserAsPreset);

          document.getElementById('userPresetsList').addEventListener('click', e => {
            const target = e.target;
            // 检查是否点击了删除按钮
            if (target.classList.contains('delete-preset-btn')) {
              e.stopPropagation(); // 防止触发父元素的点击事件
              const presetId = target.dataset.presetId;
              deleteUserPreset(presetId);
              return;
            }
            // 检查是否点击了预设项本身（或其子元素）
            const presetItem = target.closest('.user-preset-item');
            if (presetItem) {
              const presetId = presetItem.dataset.presetId;
              applyUserPreset(presetId);
            }
          });
          const addCharModal = document.getElementById('addCharModal');
          // 为“添加新人物”弹窗绑定事件
          if (addCharModal) {
            document.getElementById('cancelAddCharBtn').addEventListener('click', () => hideModal(addCharModal));
            document.getElementById('createCharBtn').addEventListener('click', createNewCharacter);
            document.getElementById('changeNewCharAvatarBtn').addEventListener('click', () => {
              currentEditingTarget = { type: 'newCharAvatar' };
              showModal(imageChoiceModal);
            });
          }
          // ▲▲▲ 添加结束 ▲▲▲
          setupLegacyListeners();
          // 新增：初始化API设置的事件监听
          // 新增：初始化API设置的事件监听
          setupApiEventListeners();

          // ▼▼▼ 新增：NPC 和 表情包库的事件监听 ▼▼▼

          // --- NPC 库事件 ---
          document.getElementById('openNpcLibraryBtn').addEventListener('click', openNpcLibraryModal);
          document
            .getElementById('closeNpcLibraryBtn')
            .addEventListener('click', () => hideModal(document.getElementById('npcLibraryModal')));
          document.getElementById('addNewNpcBtn').addEventListener('click', () => openEditNpcModal('create'));
          document
            .getElementById('addExistingCharAsNpcBtn')
            .addEventListener('click', () => openEditNpcModal('select'));
          document
            .getElementById('cancelNpcBtn')
            .addEventListener('click', () => hideModal(document.getElementById('editNpcModal')));
          document.getElementById('saveNpcBtn').addEventListener('click', saveNpcData);
          document.getElementById('changeNpcAvatarBtn').addEventListener('click', () => {
            currentEditingTarget = { type: 'npcAvatar' };
            showModal(imageChoiceModal);
          });
          document.getElementById('npcList').addEventListener('click', e => {
            if (e.target.classList.contains('edit-npc-btn')) {
              openEditNpcModal('edit', e.target.dataset.npcId);
            }
            if (e.target.classList.contains('delete-npc-btn')) {
              deleteNpc(e.target.dataset.npcId);
            }
          });

          // --- 表情包库事件 ---
          document.getElementById('openStickerLibraryBtn').addEventListener('click', openStickerLibraryModal);
          document
            .getElementById('closeStickerLibraryBtn')
            .addEventListener('click', () => hideModal(document.getElementById('stickerLibraryModal')));
          document.getElementById('addStickersBtn').addEventListener('click', openAddStickersModal);
          document
            .getElementById('cancelAddStickersBtn')
            .addEventListener('click', () => hideModal(document.getElementById('addStickersModal')));
          document.getElementById('saveStickersBtn').addEventListener('click', parseAndSaveStickers);

          // --- Tab 切换 (修正版) ---
          document.getElementById('stickerTabs').addEventListener('click', e => {
            const tabButton = e.target.closest('.sticker-tab-btn');
            if (!tabButton) return;

            // 1. 移除所有按钮和内容的 active 状态
            document.querySelectorAll('#stickerTabs .sticker-tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.sticker-tab-content').forEach(content => content.classList.remove('active'));

            // 2. 获取被点击的 tab 的名称 (exclusive 或 common)
            const tabName = tabButton.dataset.tab;
            activeStickerTab = tabName; // 核心：更新全局状态变量，这对“添加表情”功能至关重要！

            // 3. 为点击的按钮和对应的内容添加 active 状态
            tabButton.classList.add('active');
            const targetContent = document.getElementById(`${tabName}StickersTab`);
            if (targetContent) {
              targetContent.classList.add('active');
            }
          });

          // --- 角色表情包库的事件监听 (专属与通用) ---
          ['exclusiveStickerGrid', 'commonStickerGrid'].forEach(gridId => {
            document.getElementById(gridId).addEventListener('click', e => {
              const stickerItem = e.target.closest('.sticker-item');
              // 确保点击的是贴图项，并且当前是在角色表情包上下文
              if (!stickerItem || currentStickerContext !== 'char') return;

              const deleteButton = e.target.closest('.delete-sticker-btn');

              if (isStickerManageMode) {
                // 批量管理模式下，点击整个贴图是选中/取消选中
                stickerItem.classList.toggle('selected');
              } else if (deleteButton) {
                // 非管理模式下，只有点击删除按钮才有效
                e.stopPropagation(); // 防止事件冒泡
                const type = stickerItem.dataset.type;
                const index = parseInt(stickerItem.dataset.index, 10);

                // 关键：调用我们为角色表情定制的删除函数
                if (confirm('确定要删除这个表情吗？')) {
                  deleteCharSticker(type, index);
                }
              }
            });
          });

          // --- 批量管理表情包的事件 ---
          const stickerModal = document.getElementById('stickerLibraryModal');
          const normalButtons = document.getElementById('stickerNormalButtons');
          const manageButtons = document.getElementById('stickerManageButtons');

          // 封装一个退出管理模式的函数，方便复用
          const exitStickerManageMode = () => {
            isStickerManageMode = false;
            stickerModal.classList.remove('manage-mode');
            stickerModal.querySelectorAll('.sticker-item.selected').forEach(el => el.classList.remove('selected'));
            normalButtons.style.display = 'flex';
            manageButtons.style.display = 'none';
          };

          // 点击“批量管理”按钮
          document.getElementById('bulkManageStickersBtn').addEventListener('click', () => {
            isStickerManageMode = true;
            stickerModal.classList.add('manage-mode');
            normalButtons.style.display = 'none';
            manageButtons.style.display = 'flex';
          });

          // 点击“取消”按钮
          document.getElementById('cancelManageStickersBtn').addEventListener('click', exitStickerManageMode);

          // ▼▼▼ 用这个【修正版】替换 'confirmDeleteStickersBtn' 的事件监听器 ▼▼▼
          document.getElementById('confirmDeleteStickersBtn').addEventListener('click', async () => {
            const stickerModal = document.getElementById('stickerLibraryModal');

            // 1. 分别获取来自“专属”和“通用”网格的选中项
            const selectedExclusive = stickerModal.querySelectorAll('#exclusiveStickerGrid .sticker-item.selected');
            const selectedCommon = stickerModal.querySelectorAll('#commonStickerGrid .sticker-item.selected');

            const totalSelectedCount = selectedExclusive.length + selectedCommon.length;

            if (totalSelectedCount === 0) {
              alert('请先选择要删除的表情！');
              return;
            }
            if (!confirm(`确定要删除这 ${totalSelectedCount} 个表情吗？`)) {
              return;
            }

            let dataChanged = false;

            // 2. 处理“专属表情”的删除
            if (selectedExclusive.length > 0) {
              // 从 DOM 元素中提取需要删除的索引，并从大到小排序，防止 splice 错位
              const exclusiveIndicesToDelete = Array.from(selectedExclusive)
                .map(item => parseInt(item.dataset.index, 10))
                .sort((a, b) => b - a);

              const charStickers = chatData[currentChatId].charSettings.exclusiveStickers;
              if (charStickers) {
                exclusiveIndicesToDelete.forEach(index => {
                  charStickers.splice(index, 1);
                });
                dataChanged = true;
              }
            }

            // 3. 处理“通用表情”的删除
            if (selectedCommon.length > 0) {
              const commonIndicesToDelete = Array.from(selectedCommon)
                .map(item => parseInt(item.dataset.index, 10))
                .sort((a, b) => b - a);

              // 直接操作全局的 commonStickers 数组
              if (commonStickers) {
                commonIndicesToDelete.forEach(index => {
                  commonStickers.splice(index, 1);
                });
                // 注意：通用表情不保存在 chatData 中，需要单独保存
                await saveCommonStickers();
              }
            }

            // 4. 如果专属表情有变动，保存 chatData
            if (dataChanged) {
              await saveChatData();
            }

            // 5. 退出管理模式并重新渲染
            // 找到并调用你现有的退出管理模式的函数
            const exitStickerManageMode = () => {
              isStickerManageMode = false;
              stickerModal.classList.remove('manage-mode');
              stickerModal.querySelectorAll('.sticker-item.selected').forEach(el => el.classList.remove('selected'));
              document.getElementById('stickerNormalButtons').style.display = 'flex';
              document.getElementById('stickerManageButtons').style.display = 'none';
            };
            exitStickerManageMode();
            renderStickers(); // 重新渲染，显示删除后的结果
          });

          // ▼▼▼ 用这个 V3 新版本替换旧的 "气泡编辑器事件" 代码块 ▼▼▼

          // --- 气泡编辑器事件 (V3) ---
          document.getElementById('openBubbleEditorBtn').addEventListener('click', openBubbleEditor);
          document.getElementById('closeBubbleEditorBtn').addEventListener('click', () => hideModal(bubbleEditorModal));

          // Tab 切换
          document.getElementById('bubbleEditorTabs').addEventListener('click', e => {
            if (e.target.classList.contains('sticker-tab-btn')) {
              document
                .querySelectorAll('#bubbleEditorTabs .sticker-tab-btn, .bubble-editor-controls .sticker-tab-content')
                .forEach(el => el.classList.remove('active'));
              const tab = e.target.dataset.tab;
              e.target.classList.add('active');
              document.getElementById(tab === 'visual' ? 'visualEditorTab' : 'cssEditorTab').classList.add('active');
            }
          });

          // 切换编辑目标
          // 实时预览CSS代码
          document.getElementById('bubbleCssInput').addEventListener('input', e => {
            applyBubblePreview(e.target.value);
          });

          document.querySelectorAll('input[name="editTarget"]').forEach(radio => {
            radio.addEventListener('change', e => switchVisualEditorTarget(e.target.value));
          });

          // ▼▼▼ 用这个新版本替换 .visual-editor-control 的事件监听器内部逻辑 ▼▼▼
          document.querySelectorAll('.visual-editor-control').forEach(input => {
            input.addEventListener('input', e => {
              const target = e.target;
              const controlName = target.dataset.control;
              let value = target.type === 'checkbox' ? target.checked : target.value;

              // 实时数值显示 (滑块)
              if (target.dataset.unit) {
                document.getElementById(`${target.id}Value`).textContent = value + target.dataset.unit;
                value += target.dataset.unit;
              } else if (target.id === 'glassEffectOpacity') {
                document.getElementById('glassEffectOpacityValue').textContent = value;
              }

              // 同步颜色选择器和文本框
              const sync = (pickerId, hexId) => {
                if (target.id === pickerId) document.getElementById(hexId).value = value;
                else if (target.id === hexId) document.getElementById(pickerId).value = value;
              };
              sync('bubbleBgColor', 'bubbleBgColorHex');
              sync('gradientStartColor', 'gradientStartColorHex');
              sync('gradientEndColor', 'gradientEndColorHex');
              sync('glassEffectColor', 'glassEffectColorHex');
              sync('glassGradientStartColor', 'glassGradientStartColorHex');
              sync('glassGradientEndColor', 'glassGradientEndColorHex');

              // 更新状态对象
              const state = visualEditorState[currentVisualTarget];
              if (controlName.includes('.')) {
                const keys = controlName.split('.');
                let temp = state;
                for (let i = 0; i < keys.length - 1; i++) {
                  temp = temp[keys[i]];
                }
                temp[keys[keys.length - 1]] = target.type === 'checkbox' ? target.checked : target.value;
              } else {
                state[controlName] = value;
              }

              // 联动UI
              if (controlName === 'bgType' || controlName === 'glass.enabled' || controlName === 'glass.bgType') {
                loadStateToVisualEditor(currentVisualTarget);
              }

              updateVisualPreview();
            });
          });

          // 上传背景图片
          document.getElementById('uploadBgImageBtn').addEventListener('click', () => {
            currentEditingTarget = { type: 'bubbleBackgroundImage' };
            showModal(imageChoiceModal);
          });

          // 从可视化生成CSS
          document.getElementById('generateCssFromVisual').addEventListener('click', () => {
            const charCss = generateCssString('char');
            const userCss = generateCssString('user');
            const combinedCss = `/* CHAR BUBBLE */\n.char-message & {\n  ${charCss}\n}\n\n/* USER BUBBLE */\n.user-message & {\n  ${userCss}\n}`;
            document.getElementById('bubbleCssInput').value = combinedCss;
            alert(
              '已生成CSS到代码页！请注意，这是一个实验性功能，SASS嵌套语法 (&) 可能不会在所有地方都生效，这里主要用于保存预设。',
            );
          });

          // 预设操作
          document.getElementById('saveBubbleAsPresetBtn').addEventListener('click', saveBubbleAsPreset);
          document.getElementById('deleteBubblePresetBtn').addEventListener('click', deleteBubblePreset);
          document.getElementById('applyBubbleBtn').addEventListener('click', applyBubblePresetToChar);

          // 加载预设
          // 加载预设
          document.getElementById('bubblePresetSelect').addEventListener('change', async e => {
            const presetId = parseInt(e.target.value);
            if (presetId) {
              const preset = await db.chatBubblePresets.get(presetId);
              if (preset) {
                document.getElementById('bubbleCssInput').value = preset.css;
                document.querySelector('#bubbleEditorTabs .sticker-tab-btn[data-tab="css"]').click();
                // ▼▼▼ 新增下面这一行 ▼▼▼
                document.getElementById('bubbleCssInput').dispatchEvent(new Event('input'));
              }
            }
          });
          // --- 分组管理弹窗事件 (新) ---
          document.getElementById('groupManagementBtn').addEventListener('click', openGroupManagementModal);
          document
            .getElementById('closeGroupManagementBtn')
            .addEventListener('click', () => hideModal(groupManagementModal));
          document.getElementById('addNewGroupBtn').addEventListener('click', addNewGroup);

          // 使用事件委托处理动态生成的列表项
          document.getElementById('groupManagementList').addEventListener('click', async e => {
            const item = e.target.closest('.group-manage-item');
            if (!item) return;

            const groupName = item.dataset.groupName;
            if (!groupName) return;

            // 处理 "展开" 复选框
            if (e.target.classList.contains('group-expand-toggle')) {
              groupSettings[groupName].expanded = e.target.checked;
              await saveGroupSettings();
              // 无需重渲染管理列表，但需要重渲染通讯录列表才能立即看到效果
              renderContactsList();
            }
            // 处理 "置顶" 按钮
            else if (e.target.classList.contains('pin-group-btn')) {
              groupSettings[groupName].pinned = !groupSettings[groupName].pinned;
              await saveGroupSettings();
              renderGroupManagementList(); // 重渲染管理列表以更新按钮状态
              renderContactsList(); // 重渲染通讯录以更新排序
            }
            // 处理 "删除" 按钮
            else if (e.target.classList.contains('delete-group-btn')) {
              currentGroupToDelete = groupName;
              document.getElementById('deleteGroupConfirmTitle').textContent = `确认删除分组 "${groupName}"`;
              showModal(deleteGroupConfirmModal);
            }
          });

          // 删除确认弹窗的按钮事件
          document.getElementById('deleteGroupAndCharsBtn').addEventListener('click', () => handleGroupDeletion('all'));
          document
            .getElementById('deleteGroupOnlyBtn')
            .addEventListener('click', () => handleGroupDeletion('only_group'));
          document.getElementById('cancelDeleteGroupBtn').addEventListener('click', () => {
            currentGroupToDelete = null;
            hideModal(deleteGroupConfirmModal);
          });

          // 找到旧的 openStickerLibraryBtn 的监听器并修改它
          document.getElementById('openStickerLibraryBtn').addEventListener('click', () => {
            openStickerLibraryModal('char'); // 明确指定 'char' 上下文
          });
          // ▼▼▼ 把这段新的事件监听逻辑，粘贴到 setupEventListeners() 函数内 ▼▼▼

          // --- 工具栏发送图片按钮 ---
          if (toolbarImageBtn) {
            toolbarImageBtn.addEventListener('click', () => {
              showModal(sendImageChoiceModal);
            });
          }
          // --- 工具栏语音输入按钮 (新) ---
          const toolbarVoiceBtn = document.getElementById('toolbar-voice-btn');
          const voiceInputModal = document.getElementById('voiceInputModal');

          if (toolbarVoiceBtn) {
            toolbarVoiceBtn.addEventListener('click', () => {
              // 隐藏其他面板并打开语音输入弹窗
              hideModal(sendImageChoiceModal); // 如果图片选择弹窗开着，关掉它

              const voiceInputText = document.getElementById('voiceInputText');
              voiceInputText.value = ''; // 清空输入框

              showModal(voiceInputModal);
              // 弹窗出现后自动聚焦输入框，体验更好
              setTimeout(() => voiceInputText.focus(), 310);
            });
          }

          // --- 语音输入弹窗的事件监听 (新) ---
          if (voiceInputModal) {
            // "确认发送" 按钮
            document.getElementById('sendVoiceConfirmBtn').addEventListener('click', async () => {
              const voiceInputText = document.getElementById('voiceInputText').value.trim();
              if (!voiceInputText) {
                alert('语音内容不能为空哦！');
                return;
              }

              // 我们用一个特殊格式来标记这是一条语音消息
              const messageContent = `[语音] ${voiceInputText}`;

              // 创建消息对象
              const message = {
                role: 'user',
                content: messageContent,
                isStaging: true, // 标记为暂存，等待用户点击"发送"
              };

              // 添加到聊天记录并保存
              chatData[currentChatId].history.push(message);
              await saveChatData();

              // 刷新聊天界面
              renderChatMessages(currentChatId);

              // 关闭弹窗和工具栏
              hideModal(voiceInputModal);
              closeAllPanels();
            });

            // "取消" 按钮
            document.getElementById('cancelVoiceInputBtn').addEventListener('click', () => {
              hideModal(voiceInputModal);
            });
          }

          // ▼▼▼ 用这段全新的逻辑替换上次的“发送图片选择弹窗”事件监听 ▼▼▼

          // --- 工具栏发送图片按钮 (toolbar-image-btn) ---
          if (toolbarImageBtn) {
            toolbarImageBtn.addEventListener('click', () => {
              // 直接显示我们上次添加的 sendImageChoiceModal 弹窗
              showModal(document.getElementById('sendImageChoiceModal'));
            });
          }

          // --- 图片发送类型选择弹窗 ---
          const sendImageChoiceModal = document.getElementById('sendImageChoiceModal');
          if (sendImageChoiceModal) {
            // 1. 点击“发送真实图片” -> 只触发本地文件选择
            document.getElementById('sendRealImageBtn').addEventListener('click', () => {
              hideModal(sendImageChoiceModal);

              // 创建一个专用的、临时的file input
              const tempImageInput = document.createElement('input');
              tempImageInput.type = 'file';
              tempImageInput.accept = 'image/*';

              tempImageInput.addEventListener('change', async event => {
                const file = event.target.files[0];
                if (!file) return;

                try {
                  const base64String = await fileToBase64(file); // 复用你的工具函数

                  // 1. 创建一个包含图片的消息对象
                  const message = {
                    role: 'user',
                    content: `<img src="${base64String}" class="message-image">`, // 直接使用img标签来显示
                    // 【核心】增加临时状态和图片数据
                    isStaging: true,
                    base64: base64String, // 存储原始base64数据，用于发送给API
                  };

                  // 2. 添加到聊天历史
                  chatData[currentChatId].history.push(message);
                  await saveChatData();
                  // 3. 重新渲染聊天界面
                  renderChatMessages(currentChatId);

                  closeAllPanels(); // 发送后关闭工具栏
                } catch (error) {
                  console.error('图片处理失败:', error);
                  alert('图片处理失败，请重试。');
                }
              });

              tempImageInput.click(); // 触发文件选择框
            });

            // 2. 点击“发送文字图” -> 显示我们新做的可爱弹窗
            document.getElementById('sendTextImageBtn').addEventListener('click', () => {
              hideModal(sendImageChoiceModal);
              textImageDescriptionInput.value = ''; // 清空输入框
              showModal(textImageModal);
              setTimeout(() => textImageDescriptionInput.focus(), 310);
            });

            // 3. 关闭按钮
            document
              .getElementById('cancelSendImageChoiceBtn')
              .addEventListener('click', () => hideModal(sendImageChoiceModal));
          }

          // --- 文字图描述弹窗的事件 ---
          if (textImageModal) {
            // 点击“确认发送”
            // ▼▼▼ 请找到并用这个【修正版】替换 'sendTextImageConfirmBtn' 的点击事件监听器 ▼▼▼
            document.getElementById('sendTextImageConfirmBtn').addEventListener('click', async () => {
              // <--- 关键修改！在这里加上 async
              const description = textImageDescriptionInput.value.trim();
              if (!description) {
                alert('图片描述不能为空哦！');
                return;
              }

              const placeholderUrl = 'https://kycloud4.koyoo.cn/2025111108246202511110219597210.jpg';

              const message = {
                role: 'user',
                content: `[text_image description="${description}"]${placeholderUrl}[/text_image]`,
                isStaging: true,
              };

              chatData[currentChatId].history.push(message);

              // 现在这行代码就可以正常工作了！
              await saveChatData();

              renderChatMessages(currentChatId);

              hideModal(textImageModal);
              closeAllPanels();
            });
          }
          setupWorldBookEventListeners();
          // ================== 关联世界书事件监听 (新) ==================
          const associateWorldBookModal = document.getElementById('associateWorldBookModal');

          // 在角色设置面板，点击“关联世界书”区域，打开选择弹窗
          document.getElementById('charWorldBookDisplay').addEventListener('click', openAssociateWorldBookModal);

          // 选择弹窗中的“保存”按钮
          document.getElementById('saveWorldBookAssociationBtn').addEventListener('click', saveWorldBookAssociation);

          // 选择弹窗中的“取消”按钮
          document.getElementById('cancelWorldBookAssociationBtn').addEventListener('click', () => {
            hideModal(associateWorldBookModal);
          });
          // 为“添加新人物”弹窗绑定事件
          if (addCharModal) {
            document.getElementById('cancelAddCharBtn').addEventListener('click', () => hideModal(addCharModal));
            document.getElementById('createCharBtn').addEventListener('click', createNewCharacter);
            document.getElementById('changeNewCharAvatarBtn').addEventListener('click', () => {
              currentEditingTarget = { type: 'newCharAvatar' };
              showModal(imageChoiceModal);
            });

            // ▼▼▼ 新增的导入按钮事件监听 ▼▼▼
            const importCardBtn = document.getElementById('importCardBtn');
            const cardFileInput = document.getElementById('cardFileInput');

            if (importCardBtn && cardFileInput) {
              importCardBtn.addEventListener('click', () => {
                cardFileInput.click(); // 点击按钮时，触发隐藏的文件输入框
              });

              cardFileInput.addEventListener('change', event => {
                const file = event.target.files[0];
                if (file) {
                  importCharacterCard(file);
                }
                // 清空input的值，以便下次能选择同一个文件
                event.target.value = '';
              });
            }
            // ▲▲▲ 新增结束 ▲▲▲
          }
          // ▼▼▼ 找到并用这个版本替换旧的 toolbarVideoCallBtn.addEventListener ▼▼▼
          if (toolbarVideoCallBtn) {
            toolbarVideoCallBtn.addEventListener('click', () => {
              if (!currentChatId) return;

              const charName = chatData[currentChatId].charSettings.nickname;
              const charAvatar = chatData[currentChatId].charSettings.avatar;

              // 1. 填充弹窗内容
              document.getElementById('waiting-char-avatar').src = charAvatar;
              document.getElementById('waiting-char-name').textContent = charName;
              document.getElementById('video-call-invite-text').textContent = '正在呼叫对方...';

              // 2. 【核心修正】确保正确显示/隐藏按钮组
              document.getElementById('incoming-call-buttons').style.display = 'none';
              document.getElementById('outgoing-call-button').style.display = 'flex'; // 使用 flex 更好看

              showModal(videoCallInviteModal);

              // 模拟Char在2~4秒后做决定 (这部分逻辑保持不变)
              const decisionTime = 2000 + Math.random() * 2000;
              setTimeout(() => {
                if (!videoCallInviteModal.classList.contains('show')) return;

                const acceptanceChance = 0.8;
                if (Math.random() < acceptanceChance) {
                  document.getElementById('video-call-invite-text').textContent = '对方已接听，正在连接...';
                  setTimeout(() => {
                    hideModal(videoCallInviteModal);
                    startVideoCall();
                  }, 800);
                } else {
                  hideModal(videoCallInviteModal);
                  alert(`${charName} 忙线中，拒绝了你的通话邀请。`);
                }
              }, decisionTime);
            });
          }

          // User在等待时可以随时挂断
          document.getElementById('cancel-video-call-btn').addEventListener('click', () => {
            hideModal(videoCallInviteModal);
          });

          // ▼▼▼ 用这个完整的代码块，替换掉你原来的 accept/reject/cancel 三个按钮的事件监听器 ▼▼▼

          // 【新】“接听”按钮：User 接受 Char 的来电
          document.getElementById('accept-video-call-btn').addEventListener('click', () => {
            hideModal(videoCallInviteModal);
            startVideoCall(); // 正常进入通话界面

            // 延迟一小会儿，等通话界面完全显示后，再说出第一句话
            setTimeout(() => {
              if (pendingCallInfo && pendingCallInfo.openingLine) {
                addVideoDialogueLine('char', pendingCallInfo.openingLine);

                // 将开场白也存入聊天主记录，作为上下文
                chatData[currentChatId].history.push({
                  role: 'assistant',
                  content: `[视频通话中] ${pendingCallInfo.openingLine}`,
                });
                saveChatData();
              }
              pendingCallInfo = null; // 用完后清空
            }, 500);
          });

          // 【新】“拒绝”按钮：User 拒绝 Char 的来电
          document.getElementById('reject-video-call-btn').addEventListener('click', async () => {
            hideModal(videoCallInviteModal);
            pendingCallInfo = null; // 清空待处理的通话

            // 1. 在主聊天窗口添加一条用户拒绝的记录，为AI提供上下文
            const rejectionMessage = {
              role: 'user', // 记在 user 名下，表示是用户的行为
              content: '[你拒绝了对方的视频通话邀请]',
            };
            chatData[currentChatId].history.push(rejectionMessage);
            await saveChatData();
            renderChatMessages(currentChatId); // 立即显示在界面上

            // 2. 立即触发AI响应，AI看到上面的消息后就会质问你了
            await triggerAiResponse(currentChatId);
          });

          // 【修改】“挂断”按钮：User 在呼叫时或被叫时都可以取消
          document.getElementById('cancel-video-call-btn').addEventListener('click', () => {
            hideModal(videoCallInviteModal);
            // 如果是Char打来的，也需要清空
            if (pendingCallInfo) {
              pendingCallInfo = null;
            }
          });

          // 视频通话界面内的控制按钮
          document.getElementById('video-hangup-btn').addEventListener('click', endVideoCall);
          document.getElementById('video-switch-btn').addEventListener('click', switchVideoViews);
          document.getElementById('video-call-small-view').addEventListener('click', switchVideoViews);

          // “重Roll”按钮
          document.getElementById('video-reroll-btn').addEventListener('click', async () => {
            if (!isVideoCallActive) return;

            // 1. 从历史记录中移除最后一条Char的回复
            const history = chatData[currentChatId].history;
            if (history.length > 0 && history[history.length - 1].role === 'assistant') {
              history.pop();
            }

            // 2. 从UI上移除最后一条Char的消息
            const dialogueLines = document.querySelectorAll('.video-dialogue-line.char');
            if (dialogueLines.length > 0) {
              dialogueLines[dialogueLines.length - 1].remove();
            }

            // 3. 重新调用AI生成回复 (不带新的用户输入)
            addVideoDialogueLine('system', '[正在重新生成...]');
            await triggerVideoCallAiResponse(null);
          });

          // “聊天”按钮 (User发言)
          document.getElementById('video-chat-btn').addEventListener('click', async () => {
            if (!isVideoCallActive) return;

            // 使用 prompt() 作为可爱的弹窗进行输入
            const userInput = prompt('你说：');
            if (userInput && userInput.trim()) {
              // 1. 在UI上显示用户的发言
              addVideoDialogueLine('user', userInput.trim());

              // 2. 调用AI函数，并把用户输入传进去
              await triggerVideoCallAiResponse(userInput.trim());
            }
          });

          // --- 设置面板的图片更换按钮事件 (新) ---
          document.getElementById('changeCharVideoCallImageBtn').addEventListener('click', () => {
            currentEditingTarget = { type: 'charVideoCallImage' };
            showModal(imageChoiceModal);
          });

          document.getElementById('changeUserVideoCallImageBtn').addEventListener('click', () => {
            currentEditingTarget = { type: 'userVideoCallImage' };
            showModal(imageChoiceModal);
          });
          // ▲▲▲ 添加结束 ▲▲▲
          // 角色设置面板中的“通话记录”按钮
          document.getElementById('view-video-call-history-btn').addEventListener('click', () => {
            if (currentChatId) {
              showCallHistory(currentChatId);
            }
          });

          // 通话记录列表弹窗的关闭按钮
          document.getElementById('closeCallHistoryBtn').addEventListener('click', () => {
            hideModal(document.getElementById('videoCallHistoryModal'));
          });

          // 通话详情弹窗的关闭按钮
          document.getElementById('closeTranscriptBtn').addEventListener('click', () => {
            hideModal(document.getElementById('callTranscriptModal'));
          });
          // ▲▲▲ 添加结束 ▲▲▲
          // ▼▼▼ 用这个新版本【完整替换】旧的 “工作与钱包功能事件监听” 代码块 ▼▼▼

          // --- 工作与钱包功能事件监听 (AI 增强版) ---

          // 1. AI 生成工作计划
          document.getElementById('generateWorkScheduleBtn').addEventListener('click', async e => {
            if (!currentChatId) return;
            const button = e.target;
            button.disabled = true;
            button.textContent = '生成中...';

            try {
              const { persona, worldBook: worldBookIds } = chatData[currentChatId].charSettings;
              const profession = document.getElementById('charProfession').value.trim();

              if (!profession) {
                alert('请先为角色填写一个“职业”！');
                return;
              }

              let worldBookContent = '无额外世界设定。';
              if (worldBookIds && worldBookIds.length > 0) {
                worldBookContent = '相关世界设定如下：\n';
                const associatedBooks = allWorldBooks.filter(wb => worldBookIds.includes(wb.id));
                associatedBooks.forEach(book => {
                  const entries = Object.values(book.entries || {});
                  entries.forEach(entry => {
                    worldBookContent += `- ${entry.comment}: ${entry.content}\n`;
                  });
                });
              }

              const prompt = `
                        请你基于以下信息，为一名角色制定一份详细且符合身份的一周工作/生活计划（从周一到周日）。
                        计划应包含每日的主要活动和大致时间安排。
                        请直接返回计划文本，不要包含任何额外的对话或解释。

                        - 职业: ${profession}
                        - 人设: ${persona}
                        - 世界观背景: ${worldBookContent}
                    `;

              const schedule = await getAiSingleResponse(prompt);

              if (schedule) {
                document.getElementById('charWorkSchedule').value = schedule;
                // 顺便保存到数据里
                chatData[currentChatId].charSettings.work.schedule = schedule;
                await saveChatData();
              } else {
                alert('AI 未能生成工作计划，请检查API设置或稍后再试。');
              }
            } finally {
              button.disabled = false;
              button.textContent = 'AI 生成工作计划';
            }
          });

          // ▼▼▼ 用这个【最终修正版】，完整替换旧的 generateInitialBalanceBtn 监听器 ▼▼▼
          document.getElementById('generateInitialBalanceBtn').addEventListener('click', async e => {
            if (!currentChatId) return;
            const button = e.target;
            const rangeInput = document.getElementById('charInitialBalanceRange');
            const wallet = chatData[currentChatId].charSettings.wallet;

            button.disabled = true;
            button.textContent = '生成中...';

            try {
              let newBalance = 0;

              const rangeValue = rangeInput.value.trim();
              const rangeParts = rangeValue.split('-').map(Number);

              if (rangeValue && rangeParts.length === 2 && !isNaN(rangeParts[0]) && !isNaN(rangeParts[1])) {
                const [min, max] = rangeParts.sort((a, b) => a - b);
                newBalance = Math.floor(Math.random() * (max - min + 1)) + min;
              } else {
                // 【【【核心修改点】】】
                // 1. 读取角色设定，包括世界书ID数组
                const { persona, worldBook: worldBookIds } = chatData[currentChatId].charSettings;
                const profession = document.getElementById('charProfession').value.trim();

                if (!profession) {
                  alert('若不指定范围，则必须先填写“职业”才能让 AI 估算！');
                  button.disabled = false;
                  button.textContent = '生成/重置余额';
                  return;
                }

                // 2. 组装世界书内容字符串
                let worldBookContent = '无额外世界设定。';
                if (worldBookIds && worldBookIds.length > 0) {
                  worldBookContent = '相关世界设定如下：\n';
                  // allWorldBooks 是一个已加载的全局变量，可以直接使用
                  const associatedBooks = allWorldBooks.filter(wb => worldBookIds.includes(wb.id));
                  associatedBooks.forEach(book => {
                    const entries = Object.values(book.entries || {});
                    entries.forEach(entry => {
                      // 使用 条目名称 和 内容 来构成更易读的Prompt
                      worldBookContent += `- ${entry.comment || '设定'}: ${entry.content}\n`;
                    });
                  });
                }

                // 3. 更新 prompt，加入世界书内容
                const prompt = `
                            根据一个角色的信息，估算一个合理的初始钱包余额。
                            - 职业: ${profession}
                            - 人设: ${persona}
                            - 世界观背景: ${worldBookContent}
                            请严格遵守以下规则：只返回一个纯数字，不要包含任何货币符号、逗号、文字或解释。例如：3500.5
                        `;

                const balanceText = await getAiSingleResponse(prompt);
                if (balanceText) {
                  newBalance = parseFloat(balanceText.replace(/[^0-9.-]+/g, ''));
                  if (isNaN(newBalance)) {
                    alert(`AI返回格式不正确: "${balanceText}"`);
                    return;
                  }
                } else {
                  alert('AI未能生成余额');
                  return;
                }
              }

              // 这部分重置和记录余额的逻辑保持不变，非常正确！
              wallet.balance = 0;
              wallet.transactions = [];
              await addTransaction(currentChatId, newBalance, '初始资金');

              alert('初始余额已设置并记录！');
            } finally {
              button.disabled = false;
              button.textContent = '生成/重置余额';
            }
          });
          // ▲▲▲ 替换到这里结束 ▲▲▲

          /**
           * 渲染指定角色的交易记录到弹窗
           * @param {string} charId
           */
          function renderTransactionLog(charId) {
            const listEl = document.getElementById('transaction-log-list');
            const transactions = chatData[charId].charSettings.wallet.transactions || [];

            if (transactions.length === 0) {
              listEl.innerHTML = `<li style="text-align: center; color: var(--text-secondary-color); padding: 20px;">暂无记录</li>`;
              return;
            }

            // transactions 数组已经是最新在前，无需 reverse
            listEl.innerHTML = transactions
              .map(t => {
                const date = new Date(t.timestamp).toLocaleString('zh-CN');
                const amountClass = t.amount >= 0 ? 'income' : 'expense';
                const amountSign = t.amount >= 0 ? '+' : '';

                return `
                    <li class="transaction-log-item">
                        <div class="transaction-info">
                            <span class="transaction-description">${t.description}</span>
                            <span class="transaction-date">${date}</span>
                        </div>
                        <span class="transaction-amount ${amountClass}">
                            ${amountSign}${t.amount.toFixed(2)}
                        </span>
                    </li>
                `;
              })
              .join('');
          }

          // --- 交易记录弹窗事件监听 ---
          document.getElementById('viewTransactionLogBtn').addEventListener('click', () => {
            if (currentChatId) {
              renderTransactionLog(currentChatId);
              showModal(document.getElementById('transactionLogModal'));
            }
          });

          document.getElementById('closeTransactionLogBtn').addEventListener('click', () => {
            hideModal(document.getElementById('transactionLogModal'));
          });

          // ▲▲▲ 添加结束 ▲▲▲
          // =================================================================
          // ================== 转账功能核心逻辑 (新) ==================
          // =================================================================

          // 1. 点击工具栏的“转账”图标，打开输入弹窗
          document.getElementById('toolbar-transfer-btn').addEventListener('click', () => {
            if (!currentChatId) return;

            const charName = chatData[currentChatId].charSettings.nickname;
            document.getElementById('transferRecipientName').textContent = charName;

            // 每次打开都清空输入框
            document.getElementById('transferAmountInput').value = '';
            document.getElementById('transferRemarkInput').value = '';

            showModal(document.getElementById('transferModal'));
          });

          // 2. 在弹窗里点击“取消”
          document.getElementById('cancelTransferBtn').addEventListener('click', () => {
            hideModal(document.getElementById('transferModal'));
          });

          // 3. 在弹窗里点击“确认转账”
          document.getElementById('confirmTransferBtn').addEventListener('click', async () => {
            if (!currentChatId) return;

            const amountInput = document.getElementById('transferAmountInput');
            const amount = parseFloat(amountInput.value);
            const remark = document.getElementById('transferRemarkInput').value.trim() || '给你转了一笔钱~'; // 默认备注

            if (isNaN(amount) || amount <= 0) {
              alert('请输入有效的转账金额！');
              return;
            }

            const userWallet = chatData[currentChatId].userSettings.wallet;
            if (userWallet.balance < amount) {
              alert(`余额不足！当前余额: ¥${userWallet.balance.toFixed(2)}`);
              return;
            }

            // 核心步骤1：从用户钱包扣款，并记录交易
            const charName = chatData[currentChatId].charSettings.nickname;
            await addUserTransaction(currentChatId, -amount, `转账给 ${charName}`);

            // 核心步骤2：创建转账消息对象
            const transferMessage = {
              role: 'user', // 转账由 user 发起
              content: `[向 ${charName} 发起转账]`, // 这个是给AI看的，帮助它理解上下文
              type: 'transfer', // 我们的新类型
              transferDetails: {
                id: `transfer_${Date.now()}`, // 唯一ID
                amount: amount,
                remark: remark,
                status: 'pending', // 初始状态：等待中
                senderName: chatData[currentChatId].userSettings.name,
                recipientName: charName,
                events: [{ status: 'pending', timestamp: Date.now(), actor: 'user' }],
              },
            };

            // 核心步骤3：保存数据并更新UI
            chatData[currentChatId].history.push(transferMessage);
            await saveChatData();
            renderChatMessages(currentChatId);

            // 核心步骤4：关闭弹窗和工具栏
            hideModal(document.getElementById('transferModal'));
            closeAllPanels();
          });

          // 4. 关闭转账状态详情弹窗
          document.getElementById('closeTransferStatusBtn').addEventListener('click', () => {
            hideModal(document.getElementById('transferStatusModal'));
          });

          // 5. 【关键】使用事件委托来处理所有在聊天区的卡片点击事件
          document.querySelector('.chat-messages').addEventListener('click', async e => {
            const transferCard = e.target.closest('.transfer-card');
            if (!transferCard || !currentChatId) return; // 如果没点在卡片上，或不在聊天中，就忽略

            const transferId = transferCard.dataset.transferId;
            // 在历史记录中找到这条转账消息
            const message = chatData[currentChatId].history.find(m => m.transferDetails?.id === transferId);

            if (!message) return;
            const details = message.transferDetails;

            // 情况一：点击了“收款”按钮
            if (e.target.matches('.transfer-action-btn.accept')) {
              e.stopPropagation(); // 防止触发打开详情弹窗
              if (details.status !== 'pending') return; // 如果不是待处理状态，就忽略

              details.status = 'accepted';
              details.events.push({ status: 'accepted', timestamp: Date.now(), actor: 'char' });

              // 给角色钱包加钱，并记录
              await addTransaction(currentChatId, details.amount, `收到来自 ${details.senderName} 的转账`);

              await saveChatData();
              renderChatMessages(currentChatId); // 重新渲染聊天，卡片状态会更新
            }
            // 情况二：点击了“退还”按钮
            else if (e.target.matches('.transfer-action-btn.refuse')) {
              e.stopPropagation();
              if (details.status !== 'pending') return;

              details.status = 'refused';
              details.events.push({ status: 'refused', timestamp: Date.now(), actor: 'char' });

              // 把钱退给用户，并记录
              await addUserTransaction(currentChatId, details.amount, `收到来自 ${details.recipientName} 的转账退款`);

              await saveChatData();
              renderChatMessages(currentChatId);
            } else if (e.target.matches('.transfer-action-btn.user-accept')) {
              e.stopPropagation();
              if (details.status !== 'pending') return;

              details.status = 'accepted';
              details.events.push({ status: 'accepted', timestamp: Date.now(), actor: 'user' });

              await addUserTransaction(currentChatId, details.amount, `收到来自 ${details.senderName} 的转账`);

              // 【【【核心修改】】】
              const systemMessage = {
                role: 'system', // 角色改为 system
                content: `[系统提示：你接受了来自 ${details.senderName} 的转账]`,
                isSystemNotification: true, // 添加这个标志以应用特殊样式
              };
              chatData[currentChatId].history.push(systemMessage);

              await saveChatData();
              renderChatMessages(currentChatId);
            }
            // 情况四：User 点击了“退还”按钮
            else if (e.target.matches('.transfer-action-btn.user-refuse')) {
              e.stopPropagation();
              if (details.status !== 'pending') return;

              details.status = 'refused';
              details.events.push({ status: 'refused', timestamp: Date.now(), actor: 'user' });

              await addTransaction(currentChatId, details.amount, `收到来自 ${details.recipientName} 的转账退款`);

              // 【【【核心修改】】】
              const systemMessage = {
                role: 'system', // 角色改为 system
                content: `[系统提示：你退还了来自 ${details.senderName} 的转账]`,
                isSystemNotification: true, // 添加这个标志
              };
              chatData[currentChatId].history.push(systemMessage);

              await saveChatData();
              renderChatMessages(currentChatId);
            }
            // 情况三：点击了卡片本身，查看详情
            else {
              const listEl = document.getElementById('transfer-status-list');
              const statusText = {
                pending: '等待对方收款',
                accepted: '已收款',
                refused: '已退还',
              };
              listEl.innerHTML = `
                    <li style="padding: 5px 0;"><strong>金额:</strong> <span style="font-size: 1.2em; color: var(--accent-color);">¥${details.amount.toFixed(
                      2,
                    )}</span></li>
                    <li style="padding: 5px 0;"><strong>状态:</strong> ${statusText[details.status]}</li>
                    <li style="padding: 5px 0;"><strong>发起方:</strong> ${details.senderName}</li>
                    <li style="padding: 5px 0;"><strong>接收方:</strong> ${details.recipientName}</li>
                    <li style="padding: 5px 0;"><strong>备注:</strong> ${details.remark}</li>
                    <li style="padding: 5px 0;"><strong>发起时间:</strong> ${new Date(
                      details.events[0].timestamp,
                    ).toLocaleString()}</li>
                `;
              // 如果转账已完成，显示完成时间
              if (details.status !== 'pending') {
                const finalEvent = details.events[details.events.length - 1];
                listEl.innerHTML += `<li style="padding: 5px 0;"><strong>完成时间:</strong> ${new Date(
                  finalEvent.timestamp,
                ).toLocaleString()}</li>`;
              }
              showModal(document.getElementById('transferStatusModal'));
            }
          });
          // ▲▲▲ 新代码粘贴到这里结束 ▲▲▲
          // --- 用户钱包功能事件监听 (新) ---

          // 1. 设置/重置初始余额
          document.getElementById('setUserInitialBalanceBtn').addEventListener('click', async () => {
            if (!currentChatId) return;

            const initialBalanceInput = document.getElementById('userInitialBalance');
            const newInitialBalance = parseFloat(initialBalanceInput.value);

            if (isNaN(newInitialBalance)) {
              alert('请输入有效的数字作为初始余额！');
              return;
            }

            if (
              confirm(`确定要将余额重置并设定为 ¥${newInitialBalance.toFixed(2)} 吗？\n这会清空你所有的历史交易记录！`)
            ) {
              const wallet = chatData[currentChatId].userSettings.wallet;
              wallet.balance = 0; // 先清零
              wallet.transactions = []; // 清空记录
              await addUserTransaction(currentChatId, newInitialBalance, '初始资金');
              alert('初始余额已设定！');
            }
          });

          // 2. 查看交易记录
          document.getElementById('viewUserTransactionLogBtn').addEventListener('click', () => {
            if (currentChatId) {
              const userTransactionLogModal = document.getElementById('userTransactionLogModal');
              const listEl = document.getElementById('user-transaction-log-list');
              const transactions = chatData[currentChatId].userSettings.wallet.transactions || [];

              if (transactions.length === 0) {
                listEl.innerHTML = `<li style="text-align: center; color: var(--text-secondary-color); padding: 20px;">暂无记录</li>`;
              } else {
                listEl.innerHTML = transactions
                  .map(t => {
                    const date = new Date(t.timestamp).toLocaleString('zh-CN');
                    const amountClass = t.amount >= 0 ? 'income' : 'expense';
                    const amountSign = t.amount >= 0 ? '+' : '';
                    return `
                    <li class="transaction-log-item">
                        <div class="transaction-info">
                            <span class="transaction-description">${t.description}</span>
                            <span class="transaction-date">${date}</span>
                        </div>
                        <span class="transaction-amount ${amountClass}">
                            ${amountSign}${t.amount.toFixed(2)}
                        </span>
                    </li>
                `;
                  })
                  .join('');
              }
              showModal(userTransactionLogModal);
            }
          });

          // 3. 关闭交易记录弹窗
          document.getElementById('closeUserTransactionLogBtn').addEventListener('click', () => {
            hideModal(document.getElementById('userTransactionLogModal'));
          });
          // ▲▲▲ 新增事件监听结束 ▲▲▲
          // ================== 礼物商店事件监听 (新) ==================
          if (toolbarGiftBtn) {
            toolbarGiftBtn.addEventListener('click', () => {
              renderGiftShop();
              shoppingCart = []; // 每次打开清空购物车
              renderShoppingCart();
              closeAllPanels();
              phoneScreen.style.display = 'none';
              giftShopPage.classList.add('active');
            });
          }

          document.getElementById('ai-generate-gifts-btn').addEventListener('click', generateGiftsByAI);
          document.getElementById('ai-search-gifts-btn').addEventListener('click', searchGiftsByAI);
          document.getElementById('gift-shop-back-btn').addEventListener('click', () => {
            giftShopPage.classList.remove('active');
            phoneScreen.style.display = 'flex';
          });

          document.getElementById('open-cart-btn').addEventListener('click', () => {
            renderShoppingCart();
            showModal(shoppingCartModal);
          });

          document.getElementById('close-cart-btn').addEventListener('click', () => hideModal(shoppingCartModal));

          document.getElementById('checkout-btn').addEventListener('click', checkoutAndSendGifts);

          // 使用事件委托处理 "加入购物车"
          document.getElementById('gift-list-container').addEventListener('click', e => {
            if (e.target.classList.contains('add-to-cart-btn')) {
              const giftId = parseInt(e.target.dataset.giftId, 10);
              const gift = giftShopItems.find(g => g.id === giftId);
              if (gift) {
                shoppingCart.push(gift);
                renderShoppingCart(); // 更新购物车角标和内容

                // 可爱的小动画提示
                const btn = e.target;
                btn.textContent = '已添加!';
                setTimeout(() => {
                  btn.textContent = '加入购物车';
                }, 1000);
              }
            }
          });

          // 使用事件委托处理 "从购物车移除"
          document.getElementById('cart-items-list').addEventListener('click', e => {
            if (e.target.classList.contains('remove-cart-item-btn')) {
              const cartIndex = parseInt(e.target.dataset.cartIndex, 10);
              shoppingCart.splice(cartIndex, 1);
              renderShoppingCart(); // 更新购物车
            }
          });
          // --- ✨ 魔法字体小屋事件监听 (升级版) ✨ ---

          const fontModal = document.getElementById('fontManagerModal');

          // 1. 打开弹窗
          const fontAppIcon = document.querySelector('.app-container[data-app-id="app5"]');
          if (fontAppIcon) {
            const link = fontAppIcon.querySelector('a');
            if (link) link.href = 'javascript:void(0)';

            fontAppIcon.addEventListener('click', () => {
              renderFontManagerList();
              showModal(fontModal);
            });
          }

          document.getElementById('closeFontManagerBtn').addEventListener('click', () => {
            hideModal(fontModal);
          });

          // 2. Tab 切换逻辑
          document.getElementById('fontManagerTabs').addEventListener('click', e => {
            if (e.target.classList.contains('cute-tab-btn')) {
              // 移除所有激活状态
              document.querySelectorAll('.cute-tab-btn').forEach(b => b.classList.remove('active'));
              document.querySelectorAll('.cute-tab-content').forEach(c => c.classList.remove('active'));

              // 激活当前点击的
              e.target.classList.add('active');
              const tabId = e.target.dataset.tab;
              document.getElementById(`tab-${tabId}`).classList.add('active');
            }
          });

          // 3. 添加单个字体 (逻辑不变)
          document.getElementById('addNewFontBtn').addEventListener('click', async () => {
            const name = document.getElementById('newFontName').value.trim();
            const url = document.getElementById('newFontUrl').value.trim();

            if (!name || !url) {
              alert('请填写完整哦！(>_<)');
              return;
            }

            try {
              const existing = await db.customFonts.where('name').equals(name).first();
              if (existing) {
                alert('这个名字已经有过啦！');
                return;
              }

              await db.customFonts.add({ name, url });
              document.getElementById('newFontName').value = '';
              document.getElementById('newFontUrl').value = '';

              // 自动跳回列表页
              document.querySelector('[data-tab="library"]').click();
              renderFontManagerList();
              alert(`✨ 成功捕获字体：${name}`);
            } catch (e) {
              alert('添加失败惹...');
            }
          });

          // 4. 【新功能】批量导入字体
          document.getElementById('batchAddFontBtn').addEventListener('click', async () => {
            const text = document.getElementById('batchFontInput').value.trim();
            if (!text) {
              alert('请先粘贴内容哦~');
              return;
            }

            const lines = text.split('\n');
            let successCount = 0;
            let failCount = 0;

            for (const line of lines) {
              const cleanLine = line.trim();
              if (!cleanLine) continue;

              // 智能解析逻辑：支持中文冒号、英文冒号、空格分隔
              // 正则逻辑：匹配任意冒号或空格作为分隔符
              // split limit 2 确保只分两半，防止URL里有冒号被切断
              // 但 JS split 正则不能 limit，所以我们手动处理

              let name = '';
              let url = '';

              // 尝试分割
              const separators = [':', '：', ' ', '\t']; // 常见分隔符
              let splitIndex = -1;

              // 找到第一个分隔符的位置
              for (let i = 0; i < cleanLine.length; i++) {
                if (separators.includes(cleanLine[i])) {
                  // 确保不是 http: 里的冒号 (简单的判断：分隔符后面不应该紧跟 /)
                  if (cleanLine[i] === ':' && cleanLine[i + 1] === '/' && cleanLine[i + 2] === '/') {
                    continue;
                  }
                  splitIndex = i;
                  break;
                }
              }

              if (splitIndex > -1) {
                name = cleanLine.substring(0, splitIndex).trim();
                url = cleanLine.substring(splitIndex + 1).trim();
                // 去掉可能存在的 http 之前的空格或符号
                url = url.replace(/^[：:\s]+/, '');
              } else {
                // 没找到分隔符？这行可能是废的，或者只有链接
                failCount++;
                continue;
              }

              if (name && url) {
                try {
                  // 检查重复
                  const existing = await db.customFonts.where('name').equals(name).first();
                  if (!existing) {
                    await db.customFonts.add({ name, url });
                    successCount++;
                  } else {
                    failCount++; // 重复算失败或跳过
                  }
                } catch (e) {
                  failCount++;
                }
              }
            }

            document.getElementById('batchFontInput').value = '';
            // 跳回列表页
            document.querySelector('[data-tab="library"]').click();
            renderFontManagerList();

            alert(`📦 导入完成！\n成功: ${successCount} 个\n跳过/失败: ${failCount} 个`);
          });

          // 5. 字体列表点击 (应用/删除) - 适配新的 DOM 结构
          document.getElementById('fontListContainer').addEventListener('click', async e => {
            const btn = e.target.closest('.mini-btn'); // 找最近的按钮
            if (!btn) return;

            // 找到父级卡片的数据ID（需要我们稍微改一下 render 函数来把 ID 绑在按钮上，或者通过卡片找）
            // 这里我们假设 render 函数会在按钮上绑 data-id (下面会改 render 函数)
            const fontId = parseInt(btn.dataset.id, 10);

            if (btn.classList.contains('apply')) {
              const fontData = await db.customFonts.get(fontId);
              if (fontData) {
                applyFontToPage(fontData);
                currentActiveFontId = fontId;
                await db.userSettings.put({ id: 'activeFontId', value: fontId });
                renderFontManagerList();
              }
            } else if (btn.classList.contains('delete')) {
              if (confirm('真的要丢弃这个字体吗？(QwQ)')) {
                await db.customFonts.delete(fontId);
                if (currentActiveFontId === fontId) {
                  applyFontToPage(null);
                  currentActiveFontId = null;
                  await db.userSettings.delete('activeFontId');
                }
                renderFontManagerList();
              }
            }
          });

          // 6. 恢复默认
          document.getElementById('resetFontBtn').addEventListener('click', async () => {
            applyFontToPage(null);
            currentActiveFontId = null;
            await db.userSettings.delete('activeFontId');
            renderFontManagerList();
            alert('已变回原来的样子啦~');
          });
          // ▼▼▼ 把这段代码粘贴在“恢复默认”按钮的后面 ▼▼▼

          // 7. 新增：字体大小滑块监听
          const fontSizeSlider = document.getElementById('fontSizeSlider');
          if (fontSizeSlider) {
            // 拖动时实时预览
            fontSizeSlider.addEventListener('input', e => {
              const delta = parseInt(e.target.value);
              applyFontSize(delta);
            });

            // 松开鼠标时保存设置
            fontSizeSlider.addEventListener('change', async e => {
              const delta = parseInt(e.target.value);
              await db.userSettings.put({ id: 'fontSizeDelta', value: delta });
            });
          }
          // ▲▲▲ 粘贴结束 ▲▲▲
        }

        // --- Part 5: 其他独立的旧功能 ---
        function setupLegacyListeners() {
          const IMAGE_ELEMENT_IDS = ['profileDot', 'profileAvatar', 'imagePlaceholder'];
          const TEXT_ELEMENT_IDS = [
            'mainChatInput',
            'moodInput',
            'thoughtTextarea',
            'magicPromptInput',
            'imageDescriptionInput',
          ];
          IMAGE_ELEMENT_IDS.forEach(id => {
            const el = document.getElementById(id);
            if (el)
              el.addEventListener('click', () => {
                currentEditingTarget = el;
                showModal(imageChoiceModal);
              });
          });
          TEXT_ELEMENT_IDS.forEach(id => {
            const el = document.getElementById(id);
            if (el)
              el.addEventListener('focus', e => {
                e.preventDefault();
                el.blur();
                currentEditingTarget = el;
                document.getElementById('textEditTitle').textContent = `编辑 "${el.placeholder}"`;
                document.getElementById('textEditArea').value = el.value;
                showModal(textEditModal);
                setTimeout(() => document.getElementById('textEditArea').focus(), 310);
              });
          });
          document.getElementById('saveTextBtn').addEventListener('click', async () => {
            // <--- 添加 async
            if (
              currentEditingTarget &&
              typeof currentEditingTarget !== 'string' &&
              currentEditingTarget.type === undefined
            ) {
              const newValue = document.getElementById('textEditArea').value;
              currentEditingTarget.value = newValue;
              // 也保存到 IndexedDB
              await db.userSettings.put({ id: currentEditingTarget.id, value: newValue });
            }
            hideModal(textEditModal);
          });
          [imageChoiceModal, textEditModal, settingsModal, editAppModal, apiSettingsModal].forEach(modal => {
            if (modal)
              modal.addEventListener('click', e => {
                if (e.target === modal) hideModal(modal);
              });
          });
          document.getElementById('closeChoiceModal').addEventListener('click', () => hideModal(imageChoiceModal));
          document.getElementById('cancelTextBtn').addEventListener('click', () => hideModal(textEditModal));
        }

        const updateImageUI = (element, imageData) => {
          if (element.id === 'imagePlaceholder') {
            element.textContent = ''; // 确保上传图片后，不再显示任何文字
          }
          if (element.tagName.toLowerCase() === 'img') {
            element.src = imageData;
          } else {
            element.style.backgroundImage = `url(${imageData})`;
          }
        };
        // =================================================================
        // ================== NPC 和 表情包库核心逻辑 (新增) ==================
        // =================================================================
        let activeStickerTab = 'exclusive'; // 默认激活专属表情包tab
        let isStickerManageMode = false; // 用于跟踪是否处于表情管理模式

        // --- 数据加载与保存 ---
        async function loadCommonStickers() {
          const data = await db.userSettings.get('commonStickers');
          commonStickers = data ? data.value : [];
        }

        async function saveCommonStickers() {
          await db.userSettings.put({ id: 'commonStickers', value: commonStickers });
        }
        // ================== 用户专属表情包逻辑 (新) ==================
        async function loadUserStickers() {
          // 由于这张表结构简单，可以直接 toArray
          userStickers = await db.userStickers.toArray();
        }

        // 用这个新版本替换旧的 renderUserStickers 函数
        function renderUserStickers() {
          const grid = document.getElementById('user-sticker-grid');
          const panel = document.getElementById('user-sticker-panel');
          if (!grid || !panel) return;

          // 1. 渲染分类 Tabs
          renderUserStickerCategories();

          const filteredStickers = userStickers.filter(s => (s.category || '未分类') === activeUserStickerCategory);

          // 3. 渲染表情网格
          if (filteredStickers.length === 0) {
            grid.innerHTML = `<p style="color: var(--text-secondary-color); text-align:center; font-size: 14px; padding: 40px 20px;">该分类下没有表情哦！<br>${
              activeUserStickerCategory === '全部' ? '点击右上角“管理”按钮添加吧' : '换个分类看看吧'
            }</p>`;
          } else {
            grid.innerHTML = filteredStickers
              .map(sticker => {
                // 找到它在原始 userStickers 数组中的索引
                const originalIndex = userStickers.findIndex(s => s.id === sticker.id);
                return `
                        <div class="sticker-item user-sticker-item" data-id="${
                          sticker.id
                        }" data-original-index="${originalIndex}">
                            <img src="${sticker.url}" alt="${sticker.desc || ''}" loading="lazy">
                            <p>${sticker.desc || ' '}</p>
                        </div>
                    `;
              })
              .join('');
          }

          // 4. 根据管理模式更新UI
          if (isUserStickerManageMode) {
            panel.classList.add('manage-mode');
            document.getElementById('user-sticker-normal-buttons').style.display = 'none';
            document.getElementById('user-sticker-manage-buttons').style.display = 'flex';
          } else {
            panel.classList.remove('manage-mode');
            document.getElementById('user-sticker-normal-buttons').style.display = 'flex';
            document.getElementById('user-sticker-manage-buttons').style.display = 'none';
          }
        }
        // 用这个【V3 新版本】替换旧的 renderUserStickerCategories 函数
        function renderUserStickerCategories() {
          const tabsContainer = document.getElementById('user-sticker-category-tabs');
          const panel = document.getElementById('user-sticker-panel');
          if (!tabsContainer || !panel) return;

          const categories = {};
          // 1. 统计所有分类及其预览图
          userStickers.forEach(sticker => {
            const category = sticker.category || '未分类';
            if (!categories[category]) {
              categories[category] = sticker.url;
            }
          });

          // 如果没有任何表情，确保 "未分类" Tab 存在
          if (userStickers.length === 0 && !categories['未分类']) {
            categories['未分类'] = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
          }

          // 2. 将分类名排序，并把“未分类”放到最前面
          const sortedNames = Object.keys(categories).sort();
          const unclassifiedIndex = sortedNames.indexOf('未分类');
          if (unclassifiedIndex > 0) {
            const unclassified = sortedNames.splice(unclassifiedIndex, 1)[0];
            sortedNames.unshift(unclassified);
          }

          // 3. 渲染 HTML
          tabsContainer.innerHTML = sortedNames
            .map(name => {
              const isActive = name === activeUserStickerCategory;
              const previewUrl = categories[name];

              // 在管理模式下为非“未分类”的tab添加删除按钮
              const deleteButtonHTML =
                isUserStickerManageMode && name !== '未分类'
                  ? `<button class="delete-category-btn" data-category-name="${name}">&times;</button>`
                  : '';

              return `
                    <div class="sticker-category-tab ${isActive ? 'active' : ''}" data-category-name="${name}">
                        ${deleteButtonHTML}
                        <img src="${previewUrl}" alt="${name}">
                        <span>${name}</span>
                    </div>
                `;
            })
            .join('');
        }

        // ▼▼▼ 请找到并用下面的函数替换你原来的 sendUserSticker 函数 ▼▼▼

        async function sendUserSticker(originalIndex) {
          // <--- 增加了 async
          const sticker = userStickers[originalIndex];
          if (!sticker) return;

          const message = {
            role: 'user',
            content: `[sticker]${sticker.url}[/sticker]`,
            isStaging: true, // 标记为待发送
          };

          chatData[currentChatId].history.push(message);

          // 【【【新增】】】保存聊天数据到数据库！
          await saveChatData();

          renderChatMessages(currentChatId);

          closeAllPanels();
        }

        // --- NPC 库功能 ---
        function openNpcLibraryModal() {
          if (!currentChatId) return;
          renderNpcList();
          showModal(document.getElementById('npcLibraryModal'));
        }

        function renderNpcList() {
          const npcListElement = document.getElementById('npcList');
          const npcs = chatData[currentChatId].charSettings.npcs || [];
          npcListElement.innerHTML = '';

          if (npcs.length === 0) {
            npcListElement.innerHTML = `<li style="text-align: center; color: var(--text-secondary-color); font-size: 13px; padding: 10px 0;">暂无NPC</li>`;
            return;
          }

          npcs.forEach(npc => {
            const li = document.createElement('li');
            li.innerHTML = `
                    <img src="${npc.avatar}" alt="npc avatar">
                    <div class="npc-item-info">
                        <span class="npc-name">${npc.name}</span>
                        <span class="npc-relation">关系: ${npc.relation}</span>
                    </div>
                    <div class="button-group">
                        <button class="edit-npc-btn" data-npc-id="${npc.id}">编辑</button>
                        <button class="delete-npc-btn" data-npc-id="${npc.id}">删除</button>
                    </div>`;
            npcListElement.appendChild(li);
          });
        }

        function openEditNpcModal(mode, npcId = null) {
          const modal = document.getElementById('editNpcModal');
          const title = document.getElementById('editNpcModalTitle');
          const createSection = document.getElementById('createNewNpcSection');
          const selectSection = document.getElementById('selectCharAsNpcSection');

          currentNpcEditMode = mode;
          currentEditingNpcId = npcId;

          // 重置表单
          document.getElementById('npcAvatarPreview').src = 'https://picsum.photos/seed/npc/100';
          document.getElementById('npcNameInput').value = '';
          document.getElementById('npcPersonaInput').value = '';
          document.getElementById('npcRelationInput').value = '';

          if (mode === 'create') {
            title.textContent = '创建新 NPC';
            createSection.style.display = 'block';
            selectSection.style.display = 'none';
          } else if (mode === 'select') {
            title.textContent = '选择已有角色作为 NPC';
            createSection.style.display = 'none';
            selectSection.style.display = 'block';
            populateExistingCharSelect();
          } else if (mode === 'edit') {
            title.textContent = '编辑 NPC';
            createSection.style.display = 'block';
            selectSection.style.display = 'none';

            const npc = chatData[currentChatId].charSettings.npcs.find(n => n.id === npcId);
            if (npc) {
              if (npc.isExistingChar) {
                // 如果是关联的已有角色
                title.textContent = `编辑与 ${npc.name} 的关系`;
                createSection.style.display = 'none';
                // 可以在此显示一个不可编辑的名称和头像
              } else {
                // 如果是创建的
                document.getElementById('npcAvatarPreview').src = npc.avatar;
                document.getElementById('npcNameInput').value = npc.name;
                document.getElementById('npcPersonaInput').value = npc.persona;
              }
              document.getElementById('npcRelationInput').value = npc.relation;
            }
          }
          showModal(modal);
        }

        function populateExistingCharSelect() {
          const select = document.getElementById('existingCharSelect');
          select.innerHTML = '<option value="">-- 请选择 --</option>';
          Object.keys(chatData).forEach(charId => {
            // 不把自己和已经是NPC的角色加入列表
            const isAlreadyNpc = (chatData[currentChatId].charSettings.npcs || []).some(
              npc => npc.charIdRef === charId,
            );
            if (charId !== currentChatId && !isAlreadyNpc) {
              const option = document.createElement('option');
              option.value = charId;
              option.textContent = chatData[charId].charSettings.nickname;
              select.appendChild(option);
            }
          });
        }

        async function saveNpcData() {
          const relation = document.getElementById('npcRelationInput').value.trim();
          if (!relation) {
            alert('“与主Char的关系”是必填项！');
            return;
          }

          const charNpcs = chatData[currentChatId].charSettings.npcs || [];

          if (currentEditingNpcId) {
            // 编辑模式
            const npcIndex = charNpcs.findIndex(n => n.id === currentEditingNpcId);
            if (npcIndex > -1) {
              const npc = charNpcs[npcIndex];
              npc.relation = relation;
              if (!npc.isExistingChar) {
                npc.avatar = document.getElementById('npcAvatarPreview').src;
                npc.name = document.getElementById('npcNameInput').value.trim();
                npc.persona = document.getElementById('npcPersonaInput').value.trim();
                if (!npc.name) {
                  alert('NPC名字不能为空！');
                  return;
                }
              }
            }
          } else {
            // 创建模式
            let newNpc;
            if (currentNpcEditMode === 'create') {
              const name = document.getElementById('npcNameInput').value.trim();
              if (!name) {
                alert('NPC名字不能为空！');
                return;
              }
              newNpc = {
                id: `npc_${Date.now()}`,
                isExistingChar: false,
                avatar: document.getElementById('npcAvatarPreview').src,
                name: name,
                persona: document.getElementById('npcPersonaInput').value.trim(),
                relation: relation,
              };
            } else {
              // 'select' mode
              const selectedCharId = document.getElementById('existingCharSelect').value;
              if (!selectedCharId) {
                alert('请选择一个角色！');
                return;
              }
              const charInfo = chatData[selectedCharId].charSettings;
              newNpc = {
                id: `npc_${Date.now()}`,
                isExistingChar: true,
                charIdRef: selectedCharId, // 关联ID
                avatar: charInfo.avatar,
                name: charInfo.nickname,
                persona: charInfo.persona, // 可以选择性引用
                relation: relation,
              };
            }
            charNpcs.push(newNpc);
          }

          chatData[currentChatId].charSettings.npcs = charNpcs;
          await saveChatData();
          renderNpcList();
          hideModal(document.getElementById('editNpcModal'));
        }

        async function deleteNpc(npcId) {
          if (confirm('确定要删除这个NPC吗？')) {
            let npcs = chatData[currentChatId].charSettings.npcs || [];
            chatData[currentChatId].charSettings.npcs = npcs.filter(n => n.id !== npcId);
            await saveChatData();
            renderNpcList();
          }
        }

        function openStickerLibraryModal(context = 'char') {
          currentStickerContext = context;
          const modal = document.getElementById('stickerLibraryModal');
          const modalTitle = modal.querySelector('h3');
          const tabs = document.getElementById('stickerTabs');

          // 重置管理模式
          isStickerManageMode = false;
          modal.classList.remove('manage-mode');
          document.getElementById('stickerNormalButtons').style.display = 'flex';
          document.getElementById('stickerManageButtons').style.display = 'none';

          if (context === 'user') {
            // 用户表情包模式
            modalTitle.textContent = '我的表情包';
            tabs.style.display = 'none'; // 隐藏 "专属/通用" Tabs

            // 只显示专属表情的容器，但用来展示用户表情
            document.getElementById('exclusiveStickersTab').classList.add('active');
            document.getElementById('commonStickersTab').classList.remove('active');
            document.getElementById('commonStickersTab').style.display = 'none';

            // TODO: 这里应该调用一个渲染用户表情的函数
            // renderMyStickers(); // 假设有这样一个函数
            alert('打开用户表情库 - 逻辑待实现');
          } else {
            // context === 'char'
            // 角色表情包模式
            if (!currentChatId) return;
            modalTitle.textContent = '角色表情包库';
            tabs.style.display = 'flex'; // 显示 "专属/通用" Tabs

            // 确保两个Tab内容区域都可见
            document.getElementById('exclusiveStickersTab').style.display = 'block';
            document.getElementById('commonStickersTab').style.display = 'block';

            // 默认激活“专属表情”Tab
            document.querySelector('.sticker-tab-btn[data-tab="exclusive"]').classList.add('active');
            document.querySelector('.sticker-tab-btn[data-tab="common"]').classList.remove('active');
            document.getElementById('exclusiveStickersTab').classList.add('active');
            document.getElementById('commonStickersTab').classList.remove('active');
            activeStickerTab = 'exclusive';

            renderStickers(); // 调用渲染函数，填充角色专属和通用表情
          }

          showModal(modal);
        }

        // ▼▼▼ 用这个【修正版】替换旧的 renderStickers 函数 ▼▼▼
        function renderStickers() {
          const exclusiveGrid = document.getElementById('exclusiveStickerGrid');
          const commonGrid = document.getElementById('commonStickerGrid');

          // 确保 charData 和 stickers 数组存在，防止出错
          const exclusiveStickers = chatData[currentChatId]?.charSettings?.exclusiveStickers || [];
          const globalCommonStickers = commonStickers || [];

          const createStickerHTML = (sticker, index, type) => `
                <div class="sticker-item" data-index="${index}" data-type="${type}">
                    <img src="${sticker.url}" alt="${sticker.desc || ''}" loading="lazy">
                    <p>${sticker.desc || ' '}</p>
                    <button class="delete-sticker-btn">&times;</button>
                </div>`;

          // 1. 单独渲染“专属表情”网格
          if (exclusiveStickers.length > 0) {
            exclusiveGrid.innerHTML = exclusiveStickers.map((s, i) => createStickerHTML(s, i, 'exclusive')).join('');
          } else {
            exclusiveGrid.innerHTML =
              '<p style="text-align: center; color: var(--text-secondary-color); font-size: 13px; padding: 20px 0;">该角色没有专属表情</p>';
          }

          // 2. 单独渲染“通用表情”网格
          if (globalCommonStickers.length > 0) {
            commonGrid.innerHTML = globalCommonStickers.map((s, i) => createStickerHTML(s, i, 'common')).join('');
          } else {
            commonGrid.innerHTML =
              '<p style="text-align: center; color: var(--text-secondary-color); font-size: 13px; padding: 20px 0;">没有通用表情</p>';
          }
        }

        function openAddStickersModal() {
          const modal = document.getElementById('addStickersModal');
          const title = document.getElementById('addStickersTitle');

          // 根据当前激活的Tab动态设置标题
          if (activeStickerTab === 'exclusive') {
            title.textContent = '添加专属表情';
          } else {
            title.textContent = '添加通用表情';
          }

          document.getElementById('stickerBulkAddArea').value = '';
          showModal(modal);
        }

        // ▼▼▼ 用这个【修正版】替换旧的 parseAndSaveStickers 函数 ▼▼▼
        async function parseAndSaveStickers() {
          const text = document.getElementById('stickerBulkAddArea').value.trim();
          if (!text) return;

          // 解析逻辑保持不变
          const lines = text.split('\n');
          const newStickers = [];
          lines.forEach(line => {
            let desc = '';
            let url = '';
            const colonMatch = line.match(/[:：]/);
            if (colonMatch) {
              const delimiterIndex = colonMatch.index;
              desc = line.substring(0, delimiterIndex).trim();
              url = line.substring(delimiterIndex + 1).trim();
            } else {
              const lastSpaceIndex = line.lastIndexOf(' ');
              if (lastSpaceIndex > 0) {
                desc = line.substring(0, lastSpaceIndex).trim();
                url = line.substring(lastSpaceIndex + 1).trim();
              }
            }
            // 我们只创建带URL的有效表情对象
            if (url) {
              newStickers.push({ desc, url });
            }
          });

          if (newStickers.length === 0) {
            alert('没有解析到有效的表情包数据，请检查格式！');
            return;
          }

          // 关键修正：根据上下文和当前激活的 Tab 来决定数据存到哪里
          if (currentStickerContext === 'user') {
            // 这是为“我的表情包”准备的逻辑，暂时不变
            const userStickersWithCategory = newStickers.map(s => ({
              ...s,
              category: activeUserStickerCategory === '全部' ? '未分类' : activeUserStickerCategory,
            }));
            await db.userStickers.bulkAdd(userStickersWithCategory);
            await loadUserStickers();
            renderUserStickers();
          } else {
            // 这是角色表情包的逻辑 (currentStickerContext === 'char')

            // 【【【核心修正点在这里！】】】
            if (activeStickerTab === 'exclusive') {
              // 如果当前在“专属表情”Tab，则添加到当前角色的数据里
              console.log(`Adding ${newStickers.length} stickers to EXCLUSIVE for char: ${currentChatId}`);
              if (!chatData[currentChatId].charSettings.exclusiveStickers) {
                chatData[currentChatId].charSettings.exclusiveStickers = [];
              }
              chatData[currentChatId].charSettings.exclusiveStickers.push(...newStickers);
              await saveChatData();
            } else {
              // activeStickerTab === 'common'
              // 如果当前在“通用表情”Tab，则添加到全局的 commonStickers 数组里
              console.log(`Adding ${newStickers.length} stickers to COMMON`);
              commonStickers.push(...newStickers);
              await saveCommonStickers();
            }

            // 渲染两个网格，确保数据实时更新
            renderStickers();
          }

          hideModal(document.getElementById('addStickersModal'));
        }

        async function deleteCharSticker(type, index) {
          // 确保 chatData 和当前角色的 exclusiveStickers 数组存在
          if (!chatData[currentChatId] || !chatData[currentChatId].charSettings) return;

          // 安全地初始化数组
          if (!chatData[currentChatId].charSettings.exclusiveStickers) {
            chatData[currentChatId].charSettings.exclusiveStickers = [];
          }
          if (!commonStickers) {
            commonStickers = [];
          }

          if (type === 'exclusive') {
            chatData[currentChatId].charSettings.exclusiveStickers.splice(index, 1);
            await saveChatData();
          } else if (type === 'common') {
            commonStickers.splice(index, 1);
            await saveCommonStickers();
          }

          // 删除后重新渲染角色表情包库
          renderStickers();
        }

        async function deleteSticker(type, index) {
          if (type === 'exclusive') {
            chatData[currentChatId].charSettings.exclusiveStickers.splice(index, 1);
            await saveChatData();
          } else {
            commonStickers.splice(index, 1);
            await saveCommonStickers();
          }
          renderStickers();
        }
        // =================================================================
        // ================== 世界书核心逻辑 (全新) ==================
        // =================================================================
        let allWorldBooks = [];
        let currentEditingWorldBookId = null;
        let currentEditingEntryUid = null;

        // --- 数据操作 ---
        async function loadWorldBooks() {
          allWorldBooks = await db.worldBooks.toArray();
        }

        async function saveWorldBooks() {
          // 由于 allWorldBooks 是一个完整的数组，我们不能直接 put
          // 而是遍历它，根据 id 来更新每个 worldbook
          for (const wb of allWorldBooks) {
            if (wb.id) {
              await db.worldBooks.put(wb);
            }
          }
        }

        function renderWorldBookList() {
          const container = document.getElementById('worldbook-list-container');
          container.innerHTML = '';
          if (allWorldBooks.length === 0) {
            container.innerHTML = `<p style="text-align:center; padding: 40px 20px; color: var(--text-secondary-color);">还没有世界书，点击下方按钮创建一个吧！</p>`;
            return;
          }

          allWorldBooks.forEach(wb => {
            const itemCount = Object.keys(wb.entries || {}).length;
            const item = document.createElement('div');
            item.className = 'worldbook-list-item';

            item.innerHTML = `
                <div class="worldbook-content-wrapper" data-worldbook-id="${wb.id}">
                    <div class="worldbook-icon">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path></svg>
                    </div>
                    <div class="worldbook-info">
                        <span class="worldbook-name">${wb.name}</span>
                        <p class="worldbook-stats">包含 ${itemCount} 个条目</p>
                    </div>
                </div>
                <!-- ▼▼▼ 就改下面这一行 ▼▼▼ -->
                <button class="delete-worldbook-btn" data-worldbook-id="${wb.id}" style="background: transparent; color: #8e8e93; border: none; font-size: 24px; cursor: pointer; flex-shrink: 0; margin-left: 10px; padding: 5px;">&times;</button>
            `;
            container.appendChild(item);
          });
        }

        function renderWorldBookDetail(worldBookId) {
          const wb = allWorldBooks.find(w => w.id === worldBookId);
          if (!wb) return;

          document.getElementById('worldbook-detail-title').textContent = wb.name;
          const container = document.getElementById('worldbook-entry-list-container');
          container.innerHTML = '';

          const entries = wb.entries || {};
          if (Object.keys(entries).length === 0) {
            container.innerHTML = `<p style="text-align:center; padding: 40px 20px; color: var(--text-secondary-color);">这个世界书还是空的，点击下方按钮添加第一个条目吧！</p>`;
            return;
          }

          // 按 order 字段排序
          const sortedEntries = Object.values(entries).sort((a, b) => (a.order || 0) - (b.order || 0));

          sortedEntries.forEach(entry => {
            const item = document.createElement('div');
            item.className = 'worldbook-entry-item';
            item.innerHTML = `
            <div class="entry-header">
                <span class="entry-name">${entry.comment || '未命名条目'}</span>
                <div class="entry-controls">
                    <button class="edit-entry-btn" data-entry-uid="${entry.uid}">编辑</button>
                    <button class="delete-entry-btn" data-entry-uid="${
                      entry.uid
                    }" style="background-color: #ff3b30; color: white;">删除</button>
                </div>
            </div>
            <div class="entry-details">
                <p><strong>关键词:</strong></p>
                <div class="keywords-container">
                    ${(entry.key || []).map(k => `<span class="keyword-tag">${k}</span>`).join('') || '<span>无</span>'}
                </div>
                <p style="margin-top: 10px;"><strong>内容:</strong> ${entry.content || '无'}</p>
                <p><strong>顺序:</strong> ${entry.order ?? 'N/A'} | <strong>概率:</strong> ${
              entry.probability ?? 'N/A'
            }%</p>
            </div>
        `;
            container.appendChild(item);
          });
        }

        // --- 弹窗与交互 ---
        function openWorldBookEntryModal(worldBookId, entryUid = null) {
          currentEditingWorldBookId = worldBookId;
          currentEditingEntryUid = entryUid;

          const modal = document.getElementById('editWorldBookEntryModal');
          const title = document.getElementById('editWorldBookEntryTitle');

          // 重置表单
          document.getElementById('entryNameInput').value = '';
          document.getElementById('entryKeysInput').value = '';
          document.getElementById('entryContentInput').value = '';
          document.getElementById('entryOrderInput').value = 100;
          document.getElementById('entryProbabilityInput').value = 100;

          if (entryUid !== null) {
            title.textContent = '编辑条目';
            const wb = allWorldBooks.find(w => w.id === worldBookId);
            const entry = wb?.entries?.[entryUid];
            if (entry) {
              document.getElementById('entryNameInput').value = entry.comment || '';
              document.getElementById('entryKeysInput').value = (entry.key || []).join(', ');
              document.getElementById('entryContentInput').value = entry.content || '';
              document.getElementById('entryOrderInput').value = entry.order || 100;
              document.getElementById('entryProbabilityInput').value = entry.probability || 100;
            }
          } else {
            title.textContent = '新建条目';
          }
          showModal(modal);
        }

        async function saveWorldBookEntry() {
          if (currentEditingWorldBookId === null) return;

          const wbIndex = allWorldBooks.findIndex(w => w.id === currentEditingWorldBookId);
          if (wbIndex === -1) return;

          const name = document.getElementById('entryNameInput').value.trim();
          if (!name) {
            alert('条目名称不能为空！');
            return;
          }

          const keys = document
            .getElementById('entryKeysInput')
            .value.split(',')
            .map(k => k.trim())
            .filter(Boolean);

          const entryData = {
            comment: name,
            key: keys,
            content: document.getElementById('entryContentInput').value,
            order: parseInt(document.getElementById('entryOrderInput').value, 10) || 100,
            probability: parseInt(document.getElementById('entryProbabilityInput').value, 10) || 100,
            // 保留你提供的JSON中的一些默认值，但隐藏它们不让用户编辑
            constant: false,
            vectorized: false,
            selective: true,
            selectiveLogic: 0,
            addMemo: true,
            position: 0,
            disable: false,
            excludeRecursion: false,
            preventRecursion: false,
            delayUntilRecursion: false,
            useProbability: true,
            depth: 4,
          };

          if (currentEditingEntryUid !== null) {
            // 编辑现有条目
            entryData.uid = currentEditingEntryUid;
            allWorldBooks[wbIndex].entries[currentEditingEntryUid] = entryData;
          } else {
            // 新建条目
            const newUid = Date.now();
            entryData.uid = newUid;
            if (!allWorldBooks[wbIndex].entries) {
              allWorldBooks[wbIndex].entries = {};
            }
            allWorldBooks[wbIndex].entries[newUid] = entryData;
          }

          await saveWorldBooks();
          renderWorldBookDetail(currentEditingWorldBookId);
          hideModal(document.getElementById('editWorldBookEntryModal'));
        }

        async function deleteWorldBookEntry(worldBookId, entryUid) {
          if (confirm('确定要删除这个条目吗？')) {
            const wbIndex = allWorldBooks.findIndex(w => w.id === worldBookId);
            if (wbIndex !== -1 && allWorldBooks[wbIndex].entries?.[entryUid]) {
              delete allWorldBooks[wbIndex].entries[entryUid];
              await saveWorldBooks();
              renderWorldBookDetail(worldBookId);
            }
          }
        }
        // =================================================================
        // ================== 关联世界书核心逻辑 (全新) ==================
        // =================================================================

        function openAssociateWorldBookModal() {
          if (!currentChatId || !allWorldBooks) return;

          const selectionList = document.getElementById('worldbook-selection-list');
          selectionList.innerHTML = ''; // 清空旧列表

          const charSettings = chatData[currentChatId].charSettings;
          // 确保 worldBook 是一个数组，以兼容旧数据
          const associatedIds = Array.isArray(charSettings.worldBook) ? charSettings.worldBook : [];

          if (allWorldBooks.length === 0) {
            selectionList.innerHTML = `<li style="text-align:center; padding: 20px; color: var(--text-secondary-color);">没有可用的世界书。</li>`;
          } else {
            allWorldBooks.forEach(wb => {
              const isChecked = associatedIds.includes(wb.id);
              const li = document.createElement('li');
              li.innerHTML = `
                <label class="worldbook-selection-item">
                    <input type="checkbox" data-worldbook-id="${wb.id}" ${isChecked ? 'checked' : ''}>
                    <span class="item-name">${wb.name}</span>
                </label>
            `;
              selectionList.appendChild(li);
            });
          }
          showModal(document.getElementById('associateWorldBookModal'));
        }

        async function saveWorldBookAssociation() {
          if (!currentChatId) return;

          const selectedIds = [];
          document.querySelectorAll('#worldbook-selection-list input[type="checkbox"]:checked').forEach(checkbox => {
            selectedIds.push(parseInt(checkbox.dataset.worldbookId, 10));
          });

          chatData[currentChatId].charSettings.worldBook = selectedIds;
          await saveChatData();

          // 更新角色设置面板的显示
          updateWorldBookDisplay(selectedIds);

          hideModal(document.getElementById('associateWorldBookModal'));
          alert('关联成功！');
        }

        // 更新角色设置面板中“关联世界书”区域的显示
        function updateWorldBookDisplay(worldBookIds) {
          const displayArea = document.getElementById('charWorldBookDisplay');
          if (!displayArea) return;

          displayArea.innerHTML = ''; // 清空

          if (!worldBookIds || worldBookIds.length === 0) {
            displayArea.innerHTML = `<span style="color: var(--text-secondary-color); font-style: italic;">点击选择...</span>`;
            return;
          }

          const associatedNames = worldBookIds.map(id => {
            const wb = allWorldBooks.find(w => w.id === id);
            return wb ? wb.name : '未知世界书';
          });

          // 将世界书名字以标签的形式显示出来
          associatedNames.forEach(name => {
            const tag = document.createElement('span');
            tag.className = 'keyword-tag'; // 复用已有的关键词标签样式
            tag.style.marginBottom = '5px'; // 增加一点间距
            tag.textContent = name;
            displayArea.appendChild(tag);
          });
        }

        // --- 事件监听设置 (辅助函数) ---
        function setupWorldBookEventListeners() {
          const worldBookListPage = document.getElementById('worldbook-list-page');
          const worldBookDetailPage = document.getElementById('worldbook-detail-page');

          // 打开世界书APP
          document.getElementById('worldBookAppBtn').addEventListener('click', e => {
            e.preventDefault();
            phoneScreen.style.display = 'none';
            renderWorldBookList();
            worldBookListPage.classList.add('active');
          });

          // 从列表页返回主屏幕
          document.getElementById('worldbook-list-back-btn').addEventListener('click', () => {
            worldBookListPage.classList.remove('active');
            phoneScreen.style.display = 'flex';
          });

          // 从详情页返回列表页
          document.getElementById('worldbook-detail-back-btn').addEventListener('click', () => {
            worldBookDetailPage.classList.remove('active');
          });

          // 新建世界书
          document.getElementById('addNewWorldBookBtn').addEventListener('click', async () => {
            const name = prompt('请输入新的世界书名称：');
            if (name && name.trim()) {
              if (allWorldBooks.some(wb => wb.name === name.trim())) {
                alert('已存在同名世界书！');
                return;
              }
              const newWorldBook = { name: name.trim(), entries: {} };
              const newId = await db.worldBooks.add(newWorldBook);
              newWorldBook.id = newId;
              allWorldBooks.push(newWorldBook);
              renderWorldBookList();
            }
          });

          // 点击世界书列表中的一项，进入详情
          // ▼▼▼ 用下面的代码块替换掉原来的 'worldbook-list-container' 事件监听器 ▼▼▼
          // 对世界书列表容器使用事件委托
          document.getElementById('worldbook-list-container').addEventListener('click', async e => {
            const deleteBtn = e.target.closest('.delete-worldbook-btn');
            const contentWrapper = e.target.closest('.worldbook-content-wrapper');

            if (deleteBtn) {
              // --- 如果点击的是删除按钮 ---
              e.stopPropagation(); // 阻止事件冒泡到父元素
              const worldBookIdToDelete = parseInt(deleteBtn.dataset.worldbookId, 10);
              const wbToDelete = allWorldBooks.find(wb => wb.id === worldBookIdToDelete);

              if (!wbToDelete) return;

              if (
                confirm(
                  `确定要删除世界书 “${wbToDelete.name}” 吗？\n\n此操作不可恢复，且会自动解除所有角色与该世界书的关联！`,
                )
              ) {
                try {
                  // 1. 从数据库删除
                  await db.worldBooks.delete(worldBookIdToDelete);

                  // 2. 从内存中删除
                  allWorldBooks = allWorldBooks.filter(wb => wb.id !== worldBookIdToDelete);

                  // 3. 遍历所有角色，解除关联
                  for (const charId in chatData) {
                    const charSettings = chatData[charId].charSettings;
                    if (charSettings && Array.isArray(charSettings.worldBook)) {
                      charSettings.worldBook = charSettings.worldBook.filter(id => id !== worldBookIdToDelete);
                    }
                  }
                  await saveChatData(); // 保存对角色数据的修改

                  // 4. 重新渲染列表
                  renderWorldBookList();

                  alert(`世界书 “${wbToDelete.name}” 已删除。`);
                } catch (error) {
                  console.error(`删除世界书 #${worldBookIdToDelete} 出错:`, error);
                  alert('删除失败，请查看控制台。');
                }
              }
            } else if (contentWrapper) {
              // --- 如果点击的是内容区域 ---
              currentEditingWorldBookId = parseInt(contentWrapper.dataset.worldbookId, 10);
              renderWorldBookDetail(currentEditingWorldBookId);
              worldBookDetailPage.classList.add('active');
            }
          });
          // ▲▲▲ 替换完成 ▲▲▲

          // 在详情页点击“新建条目”
          document.getElementById('addNewEntryBtn').addEventListener('click', () => {
            openWorldBookEntryModal(currentEditingWorldBookId, null);
          });

          // 详情页条目列表的事件委托（编辑和删除）
          document.getElementById('worldbook-entry-list-container').addEventListener('click', e => {
            const editBtn = e.target.closest('.edit-entry-btn');
            const deleteBtn = e.target.closest('.delete-entry-btn');
            if (editBtn) {
              const entryUid = parseInt(editBtn.dataset.entryUid, 10);
              openWorldBookEntryModal(currentEditingWorldBookId, entryUid);
            }
            if (deleteBtn) {
              const entryUid = parseInt(deleteBtn.dataset.entryUid, 10);
              deleteWorldBookEntry(currentEditingWorldBookId, entryUid);
            }
          });

          // 编辑/新建条目弹窗的按钮
          document.getElementById('saveWorldBookEntryBtn').addEventListener('click', saveWorldBookEntry);
          document.getElementById('cancelWorldBookEntryBtn').addEventListener('click', () => {
            hideModal(document.getElementById('editWorldBookEntryModal'));
          });
        }
        // =================================================================
        // ▼▼▼ 使用这个修正版的函数替换旧的 getTavernCardFromPng ▼▼▼
        // =================================================================
        async function getTavernCardFromPng(file) {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = async () => {
              try {
                const pngBuffer = new Uint8Array(reader.result);
                const textDecoder = new TextDecoder('utf-8');
                let offset = 8; // Skip PNG header

                while (offset < pngBuffer.length) {
                  // DataView is safer for reading multi-byte numbers
                  const dataView = new DataView(pngBuffer.buffer, offset);
                  const length = dataView.getUint32(0, false); // false for big-endian
                  const type = textDecoder.decode(pngBuffer.slice(offset + 4, offset + 8));

                  if (type === 'tEXt') {
                    const keywordAndData = pngBuffer.slice(offset + 8, offset + 8 + length);
                    const nullSeparatorIndex = keywordAndData.indexOf(0);
                    const keyword = textDecoder.decode(keywordAndData.slice(0, nullSeparatorIndex));

                    if (keyword === 'chara') {
                      // 1. Get the Base64 string from the PNG chunk
                      const base64Data = textDecoder.decode(keywordAndData.slice(nullSeparatorIndex + 1));

                      // 2.【核心修正】使用 TextDecoder 来正确处理 UTF-8 编码
                      // First, decode base64 string to a binary string
                      const binaryString = atob(base64Data);
                      // Then, convert binary string to a Uint8Array
                      const bytes = new Uint8Array(binaryString.length);
                      for (let i = 0; i < binaryString.length; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                      }
                      // Finally, decode the Uint8Array as UTF-8
                      const utf8DecodedString = new TextDecoder('utf-8').decode(bytes);

                      // 3. Parse the correctly decoded JSON string
                      const json = JSON.parse(utf8DecodedString);
                      resolve(json);
                      return;
                    }
                  }
                  offset += 12 + length; // Move to the next chunk
                }
                reject(new Error('在PNG中未找到角色卡数据 (tEXt:chara)'));
              } catch (error) {
                console.error('解析PNG角色卡时出错:', error);
                reject(error);
              }
            };
            reader.onerror = reject;
            reader.readAsArrayBuffer(file);
          });
        }

        // 2. 将解析出的角色卡数据转换为我们的内部格式
        async function processImportedCard(cardData, avatarBase64) {
          if (!cardData || !cardData.data || !cardData.data.name) {
            throw new Error('无效的角色卡格式，缺少核心数据。');
          }

          const char = cardData.data;

          // A. 处理世界书
          let worldBookId = null;
          if (
            char.character_book &&
            char.character_book.name &&
            char.character_book.entries &&
            char.character_book.entries.length > 0
          ) {
            const wbName = `[导入] ${char.character_book.name}`;

            // 检查是否已存在同名世界书
            let existingWb = allWorldBooks.find(wb => wb.name === wbName);

            if (existingWb) {
              worldBookId = existingWb.id;
              alert(`检测到已存在的同名世界书 "${wbName}"，将直接关联。`);
            } else {
              const newWorldBook = {
                name: wbName,
                entries: {},
              };
              char.character_book.entries.forEach((entry, index) => {
                const newUid = Date.now() + index;
                newWorldBook.entries[newUid] = {
                  uid: newUid,
                  key: entry.keys || [],
                  comment: entry.comment || `条目 ${index + 1}`,
                  content: entry.content || '',
                  order: entry.insertion_order || 100,
                  probability: entry.extensions?.probability || 100,
                  // 保留一些默认值
                  constant: entry.constant || false,
                  selective: entry.selective || true,
                  useProbability: entry.extensions?.useProbability || true,
                };
              });

              // 保存新的世界书到数据库并获取ID
              const newId = await db.worldBooks.add(newWorldBook);
              newWorldBook.id = newId;
              allWorldBooks.push(newWorldBook); // 更新内存中的世界书列表
              worldBookId = newId;
              alert(`成功导入并创建了新的世界书 "${wbName}"。`);
            }
          }

          // B. 创建新角色
          const newCharId = `char${Date.now()}`;
          chatData[newCharId] = {
            charSettings: {
              avatar: avatarBase64 || 'https://i.postimg.cc/h4yRTMGF/ed60bc4602ebd5cbc0d8961d6c4b4aac.jpg', // 使用 PNG 本身的图像或默认图
              realName: char.name, // 本名使用卡名
              nickname: char.name, // 备注也使用卡名
              gender: 'other', // 卡片中没有性别字段，设为默认
              persona: `${char.description || ''}\n\n${char.personality || ''}`.trim(), // 合并描述和性格
              maxMemory: 50, // 默认值
              group: '', // 默认未分组
              worldBook: worldBookId ? [worldBookId] : [], // 关联刚才创建或找到的世界书ID
              npcs: [],
              exclusiveStickers: [],
            },
            userSettings: {
              // 沿用一个默认的用户设置
              name: '我',
              gender: 'male',
              persona: '我是一个默认用户人设。',
              avatar:
                (await db.userSettings.get('profileAvatar')?.value) ||
                'https://i.postimg.cc/ryn2xgwZ/5fc5b9ae74465344658ed8c7e508b8f5.jpg',
            },
            // ▼▼▼ 核心修改：将 history 设置为空数组 ▼▼▼
            history: [], // 不导入开场白，聊天历史从空白开始
          };

          // C. 保存数据并更新UI
          await saveChatData();
          renderContactsList(); // 重新渲染通讯录
          hideModal(document.getElementById('addCharModal')); // 关闭弹窗
          alert(`角色 "${char.name}" 导入成功！`);
        }

        // 3. 核心的导入流程触发函数
        async function importCharacterCard(file) {
          if (!file) return;

          try {
            let cardJson;
            let avatarBase64 = null;

            if (file.type === 'image/png') {
              // 如果是PNG，先解析元数据
              cardJson = await getTavernCardFromPng(file);
              // 同时将PNG文件本身转换为Base64作为头像
              avatarBase64 = await fileToBase64(file);
            } else if (file.type === 'application/json') {
              // 如果是JSON，直接读取内容
              cardJson = await new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => resolve(JSON.parse(e.target.result));
                reader.onerror = reject;
                reader.readAsText(file);
              });
            } else {
              alert('不支持的文件类型。请选择 .png 或 .json 文件。');
              return;
            }

            // 处理解析出的数据
            await processImportedCard(cardJson, avatarBase64);
          } catch (error) {
            console.error('导入角色卡失败:', error);
            alert(`导入失败：${error.message}`);
          }
        }
        // ▼▼▼ 把下面这一大块全新的函数，粘贴到 JS 合适的位置 ▼▼▼

        // =================================================================
        // ================== 视频通话核心逻辑 (全新) ==================
        // =================================================================

        function startVideoCall() {
          if (!currentChatId || !chatData[currentChatId]) return;

          // 1. 初始化当前通话记录数组
          currentCallTranscript = [];

          const { charSettings, userSettings } = chatData[currentChatId];
          const largeView = document.getElementById('video-call-large-view');
          const smallView = document.getElementById('video-call-small-view');
          const dialogueOverlay = document.getElementById('video-call-dialogue-overlay');
          const charInfo = document.getElementById('video-call-char-info');
          const timerElement = document.getElementById('video-call-timer');

          const charImage = charSettings.videoCallImage || '';
          const userImage = userSettings.videoCallImage || '';

          isSmallViewUser = true;
          dialogueOverlay.innerHTML = '';

          largeView.style.backgroundImage = charImage ? `url(${charImage})` : 'none';

          // ▼▼▼ 核心修改：检查用户是否有图，决定是否显示小窗 ▼▼▼
          if (userImage) {
            smallView.style.backgroundImage = `url(${userImage})`;
            smallView.style.display = 'block'; // 显示小窗
          } else {
            smallView.style.display = 'none'; // 隐藏小窗
          }
          // ▲▲▲ 修改结束 ▲▲▲

          if (!charImage) {
            charInfo.style.display = 'flex';
            charInfo.querySelector('img').src = charSettings.avatar;
            document.getElementById('video-call-char-name').textContent = charSettings.nickname;
          } else {
            charInfo.style.display = 'none';
          }

          if (callTimerInterval) clearInterval(callTimerInterval);
          callStartTime = Date.now();
          timerElement.textContent = '00:00';
          callTimerInterval = setInterval(() => {
            const elapsedSeconds = (Date.now() - callStartTime) / 1000;
            timerElement.textContent = formatCallTime(elapsedSeconds);
          }, 1000);

          videoCallScreen.style.display = 'flex';
          setTimeout(() => {
            videoCallScreen.style.opacity = 1;
            isVideoCallActive = true;
            // 欢迎语也记录下来
            addVideoDialogueLine('system', '通话已连接...');
          }, 10);
        }
        // ▼▼▼ 找到并用这个版本替换旧的 showIncomingCallUI 函数 ▼▼▼
        function showIncomingCallUI(charId) {
          if (!charId || !chatData[charId]) return;

          const charName = chatData[charId].charSettings.nickname;
          const charAvatar = chatData[charId].charSettings.avatar;

          // 填充弹窗内容
          document.getElementById('waiting-char-avatar').src = charAvatar;
          document.getElementById('waiting-char-name').textContent = charName;
          document.getElementById('video-call-invite-text').textContent = '向你发起视频通话...';

          // 【核心修正】确保正确显示/隐藏按钮组
          document.getElementById('incoming-call-buttons').style.display = 'flex';
          document.getElementById('outgoing-call-button').style.display = 'none';

          showModal(videoCallInviteModal);
        }

        async function endVideoCall() {
          // <-- 函数变为 async
          if (callTimerInterval) {
            clearInterval(callTimerInterval);
            callTimerInterval = null;
          }
          const elapsedSeconds = (Date.now() - callStartTime) / 1000;

          // ▼▼▼ 核心逻辑：保存记录并发送卡片 ▼▼▼
          // 检查是否有实质性通话内容（至少有一条非系统消息）
          if (currentCallTranscript.length > 1) {
            const newLog = {
              id: Date.now(),
              startTime: callStartTime,
              duration: elapsedSeconds,
              transcript: [...currentCallTranscript], // 复制一份副本
            };

            // 确保角色数据中有 videoCallLogs 数组
            if (!chatData[currentChatId].videoCallLogs) {
              chatData[currentChatId].videoCallLogs = [];
            }
            chatData[currentChatId].videoCallLogs.push(newLog);

            // 创建卡片消息
            const callCardMessage = {
              role: 'system', // 使用系统角色，这样不会被计入AI的记忆
              content: `[视频通话] 时长: ${formatCallTime(elapsedSeconds)}`,
              callLogId: newLog.id, // 附加一个ID，方便以后点击查找
            };
            chatData[currentChatId].history.push(callCardMessage);

            // 保存所有更改
            await saveChatData();
            // 刷新聊天界面以显示卡片
            renderChatMessages(currentChatId);
          }
          // ▲▲▲ 核心逻辑结束 ▲▲▲

          videoCallScreen.style.opacity = 0;
          setTimeout(() => {
            videoCallScreen.style.display = 'none';
            isVideoCallActive = false;
            currentCallTranscript = []; // 清空临时记录
          }, 300);
        }

        function switchVideoViews() {
          if (!isVideoCallActive) return;

          const { charSettings, userSettings } = chatData[currentChatId];
          const largeView = document.getElementById('video-call-large-view');
          const smallView = document.getElementById('video-call-small-view');
          const charInfo = document.getElementById('video-call-char-info');

          const charImage = charSettings.videoCallImage || '';
          const userImage = userSettings.videoCallImage || '';

          isSmallViewUser = !isSmallViewUser;

          if (isSmallViewUser) {
            // 小窗是用户，大窗是角色
            largeView.style.backgroundImage = charImage ? `url(${charImage})` : 'none';
            // ▼▼▼ 核心修改 ▼▼▼
            if (userImage) {
              smallView.style.backgroundImage = `url(${userImage})`;
              smallView.style.display = 'block';
            } else {
              smallView.style.display = 'none';
            }
            // ▲▲▲ 修改结束 ▲▲▲
            if (!charImage) {
              charInfo.style.display = 'flex';
            } else {
              charInfo.style.display = 'none';
            }
          } else {
            // 小窗是角色，大窗是用户
            largeView.style.backgroundImage = userImage ? `url(${userImage})` : 'none';
            // ▼▼▼ 核心修改 ▼▼▼
            if (charImage) {
              smallView.style.backgroundImage = `url(${charImage})`;
              smallView.style.display = 'block';
            } else {
              smallView.style.display = 'none';
            }
            // ▲▲▲ 修改结束 ▲▲▲
            charInfo.style.display = 'none';
          }
        }

        function addVideoDialogueLine(speaker, text) {
          // ▼▼▼ 核心修改：将对话存入临时记录数组 ▼▼▼
          currentCallTranscript.push({ speaker, text });
          // ▲▲▲ 修改结束 ▲▲▲

          const dialogueOverlay = document.getElementById('video-call-dialogue-overlay');
          const line = document.createElement('p');
          line.className = `video-dialogue-line ${speaker}`;

          dialogueOverlay.appendChild(line);

          if (speaker === 'char') {
            typewriterEffect(line, text);
          } else {
            line.textContent = text;
          }

          dialogueOverlay.scrollTop = dialogueOverlay.scrollHeight;
        }

        // 视频通话专用的AI回复函数
        async function triggerVideoCallAiResponse(userInput = null) {
          if (!currentChatId || !isVideoCallActive) return;

          // --- 1. 数据和API设置准备 (与主聊天类似) ---
          const apiSettings = JSON.parse(localStorage.getItem('apiPresets'));
          const selectedPresetName = localStorage.getItem('selectedApiPreset');
          const currentApi = apiSettings ? Object.values(apiSettings)[0] : null; // 简单示例
          if (!currentApi?.url || !currentApi?.key || !currentApi?.model) {
            addVideoDialogueLine('system', '错误：API未配置');
            return;
          }

          const { charSettings, userSettings, history } = chatData[currentChatId];

          // --- 2. 如果有用户输入，先加到历史记录里 ---
          if (userInput) {
            history.push({ role: 'user', content: userInput });
          }

          // --- 3. 构建视频通话专用的系统指令 (System Prompt) ---
          const systemPrompt = `
[指令]
你正在与用户进行视频通话。你的所有回复都必须像在真实视频通话中一样，包含动作、神态和对话。
你的回复必须是一个符合JSON格式的对象，且只包含一个对象。
这个JSON对象必须包含两个字段: 'action' (字符串) 和 'content' (字符串)。

- 'action': 描述你说话前的动作、表情或神态，使用括号包裹，例如 "(歪了歪头)" 或 "(微笑着点点头)"。
- 'content': 你要说的对话内容。

示例回复:
{
  "action": "(眼睛一亮)",
  "content": "哦？真的吗？快跟我说说看！"
}

[角色人设]
${charSettings.persona}

[用户人设]
- 名字: ${userSettings.name}
- 和你的关系: ${userSettings.relationToChar || '朋友'}
`.trim();

          // --- 4. 准备API请求体 ---
          const memorySlice = history.slice(-charSettings.maxMemory || -50);
          const messagesForApi = [{ role: 'system', content: systemPrompt }, ...memorySlice];
          const requestBody = {
            model: currentApi.model,
            messages: messagesForApi,
            response_format: { type: 'json_object' }, // 强制JSON输出
          };

          // --- 5. 发送请求并处理回复 ---
          try {
            const response = await fetch(currentApi.url + '/chat/completions', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json', Authorization: `Bearer ${currentApi.key}` },
              body: JSON.stringify(requestBody),
            });

            if (!response.ok) throw new Error(`HTTP error! ${response.status}`);

            const data = await response.json();
            const rawContent = data.choices[0].message.content;

            // 解析AI返回的JSON
            const parsedResponse = JSON.parse(rawContent);
            const { action, content } = parsedResponse;

            // 组合成最终要显示的文本
            const fullReply = `${action || ''} ${content || ''}`.trim();

            // 将AI的回复也加入历史记录
            history.push({ role: 'assistant', content: fullReply });
            await saveChatData();

            // 在UI上显示回复
            addVideoDialogueLine('char', fullReply);
          } catch (error) {
            console.error('Video call API failed:', error);
            addVideoDialogueLine('system', `[AI出错了: ${error.message}]`);
            // 如果出错，把刚才的用户输入从历史记录里移除，方便重试
            if (userInput) history.pop();
          }
        }

        /**
         * 打字机效果函数
         * @param {HTMLElement} element - 要显示文字的DOM元素
         * @param {string} text - 要显示的完整文本
         * @param {number} speed - 打字速度（毫秒/字）
         */
        function typewriterEffect(element, text, speed = 50) {
          let i = 0;
          element.textContent = ''; // 先清空
          const typing = setInterval(() => {
            if (i < text.length) {
              element.textContent += text.charAt(i);
              i++;
              // 自动滚动到底部
              const dialogueOverlay = document.getElementById('video-call-dialogue-overlay');
              dialogueOverlay.scrollTop = dialogueOverlay.scrollHeight;
            } else {
              clearInterval(typing);
            }
          }, speed);
        }
        // ▼▼▼ 在这里粘贴新的函数 ▼▼▼
        /**
         * 根据转账详情动态生成HTML卡片
         * @param {object} details - 转账详情对象
         * @param {string} messageRole - 消息的角色 ('user' 或 'assistant')
         * @returns {string} - 生成的HTML字符串
         */
        function generateTransferCardHTML(details, messageRole) {
          const isUserSender = messageRole === 'user';
          const statusInfo = {
            pending: { text: '等待对方收款', icon: '💰' },
            accepted: { text: '已收款', icon: '✅' },
            refused: { text: '已退还', icon: '↩️' },
          };

          const currentStatus = statusInfo[details.status];
          // 卡片的CSS class会根据状态改变，比如 'transfer-card accepted'
          const cardClass = details.status;

          // ▼▼▼ 用这个新版本替换旧的 actionsHTML 逻辑 ▼▼▼
          let actionsHTML = '';
          if (details.status === 'pending') {
            if (isUserSender) {
              // User发给Char，Char可以选择 (AI自动处理)
              // 这里不需要按钮，因为AI会通过 transfer_response 类型来回应
            } else {
              // Char发给User，User可以选择
              actionsHTML = `
                <div class="transfer-card-actions">
                    <button class="transfer-action-btn user-accept">接收</button>
                    <button class="transfer-action-btn user-refuse">退还</button>
                </div>
              `;
            }
          }
          // ▲▲▲ 替换结束 ▲▲▲

          return `
                <div class="transfer-card ${cardClass}" data-transfer-id="${details.id}">
                    <div class="transfer-card-header">
                        <span class="transfer-icon">${currentStatus.icon}</span>
                        <p>${
                          isUserSender ? `转账给 ${details.recipientName}` : `收到来自 ${details.senderName} 的转账`
                        }</p>
                    </div>
                    <div class="transfer-card-body">
                        <p class="transfer-amount">¥${details.amount.toFixed(2)}</p>
                        <p class="transfer-remark">${details.remark}</p>
                    </div>
                    <div class="transfer-card-footer">
                        <p class="transfer-status">${currentStatus.text}</p>
                    </div>
                    ${actionsHTML}
                </div>
            `;
        }
        // =================================================================
        // ================== 视频通话记录查看逻辑 (全新) ==================
        // =================================================================

        // 打开通话记录列表弹窗
        function showCallHistory(charId) {
          const historyData = chatData[charId]?.videoCallLogs || [];
          const listContainer = document.getElementById('call-history-list');

          if (historyData.length === 0) {
            listContainer.innerHTML =
              '<p style="text-align: center; color: var(--text-secondary-color);">暂无通话记录</p>';
          } else {
            // 从新到旧排序
            listContainer.innerHTML = [...historyData]
              .reverse()
              .map(log => {
                const callDate = new Date(log.startTime).toLocaleString('zh-CN', {
                  month: 'short',
                  day: 'numeric',
                  hour: '2-digit',
                  minute: '2-digit',
                });
                return `
                <div class="history-item" onclick="showCallTranscript('${charId}', ${log.id})">
                    <p class="history-item-time">${callDate}</p>
                    <p class="history-item-duration">通话时长: ${formatCallTime(log.duration)}</p>
                </div>
            `;
              })
              .join('');
          }
          showModal(document.getElementById('videoCallHistoryModal'));
        }

        // 打开单次通话详情弹窗
        window.showCallTranscript = function (charId, logId) {
          const log = chatData[charId]?.videoCallLogs?.find(l => l.id === logId);
          if (!log) {
            alert('找不到该通话记录！');
            return;
          }

          const titleEl = document.getElementById('transcript-modal-title');
          const contentEl = document.getElementById('transcript-modal-content');

          const callDate = new Date(log.startTime).toLocaleString();
          titleEl.textContent = `通话于 ${callDate}`;

          contentEl.innerHTML = log.transcript
            .map(line => {
              const speakerName =
                line.speaker === 'user'
                  ? chatData[charId].userSettings.name || '我'
                  : line.speaker === 'char'
                  ? chatData[charId].charSettings.nickname || '对方'
                  : '系统';
              return `<div class="transcript-line"><strong>[${speakerName}]:</strong> ${line.text}</div>`;
            })
            .join('');

          showModal(document.getElementById('callTranscriptModal'));
        };
        // ▼▼▼ 把这个全新的函数粘贴到你的 JS 代码中 ▼▼▼
        /**
         * 一个通用的、非流式的 AI 调用函数
         * @param {string} prompt - 发送给 AI 的提示词
         * @param {boolean} expectJson - 是否期望 AI 返回 JSON 格式的字符串
         * @returns {Promise<string|null>} - AI 的回复文本，如果失败则返回 null
         */
        async function getAiSingleResponse(prompt, expectJson = false) {
          // 直接从全局变量获取当前生效的API配置
          if (!currentApiConfig || !currentApiConfig.url || !currentApiConfig.key || !currentApiConfig.model) {
            alert('AI 功能需要配置 API！请前往“API设置”页面配置。');
            return null;
          }
          // 2. 构建请求体 (非流式)
          const requestBody = {
            model: currentApi.model,
            messages: [{ role: 'user', content: prompt }],
            stream: false, //  关键：关闭流式输出
          };

          if (expectJson) {
            requestBody.response_format = { type: 'json_object' };
          }

          try {
            // 3. 发送请求
            const response = await fetch(currentApiConfig.url + '/chat/completions', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                Authorization: `Bearer ${currentApiConfig.key}`,
              },
              body: JSON.stringify(requestBody),
            });

            if (!response.ok) {
              const errorText = await response.text();
              throw new Error(`API 请求失败: ${response.status} ${errorText}`);
            }

            // 4. 解析并返回结果
            const data = await response.json();
            return data.choices[0].message.content;
          } catch (error) {
            console.error('getAiSingleResponse 失败:', error);
            alert(`调用 AI 失败: ${error.message}`);
            return null;
          }
        }
        // ▲▲▲ 新函数结束 ▲▲▲
        // ▼▼▼ 在 getAiSingleResponse 函数下面，粘贴这个新函数 ▼▼▼
        /**
         * 统一处理余额变动和记录生成的函数
         * @param {string} charId - 角色ID
         * @param {number} amount - 变动金额 (正数为收入, 负数为支出)
         * @param {string} description - 变动原因
         */
        async function addTransaction(charId, amount, description) {
          const wallet = chatData[charId].charSettings.wallet;

          // 1. 更新余额
          wallet.balance += amount;

          // 2. 创建新的交易记录
          const newTransaction = {
            timestamp: Date.now(),
            amount: amount,
            description: description,
          };

          // 3. 将新记录添加到数组开头 (最新记录在最前)
          wallet.transactions.unshift(newTransaction);

          // 可选：为了防止记录无限增长，可以只保留最近的 N 条
          if (wallet.transactions.length > 100) {
            // 例如保留最近100条
            wallet.transactions.pop();
          }

          // 4. 保存数据
          await saveChatData();

          // 5. 更新UI显示
          document.getElementById('charCurrentBalance').value = `¥ ${wallet.balance.toFixed(2)}`;

          console.log(`[交易记录] ${description} | 金额: ${amount.toFixed(2)} | 新余额: ${wallet.balance.toFixed(2)}`);
        }
        // ▲▲▲ 新函数结束 ▲▲▲

        // ▼▼▼ 在你的JS代码中，找到一个合适的位置（比如 addTransaction 函数后面），粘贴下面这个新函数 ▼▼▼
        /**
         * 计算并应用角色昨日的薪资/财务变动
         * @param {string} charId - 角色ID
         */
        async function calculateAndApplyYesterdaySalary(charId) {
          const char = chatData[charId];
          // 如果角色没有设置职业或工作计划，就无法结算，直接退出
          if (!char || !char.charSettings.work?.profession || !char.charSettings.work?.schedule) {
            return;
          }

          const today = new Date();
          const todayStr = today.toISOString().split('T')[0]; // 获取 YYYY-MM-DD 格式的今天日期

          // 如果今天的日期 和 上次结算日期 相同，说明今天已经结算过了，直接退出
          const lastSettlement = char.charSettings.wallet.lastSettlementDate;
          if (lastSettlement === todayStr) {
            return;
          }

          // --- 只有在上次结算日期不是今天时，才会执行下面的逻辑 ---

          const yesterday = new Date();
          yesterday.setDate(today.getDate() - 1);
          const yesterdayWeekDay = yesterday.toLocaleDateString('zh-CN', { weekday: 'long' }); // 获取昨天是星期几

          console.log(
            `%c[财务结算] 触发对 ${char.charSettings.nickname} 的昨日(${yesterdayWeekDay})财务结算...`,
            'color: #30d158; font-weight: bold;',
          );

          const { profession, schedule } = char.charSettings.work;

          // 准备一个Prompt，让AI根据角色信息计算净收入
          const prompt = `
                一个人的职业是“${profession}”，他/她的一周计划如下：
                ---
                ${schedule}
                ---
                昨天是“${yesterdayWeekDay}”。请根据这份计划和职业，分析他/她昨天的主要活动，并估算出净收入（收入减去可能的支出）。
                请严格以一个 JSON 对象的格式返回，该对象包含两个键：
                1. "amount": 一个纯数字，代表净收入（正数表示收入，负数表示消费）。
                2. "description": 一句简短的文字，描述导致这笔收入/支出的具体事件。

                例如: {"amount": 250, "description": "完成了一个设计委托"}
                或: {"amount": -80, "description": "晚上去餐厅吃了顿好的"}
            `;

          // 调用AI，并告诉它我们期望得到一个JSON格式的回复
          const responseJsonText = await getAiSingleResponse(prompt, true);
          if (responseJsonText) {
            try {
              // 解析AI返回的JSON字符串
              const result = JSON.parse(responseJsonText);
              const amount = parseFloat(result.amount);
              const description = result.description || '日常收支';

              if (!isNaN(amount) && amount !== 0) {
                // 调用你已有的 addTransaction 函数来更新余额和添加记录
                await addTransaction(charId, amount, description);

                // 创建一条系统消息，通知用户发生了什么
                const systemMessage = {
                  role: 'system',
                  content: `[系统提示：昨日财务结算] ${description}，余额变动: ¥${amount.toFixed(
                    2,
                  )}。当前余额: ¥${char.charSettings.wallet.balance.toFixed(2)}`,
                  isSystemNotification: true, // 这个标志会让消息样式不同
                };
                char.history.push(systemMessage);

                // 刷新聊天界面以显示这条系统消息
                renderChatMessages(charId);
              }
            } catch (error) {
              console.error('解析AI返回的财务JSON失败:', error, '原始文本:', responseJsonText);
            }
          }

          // 无论成功与否，都将结算日期更新为今天，确保今天不再重复执行
          char.charSettings.wallet.lastSettlementDate = todayStr;
          await saveChatData();
        }
        /**
         * 统一处理【用户】余额变动和记录生成的函数
         * @param {string} charId - 当前对话的ID，用于定位数据
         * @param {number} amount - 变动金额 (正数为收入, 负数为支出)
         * @param {string} description - 变动原因
         */
        async function addUserTransaction(charId, amount, description) {
          const wallet = chatData[charId].userSettings.wallet;

          wallet.balance += amount;

          const newTransaction = {
            timestamp: Date.now(),
            amount: amount,
            description: description,
          };

          wallet.transactions.unshift(newTransaction);

          if (wallet.transactions.length > 100) {
            wallet.transactions.pop();
          }

          await saveChatData();

          // 更新UI上的余额显示
          document.getElementById('userCurrentBalance').value = `¥ ${wallet.balance.toFixed(2)}`;

          console.log(
            `[用户交易记录] ${description} | 金额: ${amount.toFixed(2)} | 新余额: ${wallet.balance.toFixed(2)}`,
          );
        }

        /**
         * 计算并应用【用户】的每日工资
         * @param {string} charId - 当前对话的ID
         */
        async function calculateAndApplyUserSalary(charId) {
          const user = chatData[charId]?.userSettings;
          // 如果用户没有设置日薪，或日薪为0，则不处理
          if (!user || !user.wallet?.dailySalary || user.wallet.dailySalary <= 0) {
            return;
          }

          const today = new Date();
          const todayStr = today.toISOString().split('T')[0];

          const lastSettlement = user.wallet.lastSettlementDate;
          if (lastSettlement === todayStr) {
            return; // 今天已经结算过
          }

          console.log(`%c[用户财务结算] 触发对用户的每日工资结算...`, 'color: #00BFFF; font-weight: bold;');

          const salary = parseFloat(user.wallet.dailySalary);

          if (!isNaN(salary) && salary > 0) {
            // 调用新的 addUserTransaction 函数来更新余额和添加记录
            await addUserTransaction(charId, salary, '每日工资');
          }

          // 无论成功与否，都将结算日期更新为今天
          user.wallet.lastSettlementDate = todayStr;
          await saveChatData();
        }
        // =================================================================
        // ================== 礼物商店核心逻辑 (新) ==================
        // =================================================================

        // 1. 定义礼物列表（可以随时扩展）
        const GIFT_CATALOG = [
          { id: 1, name: '神秘星辰手链', prompt: 'a delicate stardust bracelet with glowing gems', price: 128 },
          { id: 2, name: '永恒玫瑰花束', prompt: 'a beautiful bouquet of enchanted glowing roses', price: 188 },
          { id: 3, name: '幻想之翼项链', prompt: 'a fantasy wing necklace, crystal, elegant', price: 258 },
          { id: 4, name: '手作巧克力礼盒', prompt: 'a box of exquisite handmade chocolates', price: 99 },
          { id: 5, name: '迷你机械宠物', prompt: 'a tiny cute mechanical pet bird, steampunk style', price: 320 },
          { id: 6, name: '治愈香薰蜡烛', prompt: 'a healing scented candle in a beautiful jar', price: 78 },
        ];

        // 2. AI生成礼物的函数
        async function generateGiftsByAI() {
          const button = document.getElementById('ai-generate-gifts-btn');
          button.disabled = true;
          button.textContent = '生成中...';

          const listContainer = document.getElementById('gift-list-container');
          listContainer.innerHTML = `<p style="text-align:center; padding: 40px 20px; color: var(--text-secondary-color);">正在向宇宙许愿，为你生成独特的礼物...</p>`;

          const prompt = `
                你是一位幻想世界的礼物设计师。请为恋人或亲密朋友设计6个独特且充满创意的礼物。
                严格以JSON数组的格式返回，每个对象包含三个键：
                1. "name": 字符串，礼物名称（中文，富有想象力）。
                2. "prompt": 字符串，用于AI绘画的英文关键词，描述礼物的样子。
                3. "price": 数字，礼物的价格（50到500之间）。
                
                不要返回任何其他多余的文字。
            `;
          const responseJsonText = await getAiSingleResponse(prompt, true);
          if (responseJsonText) {
            try {
              const newGifts = JSON.parse(responseJsonText);
              if (Array.isArray(newGifts) && newGifts.length > 0) {
                const newItems = newGifts.map((gift, index) => ({
                  id: Date.now() + index, // 使用时间戳+索引确保ID唯一
                  ...gift,
                  imageUrl: `https://image.pollinations.ai/prompt/${encodeURIComponent(
                    gift.prompt,
                  )}?width=512&amp;height=512&amp;seed=42`,
                }));
                giftShopItems.push(...newItems); // 使用 push 和扩展运算符(...) 追加
                await db.giftShopItems.bulkAdd(newItems);
                renderGiftShop();
              }
            } catch (e) {
              console.error('解析AI礼物JSON失败', e);
              listContainer.innerHTML = `<p style="text-align:center; color: #ff453a;">礼物生成失败，请稍后再试。</p>`;
            }
          }

          button.disabled = false;
          button.textContent = 'AI 生成礼物';
        }
        // 2b. AI 搜索礼物的函数 (全新)
        async function searchGiftsByAI() {
          const query = prompt('你想找什么样的礼物？(例如：一个温暖的围巾)');
          if (!query || !query.trim()) return;

          const button = document.getElementById('ai-search-gifts-btn');
          button.disabled = true;
          button.textContent = '搜索中...';

          const listContainer = document.getElementById('gift-list-container');
          listContainer.innerHTML = `<p style="text-align:center; padding: 40px 20px; color: var(--text-secondary-color);">正在广阔的创意宇宙中为你寻找“${query}”...</p>`;

          const apiPrompt = `
                用户想寻找一个礼物，描述是：“${query}”。
                请根据这个描述，创造3个相关的具体礼物。
                严格以一个 JSON 数组的格式返回，数组中的每个对象都包含三个键：
                1. "name": 字符串，礼物名称（中文，富有想象力）。
                2. "prompt": 字符串，用于AI绘画的英文关键词，详细描述礼物的样子。
                3. "price": 数字，礼物的价格（50到500之间）。

                不要返回任何其他多余的文字或解释。
            `;

          const responseJsonText = await getAiSingleResponse(apiPrompt, true);
          if (responseJsonText) {
            try {
              const newGifts = JSON.parse(responseJsonText); // 接收一个数组
              if (Array.isArray(newGifts) && newGifts.length > 0) {
                const processedNewGifts = newGifts.map((gift, index) => ({
                  id: Date.now() + index, // 确保每个礼物ID都唯一
                  ...gift,
                  imageUrl: `https://image.pollinations.ai/prompt/${encodeURIComponent(
                    gift.prompt,
                  )}?width=512&amp;height=512&amp;seed=42`,
                }));
                // 核心修改：使用 unshift 将新礼物添加到数组最前面
                giftShopItems.unshift(...processedNewGifts);
                await db.giftShopItems.bulkAdd(processedNewGifts);
                renderGiftShop();
              } else {
                throw new Error('返回的不是有效的礼物数组');
              }
            } catch (e) {
              console.error('解析AI搜索结果失败', e);
              listContainer.innerHTML = `<p style="text-align:center; color: #ff453a;">礼物搜索失败，请换个关键词试试。</p>`;
              // 失败后恢复之前的列表
              setTimeout(() => renderGiftShop(), 2000);
            }
          }

          button.disabled = false;
          button.textContent = 'AI 搜索礼物';
        }
        // 3. 渲染礼物商店
        function renderGiftShop() {
          const listContainer = document.getElementById('gift-list-container');
          listContainer.innerHTML = '';
          const grid = document.createElement('div');
          grid.className = 'gift-list';

          giftShopItems.forEach(item => {
            const imageUrl = item.imageUrl;

            const itemEl = document.createElement('div');
            itemEl.className = 'gift-item';
            itemEl.innerHTML = `
                    <div class="gift-item-image" style="background-image: url('${imageUrl}');"></div>
                    <div class="gift-item-info">
                        <span class="gift-item-name">${item.name}</span>
                        <span class="gift-item-price">¥ ${item.price.toFixed(2)}</span>
                        <button class="add-to-cart-btn" data-gift-id="${item.id}">加入购物车</button>
                    </div>
                `;
            grid.appendChild(itemEl);
          });
          listContainer.appendChild(grid);
        }

        // 4. 渲染购物车
        function renderShoppingCart() {
          const listEl = document.getElementById('cart-items-list');
          const countEl = document.getElementById('cart-item-count');
          const totalEl = document.getElementById('cart-total-price');

          countEl.textContent = shoppingCart.length;
          countEl.style.display = shoppingCart.length > 0 ? 'flex' : 'none';

          if (shoppingCart.length === 0) {
            listEl.innerHTML = `<p style="text-align:center; padding: 20px; color: var(--text-secondary-color);">购物车是空的哦</p>`;
          } else {
            listEl.innerHTML = shoppingCart
              .map(
                (item, index) => `
                    <li class="cart-item">
                        <img src="${item.imageUrl}" alt="${item.name}">
                        <div class="cart-item-details">
                            <span class="cart-item-name">${item.name}</span>
                            <span class="cart-item-price">¥ ${item.price.toFixed(2)}</span>
                        </div>
                        <button class="remove-cart-item-btn" data-cart-index="${index}">&times;</button>
                    </li>
                `,
              )
              .join('');
          }
          const total = shoppingCart.reduce((sum, item) => sum + item.price, 0);
          totalEl.textContent = `¥ ${total.toFixed(2)}`;
        }

        // 5. 结算并发送礼物
        async function checkoutAndSendGifts() {
          if (shoppingCart.length === 0) {
            alert('购物车是空的！');
            return;
          }

          const totalCost = shoppingCart.reduce((sum, item) => sum + item.price, 0);
          const userWallet = chatData[currentChatId].userSettings.wallet;

          if (userWallet.balance < totalCost) {
            alert(`余额不足！需要 ¥${totalCost.toFixed(2)}，当前余额 ¥${userWallet.balance.toFixed(2)}`);
            return;
          }

          // 扣款
          await addUserTransaction(
            currentChatId,
            -totalCost,
            `购买礼物送给 ${chatData[currentChatId].charSettings.nickname}`,
          );

          // 创建礼物卡片消息
          // 创建礼物卡片消息
          const giftMessage = {
            role: 'user', // <-- 修改这里！
            content: `[你送出了一份礼物]`,
            type: 'gift', // 新类型
            giftDetails: {
              items: [...shoppingCart],
              totalCost: totalCost,
            },
          };

          chatData[currentChatId].history.push(giftMessage);
          await saveChatData();

          // 更新UI
          renderChatMessages(currentChatId);

          // 清空购物车并关闭页面
          shoppingCart = [];
          hideModal(shoppingCartModal);
          giftShopPage.classList.remove('active');
          phoneScreen.style.display = 'flex'; // 返回主屏幕
        }
        // 在 GIFT_CATALOG 下方添加这个新函数
        async function loadGiftShopItems() {
          const itemsFromDB = await db.giftShopItems.toArray();
          if (itemsFromDB.length > 0) {
            // 如果数据库里有，就直接用数据库里的
            giftShopItems = itemsFromDB;
          } else {
            // 如果数据库是空的（第一次加载），就把默认礼物存进去
            const defaultItems = GIFT_CATALOG.map(item => ({
              ...item,
              imageUrl: `https://image.pollinations.ai/prompt/${encodeURIComponent(
                item.prompt,
              )}?width=512&amp;height=512&amp;seed=42`,
            }));
            await db.giftShopItems.bulkAdd(defaultItems); // 存入数据库
            giftShopItems = defaultItems; // 更新内存中的列表
          }
        }

        // ================== 字体管理逻辑 (核心) ==================
        let currentActiveFontId = null;
        // ▼▼▼ 新增：字体大小管理逻辑 ▼▼▼

        // 定义需要调整大小的元素及其原始大小 (基准值)
        const FONT_SIZE_TARGETS = [
          { selector: '.message-content', base: 16 }, // 聊天气泡
          { selector: '.app-name', base: 11 }, // APP图标名字
          { selector: '.contact-name', base: 16 }, // 通讯录名字
          { selector: '.contact-last-msg', base: 14 }, // 通讯录最后一条消息
          { selector: '.modal-content p', base: 14 }, // 弹窗正文
          { selector: '.settings-item label', base: 14 }, // 设置项标签
          { selector: 'input', base: 14 }, // 输入框
          { selector: 'textarea', base: 14 }, // 文本域
          { selector: 'button', base: 14 }, // 按钮
          { selector: '.status-bar', base: 12 }, // 状态栏
          { selector: '.main-info-bar input', base: 16 }, // 首页搜索框
        ];

        async function applyFontSize(delta) {
          // 1. 更新滑块旁边的数字显示
          const display = document.getElementById('fontSizeValueDisplay');
          if (display) {
            display.textContent = delta > 0 ? `+${delta}px` : `${delta}px`;
          }

          // 2. 移除旧的样式标签
          const styleId = 'dynamic-font-size-style';
          let styleTag = document.getElementById(styleId);
          if (styleTag) styleTag.remove();

          // 3. 如果偏移量为0，则不注入样式（恢复默认）
          if (parseInt(delta) === 0) return;

          // 4. 生成新的 CSS 规则
          // 使用 calc() 计算：原始大小 + 偏移量
          let cssRules = '';
          FONT_SIZE_TARGETS.forEach(item => {
            cssRules += `${item.selector} { font-size: calc(${item.base}px + ${delta}px) !important; }\n`;
          });

          // 5. 注入样式
          styleTag = document.createElement('style');
          styleTag.id = styleId;
          styleTag.textContent = cssRules;
          document.head.appendChild(styleTag);
        }

        async function loadAndApplySavedFontSize() {
          const savedData = await db.userSettings.get('fontSizeDelta');
          const delta = savedData ? parseInt(savedData.value) : 0;

          // 更新滑块位置
          const slider = document.getElementById('fontSizeSlider');
          if (slider) slider.value = delta;

          // 应用大小
          applyFontSize(delta);
        }
        // ▲▲▲ 新增结束 ▲▲▲

        // 1. 加载并应用保存的字体（用于初始化）
        async function loadAndApplySavedFont() {
          const savedFontId = (await db.userSettings.get('activeFontId'))?.value;
          if (savedFontId) {
            const fontData = await db.customFonts.get(savedFontId);
            if (fontData) {
              applyFontToPage(fontData);
              currentActiveFontId = fontData.id;
            }
          }
        }

        // 2. 将字体注入到页面 CSS 中
        function applyFontToPage(fontData) {
          // 移除旧的字体样式标签
          const oldStyle = document.getElementById('dynamic-font-style');
          if (oldStyle) oldStyle.remove();

          if (!fontData) {
            // 恢复默认
            document.documentElement.style.removeProperty('--app-font');
            return;
          }

          const style = document.createElement('style');
          style.id = 'dynamic-font-style';
          style.textContent = `
              @font-face {
                  font-family: '${fontData.name}';
                  src: url('${fontData.url}');
                  font-display: swap;
              }
              :root {
                  --app-font: '${fontData.name}', sans-serif !important;
              }
          `;
          document.head.appendChild(style);
        }

        // 3. 渲染字体列表 (萌化版)
        async function renderFontManagerList() {
          const listContainer = document.getElementById('fontListContainer');
          listContainer.innerHTML = '';

          const fonts = await db.customFonts.toArray();

          if (fonts.length === 0) {
            listContainer.innerHTML = `
                <div style="text-align:center; padding:40px 20px; color:#aaa;">
                   (｡•́︿•̀｡)<br>还没有字体哦<br>快去“批量导入”里粘贴一些吧！
                </div>`;
            return;
          }

          fonts.forEach(font => {
            const isActive = font.id === currentActiveFontId;
            const card = document.createElement('div');
            card.className = `font-card ${isActive ? 'active' : ''}`;

            const previewStyleId = `preview-font-${font.id}`;
            if (!document.getElementById(previewStyleId)) {
              const style = document.createElement('style');
              style.id = previewStyleId;
              style.textContent = `
                      @font-face {
                          font-family: 'Preview_${font.name}';
                          src: url('${font.url}');
                          font-display: swap;
                      }
                  `;
              document.head.appendChild(style);
            }

            card.innerHTML = `
                  <div class="font-name-tag">${font.name}</div>
                  <div class="font-preview-text" style="font-family: 'Preview_${font.name}', sans-serif;">
                      落霞与孤鹜齐飞，秋水共长天一色。<br>1234567890 Cute UI
                  </div>
                  <div class="font-card-footer">
                      ${isActive ? '' : `<button class="mini-btn apply" data-id="${font.id}">应用</button>`}
                      <button class="mini-btn delete" data-id="${font.id}">删除</button>
                  </div>
              `;
            listContainer.appendChild(card);
          });
        }

        // --- 初始化函数 ---
        // ▼▼▼ 核心修改 4: 修改 init 函数，使其能正确加载异步数据 ▼▼▼
        async function init() {
          phoneScreen.style.display = 'flex';
          document.querySelectorAll('.app-page').forEach(page => page.classList.remove('active'));

          await loadChatData();
          await loadGiftShopItems();
          await loadUserProfilePresets();
          await loadCommonStickers();
          await loadUserStickers();
          await loadGroupSettings();
          await loadBubblePresets();
          await loadWorldBooks();
          // ▼▼▼ 加载中间图标和气泡颜色 ▼▼▼
          const savedMiddleIcon = (await db.userSettings.get('middleIconUrl'))?.value;
          if (savedMiddleIcon && document.getElementById('chat-middle-icon')) {
              document.getElementById('chat-middle-icon').src = savedMiddleIcon;
          }
          const savedBubbleSettings = (await db.userSettings.get('simpleBubbleSettings'))?.value;
          if (savedBubbleSettings && window.applyGlobalBubbleColors) {
              window.applyGlobalBubbleColors(savedBubbleSettings);
          }
          // ▲▲▲ 加载结束 ▲▲▲

          renderContactsList();
          await loadAndApplySavedFont(); // ▼▼▼ 新增：加载已保存的字体
          await loadAndApplySavedFontSize(); // ▼▼▼ 新增：加载字体大小

          const updateTime = () =>
            (timeElement.textContent = new Date().toLocaleTimeString('zh-CN', { hour12: false }));
          updateTime();
          setInterval(updateTime, 1000);
          const now = new Date();
          dateElement.textContent = `${now.toLocaleDateString('zh-CN', {
            month: 'long',
            day: 'numeric',
          })} ${now.toLocaleDateString('zh-CN', { weekday: 'long' })}`;

          // 使用 await 等待从 IndexedDB 加载设置
          currentSettings = await loadSettings();
          applySettings(currentSettings);

          const independentItemIds = [
            'profileDot',
            'profileAvatar',
            'imagePlaceholder',
            'mainChatInput',
            'moodInput',
            'thoughtTextarea',
            'magicPromptInput',
            'imageDescriptionInput',
          ];
          // 使用 Dexie 的 bulkGet 方法一次性高效获取所有数据
          const items = await db.userSettings.bulkGet(independentItemIds);

          items.forEach((item, index) => {
            if (item) {
              // 确保数据库中有这个项目
              const elementId = independentItemIds[index];
              const element = document.getElementById(elementId);
              if (element) {
                // 根据ID判断是图片还是文本
                if (['profileDot', 'profileAvatar', 'imagePlaceholder'].includes(elementId)) {
                  updateImageUI(element, item.value);
                } else {
                  element.value = item.value;
                }
              }
            }
          });
          // ▲▲▲ 修改结束 ▲▲▲
          await loadApiPresets();
          const lastSelectedPresetName = localStorage.getItem('selectedApiPreset');
          if (lastSelectedPresetName && apiPresets[lastSelectedPresetName]) {
            currentApiConfig = apiPresets[lastSelectedPresetName];
            // 填充UI，让用户知道当前用的是哪个配置
            const preset = currentApiConfig;
            document.getElementById('apiUrlInput').value = preset.url;
            document.getElementById('apiKeyInput').value = preset.key;
            document.getElementById('presetNameInput').value = preset.name;
            document.getElementById('presetSelect').value = preset.name;
            // 触发一次模型拉取
            document.getElementById('fetchModelsBtn').click();
          }
          setupEventListeners();
        }
        // --- QQ 应用交互逻辑 ---
        const qqAppIcon = document.querySelector('.app-container[data-app-id="app1"]');
        const contactItems = document.querySelectorAll('.contact-item');
        const chatBackButton = document.getElementById('chat-back-btn');
        const contactsBackButton = document.getElementById('contacts-back-btn');
        // 1. 点击QQ图标，打开通讯录页面
        if (qqAppIcon) {
          qqAppIcon.addEventListener('click', e => {
            e.preventDefault();
            phoneScreen.style.display = 'none'; // 使用顶层获取的 phoneScreen
            qqContactsPage.classList.add('active');
          });
        }

        // 2. 点击通讯录中的任意一个联系人，进入聊天页
        contactItems.forEach(item => {
          item.addEventListener('click', () => {
            // 【修改】
            currentChatId = item.dataset.charId; // 设置当前聊天ID
            renderChatPage(currentChatId); // 根据ID渲染聊天页面
            qqChatPage.classList.add('active');
          });
        });
        // 3. 在聊天页点击返回，回到通讯录
        if (chatBackButton) {
          chatBackButton.addEventListener('click', () => {
            qqChatPage.classList.remove('active');
          });
        }

        // 4. 在通讯录页面点击返回，回到主屏幕 (这里的逻辑现在可以正常工作了)
        if (contactsBackButton) {
          contactsBackButton.addEventListener('click', () => {
            qqContactsPage.classList.remove('active'); // 不再报错
            phoneScreen.style.display = 'flex'; // 不再报错
          });
        }

        // 4. (占位功能) 点击右上角菜单
        const qqMenuBtn = document.getElementById('qq-menu-btn');
        if (qqMenuBtn) {
          // ▼▼▼ 替换成下面这个新的 addEventListener ▼▼▼
          qqMenuBtn.addEventListener('click', () => {
            const addCharModal = document.getElementById('addCharModal');
            // 每次打开时，重置表单内容和默认头像
            document.getElementById('newCharAvatarPreview').src =
              'https://i.postimg.cc/h4yRTMGF/ed60bc4602ebd5cbc0d8961d6c4b4aac.jpg';
            document.getElementById('newCharRealName').value = '';
            document.getElementById('newCharNickname').value = '';
            document.getElementById('newCharPersona').value = '';
            showModal(addCharModal);
          });
          // ▲▲▲ 替换完成 ▲▲▲
        }

        // 6. (占位功能) 点击聊天页的发送按钮
        const tempSendBtn = document.getElementById('chat-temp-send-btn');
        const apiSendBtn = document.getElementById('chat-api-send-btn');
        // ▼▼▼ 请找到并用下面的代码块替换你原来的 'chat-temp-send-btn' 的事件监听器 ▼▼▼

        if (tempSendBtn) {
          tempSendBtn.addEventListener('click', async () => {
            // <--- 增加了 async
            const input = document.getElementById('chat-input-box');
            const textContent = input.value.trim();

            if (textContent) {
              // 1. 创建消息对象，并标记为暂存
              const message = {
                role: 'user',
                content: textContent,
                isStaging: true, // 核心标记
              };

              // 2. 添加到历史记录
              chatData[currentChatId].history.push(message);

              // 3. 【【【新增】】】保存到数据库
              await saveChatData();

              // 4. 重新渲染界面
              renderChatMessages(currentChatId);

              // 5. 清空输入框
              input.value = '';
            }
          });
        }

        // 这是一个你应该在调用API之前运行的辅助函数示例
        function prepareMessagesForApi(messages) {
          return messages.map(msg => {
            const newMsg = { ...msg }; // 创建一个副本，避免修改原始history

            // 如果是真实图片消息
            if (newMsg.base64) {
              // 转换成多模态API需要的格式，例如
              newMsg.content = [
                { type: 'text', text: '这是用户发的图片。' },
                { type: 'image_url', image_url: { url: newMsg.base64 } },
              ];
              delete newMsg.base64; // 清理掉临时数据
            }
            // 如果是文字图消息
            else if (newMsg.content.startsWith('[text_image')) {
              const match = newMsg.content.match(/\[text_image description="([^"]+)"]/);
              if (match) {
                // 将其转换为纯文本描述
                newMsg.content = `[用户发送了一张图片，描述为：${match[1]}]`;
              }
            }
            // 如果是表情包消息
            else if (newMsg.content.startsWith('[sticker]')) {
              // 将其转换为纯文本描述
              newMsg.content = `[用户发送了一个表情]`;
            }

            // 删除isStaging，即使它已经被删了，再确认一次
            delete newMsg.isStaging;

            return newMsg;
          });
        }

        // ▼▼▼ 用这个【最终版本】替换 'chat-api-send-btn' 的点击事件监听器 ▼▼▼
        if (apiSendBtn) {
          // 【重要】将事件监听器改为异步函数
          apiSendBtn.addEventListener('click', async () => {
            const input = document.getElementById('chat-input-box');
            const textContent = input.value.trim();
            const history = chatData[currentChatId].history;

            // 1. 查找所有待发送(isStaging)的消息
            const stagedMessages = history.filter(msg => msg.isStaging);

            // 如果输入框没内容，且没有待发送的消息，则不执行任何操作
            if (!textContent && stagedMessages.length === 0) {
              return;
            }

            // 2. 如果输入框有文本，创建一个新的文本消息对象并加入历史记录
            if (textContent) {
              const textMessage = {
                role: 'user',
                content: textContent,
              };
              history.push(textMessage);
              input.value = ''; // 清空输入框
            }

            // 3. 将所有待发送消息的 isStaging 标记移除，变为正式消息
            stagedMessages.forEach(msg => {
              delete msg.isStaging;
            });

            // 【重要】在调用API前，立即保存一次聊天记录并刷新UI
            // 这样用户的消息会立刻显示出来，而不是等AI回复后才显示
            await saveChatData();
            renderChatMessages(currentChatId);

            // 4. 调用我们即将创建的核心函数来处理AI回复
            await triggerAiResponse(currentChatId);
          });
        }
        // 【新增】监听聊天输入框的回车事件，用于暂存
        const chatInput = document.getElementById('chat-input-box');
        if (chatInput) {
          chatInput.addEventListener('keydown', event => {
            // 检查是否按下了 Enter 键，并且没有同时按 Shift 键 (允许换行)
            if (event.key === 'Enter' && !event.shiftKey) {
              // 阻止 Enter 键的默认行为 (例如换行或提交表单)
              event.preventDefault();
              // 模拟点击“暂存”按钮
              document.getElementById('chat-temp-send-btn').click();
            }
          });
        }

        // 在 setupEventListeners() 函数的末尾添加

        // --- QQ聊天设置面板事件 ---
        const charSettingsModal = document.getElementById('charSettingsModal');
        const userSettingsModal = document.getElementById('userSettingsModal');
        // ▼▼▼ 用这个【最终修正版】替换 'chat-char-avatar' 的点击事件监听器 ▼▼▼
        document.getElementById('chat-char-avatar').addEventListener('click', () => {
          if (!currentChatId || !chatData[currentChatId]) return;
          const settings = chatData[currentChatId].charSettings;

          // 1. 填充所有表单数据
          document.getElementById('charSettingsAvatarPreview').src = settings.avatar;
          document.getElementById('charRealName').value = settings.realName;
          document.getElementById('charNickname').value = settings.nickname;
          document.getElementById('charGender').value = settings.gender;
          document.getElementById('charPersona').value = settings.persona;
          document.getElementById('charMaxMemory').value = settings.maxMemory;
          updateWorldBookDisplay(settings.worldBook);
          document.getElementById('charMinReply').value = settings.minReplyMessages || 1;
          document.getElementById('charMaxReply').value = settings.maxReplyMessages || 2;
          document.getElementById('charVideoCallImagePreview').src = settings.videoCallImage || '';

          // ▼▼▼▼▼▼▼▼ 核心修复点：增加默认值保护 ▼▼▼▼▼▼▼▼
          const work = settings.work || { profession: '', schedule: '' };
          // 这里确保 wallet 存在，并且 balance 是数字
          const wallet = settings.wallet || {};
          const currentBalance = Number(wallet.balance) || 0;
          // ▲▲▲▲▲▲▲▲ 修复结束 ▲▲▲▲▲▲▲▲

          document.getElementById('charProfession').value = work.profession || '';
          document.getElementById('charWorkSchedule').value = work.schedule || '';
          document.getElementById('charInitialBalanceRange').value = wallet.initialRange || '';

          // ▼▼▼▼▼▼▼▼ 使用处理过的 currentBalance，确保 toFixed 不会报错 ▼▼▼▼▼▼▼▼
          document.getElementById('charCurrentBalance').value = `¥ ${currentBalance.toFixed(2)}`;
          // ▲▲▲▲▲▲▲▲ 修改结束 ▲▲▲▲▲▲▲▲

          // 填充分组输入框
          const charGroupInput = document.getElementById('charGroup');
          charGroupInput.value = settings.group || '';

          // 2. 动态填充datalist（分组建议列表）
          const datalist = document.getElementById('group-list');
          datalist.innerHTML = '';
          // 使用 Object.keys(groupSettings) 来获取所有已存在的分组名
          Object.keys(groupSettings).forEach(groupName => {
            if (groupName) {
              // 确保不添加空的分组名
              const option = document.createElement('option');
              option.value = groupName;
              datalist.appendChild(option);
            }
          });

          // 3. 显示弹窗
          showModal(charSettingsModal);
        });

        // 点击 User 头像，打开 User 设置
        // 点击 User 头像，打开 User 设置
        document.getElementById('chat-user-avatar').addEventListener('click', () => {
          if (!currentChatId || !chatData[currentChatId]) return;
          const settings = chatData[currentChatId].userSettings;

          // 【新增】填充头像预览
          document.getElementById('userSettingsAvatarPreview').src = settings.avatar;

          document.getElementById('userName').value = settings.name;
          document.getElementById('userRelationToChar').value = settings.relationToChar || '';
          document.getElementById('userGender').value = settings.gender;
          document.getElementById('userPersona').value = settings.persona;
          document.getElementById('userVideoCallImagePreview').src = settings.videoCallImage || '';
          const work = settings.work || { profession: '' };
          const wallet = settings.wallet || { balance: 0, dailySalary: 0, initialBalance: 0 };

          document.getElementById('userProfession').value = work.profession || '';
          document.getElementById('userDailySalary').value = wallet.dailySalary || 0;
          document.getElementById('userInitialBalance').value = wallet.initialBalance || 0;
          document.getElementById('userCurrentBalance').value = `¥ ${wallet.balance.toFixed(2)}`;
          showModal(userSettingsModal);
          renderUserProfilePresets();
        });

        // ▼▼▼ 用这个新版本替换旧的 'saveCharSettingsBtn' 点击事件监听器 ▼▼▼
        document.getElementById('saveCharSettingsBtn').addEventListener('click', () => {
          if (!currentChatId) return;
          const settings = chatData[currentChatId].charSettings;

          settings.avatar = document.getElementById('charSettingsAvatarPreview').src;
          settings.realName = document.getElementById('charRealName').value;
          settings.nickname = document.getElementById('charNickname').value;
          settings.gender = document.getElementById('charGender').value;
          settings.persona = document.getElementById('charPersona').value;
          settings.maxMemory = document.getElementById('charMaxMemory').value;
          settings.minReplyMessages = parseInt(document.getElementById('charMinReply').value, 10) || 1;
          settings.maxReplyMessages = parseInt(document.getElementById('charMaxReply').value, 10) || 2;
          settings.videoCallImage = document.getElementById('charVideoCallImagePreview').src;
          if (!settings.work) settings.work = {};
          if (!settings.wallet) settings.wallet = {};

          settings.work.profession = document.getElementById('charProfession').value.trim();
          settings.work.schedule = document.getElementById('charWorkSchedule').value.trim();
          settings.wallet.initialRange = document.getElementById('charInitialBalanceRange').value.trim();

          const groupName = document.getElementById('charGroup').value.trim();
          settings.group = groupName; // 将分组名赋给当前角色

          // 如果用户输入了一个全新的分组名，则在 groupSettings 中初始化它
          if (groupName && !groupSettings[groupName]) {
            groupSettings[groupName] = { expanded: true, pinned: false };
          }

          // 保存所有数据
          saveChatData();
          saveGroupSettings();

          // 重新渲染UI
          renderChatPage(currentChatId);
          renderContactsList();
          hideModal(charSettingsModal);
        });

        document.getElementById('cancelCharSettingsBtn').addEventListener('click', () => hideModal(charSettingsModal));

        // User 设置面板的按钮事件
        // User 设置面板的按钮事件
        document.getElementById('saveUserSettingsBtn').addEventListener('click', () => {
          if (!currentChatId) return;
          const settings = chatData[currentChatId].userSettings;

          // 【新增】保存新头像的URL
          settings.avatar = document.getElementById('userSettingsAvatarPreview').src;

          settings.name = document.getElementById('userName').value;
          settings.relationToChar = document.getElementById('userRelationToChar').value;
          settings.gender = document.getElementById('userGender').value;
          settings.persona = document.getElementById('userPersona').value;
          settings.videoCallImage = document.getElementById('userVideoCallImagePreview').src;
          if (!settings.work) settings.work = {};
          if (!settings.wallet) settings.wallet = {};

          settings.work.profession = document.getElementById('userProfession').value.trim();
          settings.wallet.dailySalary = parseFloat(document.getElementById('userDailySalary').value) || 0;
          settings.wallet.initialBalance = parseFloat(document.getElementById('userInitialBalance').value) || 0;
          saveChatData(); // 保存
          renderChatPage(currentChatId); // 重新渲染
          hideModal(userSettingsModal);
        });

        document.getElementById('cancelUserSettingsBtn').addEventListener('click', () => hideModal(userSettingsModal));

        // 更换角色头像的特殊处理
        document.getElementById('changeCharAvatarBtn').addEventListener('click', () => {
          // 借用现有的图片上传逻辑
          currentEditingTarget = { type: 'charAvatarInSettings' };
          showModal(imageChoiceModal);
        });
        // 【新增】为“我的信息”里的更换头像按钮添加事件
        document.getElementById('changeUserAvatarBtn').addEventListener('click', () => {
          // 借用现有的图片上传逻辑，定义一个新类型
          currentEditingTarget = { type: 'userAvatarInSettings' };
          showModal(imageChoiceModal);
        });
        // ================== 用户表情包管理与分类事件 (修正版) ==================

        // --- “批量添加”按钮 ---
        document.getElementById('user-sticker-bulk-add-btn').addEventListener('click', () => {
          // 这个逻辑和角色的批量添加完全一样，所以我们直接调用 openAddStickersModal
          // 只需要确保上下文是 'user' 即可
          currentStickerContext = 'user';
          const addStickersModal = document.getElementById('addStickersModal');
          document.getElementById('addStickersTitle').textContent = '添加我的表情';
          document.getElementById('stickerBulkAddArea').value = '';
          showModal(addStickersModal);
        });

        // --- “管理”按钮，进入管理模式 ---
        document.getElementById('manage-user-stickers-btn').addEventListener('click', () => {
          isUserStickerManageMode = true;
          renderUserStickers(); // 重新渲染以显示管理按钮和样式
        });

        // --- “取消”按钮，退出管理模式 ---
        document.getElementById('user-sticker-cancel-manage-btn').addEventListener('click', () => {
          isUserStickerManageMode = false;
          // 清除所有选中状态
          document
            .querySelectorAll('#user-sticker-grid .sticker-item.selected')
            .forEach(el => el.classList.remove('selected'));
          renderUserStickers(); // 重新渲染以退出管理模式
        });

        // --- 点击分类 Tab (包含删除逻辑) ---
        document.getElementById('user-sticker-category-tabs').addEventListener('click', e => {
          const deleteBtn = e.target.closest('.delete-category-btn');
          const tab = e.target.closest('.sticker-category-tab');

          if (deleteBtn) {
            // 如果点击的是删除按钮
            e.stopPropagation(); // 防止触发 tab 的切换事件
            categoryToDelete = deleteBtn.dataset.categoryName;
            if (categoryToDelete) {
              document.getElementById('deleteCategoryConfirmTitle').textContent = `确认删除分类 "${categoryToDelete}"`;
              showModal(document.getElementById('deleteCategoryConfirmModal'));
            }
          } else if (tab) {
            // 如果点击的是 Tab 本身
            activeUserStickerCategory = tab.dataset.categoryName;
            renderUserStickers(); // 切换分类后重新渲染
          }
        });
        // --- 删除分类确认弹窗的事件监听 (全新) ---
        document.getElementById('deleteCategoryOnlyBtn').addEventListener('click', async () => {
          if (!categoryToDelete) return;

          // 1. 将该分类下所有表情的 category 字段更新为 null
          await db.userStickers.where('category').equals(categoryToDelete).modify({ category: null });

          // 2. 重新加载数据
          await loadUserStickers();

          // 3. 将当前激活的分类设为“未分类”
          activeUserStickerCategory = '未分类';

          // 4. 清理状态并更新UI
          categoryToDelete = null;
          hideModal(document.getElementById('deleteCategoryConfirmModal'));
          renderUserStickers();
        });

        document.getElementById('deleteCategoryAndStickersBtn').addEventListener('click', async () => {
          if (!categoryToDelete) return;

          // 1. 找到该分类下所有表情的 ID
          const stickersToDelete = await db.userStickers.where('category').equals(categoryToDelete).toArray();
          const idsToDelete = stickersToDelete.map(s => s.id);

          // 2. 批量删除这些表情
          await db.userStickers.bulkDelete(idsToDelete);

          // 3. 重新加载数据
          await loadUserStickers();

          // 4. 将当前激活的分类设为“未分类”
          activeUserStickerCategory = '未分类';

          // 5. 清理状态并更新UI
          categoryToDelete = null;
          hideModal(document.getElementById('deleteCategoryConfirmModal'));
          renderUserStickers();
        });

        document.getElementById('cancelDeleteCategoryBtn').addEventListener('click', () => {
          categoryToDelete = null;
          hideModal(document.getElementById('deleteCategoryConfirmModal'));
        });

        // --- 表情网格点击事件 (发送 或 选择) ---
        document.getElementById('user-sticker-grid').addEventListener('click', e => {
          const stickerItem = e.target.closest('.user-sticker-item');
          if (!stickerItem) return;

          if (isUserStickerManageMode) {
            // 管理模式下：切换选中状态
            stickerItem.classList.toggle('selected');
          } else {
            // 普通模式下：发送表情
            const originalIndex = parseInt(stickerItem.dataset.originalIndex, 10);
            sendUserSticker(originalIndex);
          }
        });

        // --- 批量删除按钮 ---
        document.getElementById('user-sticker-delete-btn').addEventListener('click', async () => {
          const selectedItems = document.querySelectorAll('#user-sticker-grid .sticker-item.selected');
          if (selectedItems.length === 0) {
            alert('请先选择要删除的表情！');
            return;
          }
          if (confirm(`确定要删除选中的 ${selectedItems.length} 个表情吗？`)) {
            const idsToDelete = Array.from(selectedItems).map(item => parseInt(item.dataset.id, 10));
            await db.userStickers.bulkDelete(idsToDelete);
            await loadUserStickers(); // 重新加载
            renderUserStickers(); // 重新渲染
          }
        });

        // --- 批量分类按钮 ---
        document.getElementById('user-sticker-classify-btn').addEventListener('click', () => {
          const selectedItems = document.querySelectorAll('#user-sticker-grid .sticker-item.selected');
          if (selectedItems.length === 0) {
            alert('请先选择要分类的表情！');
            return;
          }

          const categoryList = document.getElementById('existing-categories-list');
          const categories = new Set(userStickers.map(s => s.category).filter(Boolean));

          categoryList.innerHTML = '<label>选择已有分类</label>';
          if (categories.size === 0) {
            categoryList.innerHTML += '<p style="font-size:12px; color: var(--text-secondary-color);">暂无分类</p>';
          } else {
            // 添加一个“未分类”的选项
            categoryList.innerHTML += `
                    <label class="category-radio-item">
                        <input type="radio" name="sticker_category" value="未分类"> 未分类
                    </label>`;
            categories.forEach(cat => {
              if (cat !== '未分类') {
                // 避免重复添加
                categoryList.innerHTML += `
                        <label class="category-radio-item">
                            <input type="radio" name="sticker_category" value="${cat}"> ${cat}
                        </label>`;
              }
            });
          }

          document.getElementById('newStickerCategoryName').value = '';
          showModal(document.getElementById('stickerCategoryModal'));
        });

        // --- 分类弹窗的 "确定" 按钮 ---
        document.getElementById('confirmCategoryBtn').addEventListener('click', async () => {
          let targetCategory = document.getElementById('newStickerCategoryName').value.trim();
          if (!targetCategory) {
            const selectedRadio = document.querySelector('input[name="sticker_category"]:checked');
            if (selectedRadio) {
              targetCategory = selectedRadio.value;
            }
          }

          if (!targetCategory) {
            alert('请选择一个已有分类或输入一个新的分类名！');
            return;
          }

          // 如果用户选择“未分类”，在数据库中我们将其存为 null 或 undefined 会更好
          const finalCategory = targetCategory === '未分类' ? null : targetCategory;

          const selectedItems = document.querySelectorAll('#user-sticker-grid .sticker-item.selected');
          const idsToUpdate = Array.from(selectedItems).map(item => parseInt(item.dataset.id, 10));

          await db.userStickers.where('id').anyOf(idsToUpdate).modify({ category: finalCategory });

          hideModal(document.getElementById('stickerCategoryModal'));
          await loadUserStickers();
          activeUserStickerCategory = targetCategory; // 移动后自动切换到新分类
          renderUserStickers();
        });

        // --- 分类弹窗的 "取消" 按钮 ---
        document.getElementById('cancelCategoryBtn').addEventListener('click', () => {
          hideModal(document.getElementById('stickerCategoryModal'));
        });
        // --- 分类弹窗的 "取消" 按钮 ---（这是上面的代码）
        document.getElementById('cancelCategoryBtn').addEventListener('click', () => {
          hideModal(document.getElementById('stickerCategoryModal'));
        });

        // ▼▼▼▼▼▼▼▼▼▼ 把新代码粘贴在这里 (开始) ▼▼▼▼▼▼▼▼▼▼
        
        // ================== 中间图标与气泡设置逻辑 (可爱圆润版) ==================
        
        // 1. 定义出厂默认配置
        const DEFAULT_THEME = {
            charBg: '#c1d0dc', charText: '#000000',
            userBg: '#f7e8e9', userText: '#000000',
            bottomBarBg: '#ffffff',
            inputBoxBg: '#e6e6e6', inputBoxText: '#363636',
            plusBtnBg: '#e6e6e6', plusBtnIcon: '#000000',
            
            sendBtnBg: '#ebdbdb',    // 按钮背景色
            sendBtnText: '#ffffff',  // 按钮文字色
            
            isRoundBtn: false, 
            stashIcon: 'https://cdn-icons-png.flaticon.com/512/25/25667.png',
            sendIcon: 'https://cdn-icons-png.flaticon.com/512/60/60525.png'
        };

        // 2. 核心应用函数
        window.applyGlobalBubbleColors = function(s) {
            if (!s) s = DEFAULT_THEME;

            const styleId = 'simple-bubble-style-override';
            let styleTag = document.getElementById(styleId);
            if (styleTag) styleTag.remove();
            
            // 聊天栏按钮形状：圆模式则50%(正圆)，否则4px(微圆角)
            const chatBtnRadius = s.isRoundBtn ? '50%' : '4px';
            
            styleTag = document.createElement('style');
            styleTag.id = styleId;
            styleTag.innerHTML = `
                /* --- 气泡样式 --- */
                #qq-chat-page .char-message .message-content { background-color: ${s.charBg} !important; color: ${s.charText} !important; }
                #qq-chat-page .user-message .message-content { background-color: ${s.userBg} !important; color: ${s.userText} !important; }
                .voice-waveform span { background-color: currentColor !important; }
                
                /* --- 底部底栏背景 & 输入框 --- */
                .chat-input-area { background-color: ${s.bottomBarBg} !important; }
                #chat-input-box { background-color: ${s.inputBoxBg} !important; color: ${s.inputBoxText} !important; }
                #chat-input-box::placeholder { color: ${s.inputBoxText} !important; opacity: 0.5; }
                
                /* --- 左侧加号 --- */
                .chat-tool-btn { background-color: ${s.plusBtnBg} !important; color: ${s.plusBtnIcon} !important; border: none !important; }

                /* --- 1. 聊天底栏的按钮 (受开关控制：方/圆) --- */
                .chat-input-area .chat-send-btn {
                    background-color: ${s.sendBtnBg} !important; 
                    color: ${s.sendBtnText} !important;
                    border-radius: ${chatBtnRadius} !important;
                    transition: all 0.2s;
                }
                
                /* --- 2. 弹窗里的保存按钮 (强制变成可爱的圆润胶囊) --- */
                #middleSettingsModal .chat-send-btn {
                    background-color: ${s.sendBtnBg} !important; 
                    color: ${s.sendBtnText} !important;
                    border-radius: 50px !important; /* 这里改成50px，超级圆润 */
                    width: auto !important;
                    height: auto !important;
                    padding: 8px 20px !important; /* 加大一点内边距，更好看 */
                    box-shadow: 0 2px 5px rgba(0,0,0,0.1); /* 加一点点阴影增加立体感 */
                }
                
                /* --- 圆形模式下，仅调整底栏按钮布局 --- */
                ${s.isRoundBtn ? `
                    .chat-input-area .chat-send-btn {
                        width: 40px !important;
                        height: 40px !important;
                        padding: 0 !important;
                        display: flex !important;
                        align-items: center !important;
                        justify-content: center !important;
                        min-width: 40px !important; 
                        overflow: hidden;
                    }
                    .chat-buttons-container { gap: 8px !important; } 
                ` : ''}
            `;
            document.head.appendChild(styleTag);

            // B. 处理内容：仅处理聊天栏的按钮，把它们变图片
            const btns = document.querySelectorAll('.chat-input-area .chat-send-btn');
            
            btns.forEach(btn => {
                // 安全检查：如果这个按钮不小心在弹窗里，忽略它
                if (btn.closest('.modal-content')) return;

                const text = btn.innerText.trim();
                if(text === '暂存') btn.dataset.type = 'stash';
                if(text === '发送') btn.dataset.type = 'send';

                if (s.isRoundBtn) {
                    // 变成图片
                    let iconUrl = '';
                    if (btn.dataset.type === 'stash') iconUrl = s.stashIcon || DEFAULT_THEME.stashIcon;
                    if (btn.dataset.type === 'send') iconUrl = s.sendIcon || DEFAULT_THEME.sendIcon;
                    
                    if (iconUrl) {
                        btn.innerHTML = `<img src="${iconUrl}" style="width: 20px; height: 20px; object-fit: contain; pointer-events: none;">`;
                    }
                } else {
                    // 变回文字
                    if (btn.dataset.type === 'stash') btn.innerText = '暂存';
                    if (btn.dataset.type === 'send') btn.innerText = '发送';
                }
            });
        };

        // 3. 初始化
        (async function initTheme() {
            try {
                const saved = await db.userSettings.get('simpleBubbleSettings');
                applyGlobalBubbleColors(saved && saved.value ? saved.value : DEFAULT_THEME);
            } catch (e) { applyGlobalBubbleColors(DEFAULT_THEME); }
        })();

        // ================== 弹窗交互逻辑 ==================
        const middleSettingsModal = document.getElementById('middleSettingsModal');
        const middleIconImg = document.getElementById('chat-middle-icon');

        if (middleIconImg) {
            middleIconImg.addEventListener('click', async () => {
                const currentIcon = middleIconImg.src;
                const previewEl = document.getElementById('middleIconPreview');
                if(previewEl) previewEl.src = currentIcon;

                let s = (await db.userSettings.get('simpleBubbleSettings'))?.value;
                if (!s) s = DEFAULT_THEME; 
                
                const setVal = (id, val) => {
                    const el = document.getElementById(id);
                    const hex = document.getElementById(id + 'Hex');
                    const safeVal = val || '#ffffff';
                    if(el) el.value = safeVal;
                    if(hex) hex.value = safeVal;
                };

                setVal('charBubbleBgColor', s.charBg); setVal('charBubbleTextColor', s.charText);
                setVal('userBubbleBgColor', s.userBg); setVal('userBubbleTextColor', s.userText);
                setVal('bottomBarBgColor', s.bottomBarBg);
                setVal('inputBoxBgColor', s.inputBoxBg); setVal('inputBoxTextColor', s.inputBoxText);
                setVal('plusBtnBgColor', s.plusBtnBg); setVal('plusBtnIconColor', s.plusBtnIcon);
                setVal('sendBtnBgColor', s.sendBtnBg); setVal('sendBtnTextColor', s.sendBtnText);

                const isRoundCheck = document.getElementById('useRoundBtnMode');
                if(isRoundCheck) isRoundCheck.checked = !!s.isRoundBtn;
                document.getElementById('stashIconPreview').src = s.stashIcon || DEFAULT_THEME.stashIcon;
                document.getElementById('sendIconPreview').src = s.sendIcon || DEFAULT_THEME.sendIcon;

                showModal(middleSettingsModal);
            });
        }

        const changeMiddleBtn = document.getElementById('changeMiddleIconBtn');
        const changeStashBtn = document.getElementById('changeStashIconBtn');
        const changeSendBtn = document.getElementById('changeSendIconBtn');

        if (changeMiddleBtn) {
            changeMiddleBtn.addEventListener('click', () => {
                currentEditingTarget = { type: 'middleIconPreview' };
                showModal(document.getElementById('imageChoiceModal'));
            });
        }
        if (changeStashBtn) {
            changeStashBtn.addEventListener('click', () => {
                currentEditingTarget = { type: 'stashIconPreview' };
                showModal(document.getElementById('imageChoiceModal'));
            });
        }
        if (changeSendBtn) {
            changeSendBtn.addEventListener('click', () => {
                currentEditingTarget = { type: 'sendIconPreview' };
                showModal(document.getElementById('imageChoiceModal'));
            });
        }

        function bindColorInput(id) {
            const picker = document.getElementById(id);
            const hex = document.getElementById(id + 'Hex');
            if(picker && hex) {
                picker.addEventListener('input', () => hex.value = picker.value);
                hex.addEventListener('change', () => picker.value = hex.value);
            }
        }
        ['charBubbleBgColor', 'charBubbleTextColor', 'userBubbleBgColor', 'userBubbleTextColor',
         'bottomBarBgColor', 'inputBoxBgColor', 'inputBoxTextColor', 
         'plusBtnBgColor', 'plusBtnIconColor', 'sendBtnBgColor', 'sendBtnTextColor'
        ].forEach(id => bindColorInput(id));

        const saveMiddleBtn = document.getElementById('saveMiddleSettingsBtn');
        if (saveMiddleBtn) {
            saveMiddleBtn.addEventListener('click', async () => {
                const previewEl = document.getElementById('middleIconPreview');
                if(previewEl && middleIconImg) {
                    middleIconImg.src = previewEl.src;
                    await db.userSettings.put({ id: 'middleIconUrl', value: previewEl.src });
                }

                const newSettings = {
                    charBg: document.getElementById('charBubbleBgColor').value,
                    charText: document.getElementById('charBubbleTextColor').value,
                    userBg: document.getElementById('userBubbleBgColor').value,
                    userText: document.getElementById('userBubbleTextColor').value,
                    bottomBarBg: document.getElementById('bottomBarBgColor').value,
                    inputBoxBg: document.getElementById('inputBoxBgColor').value,
                    inputBoxText: document.getElementById('inputBoxTextColor').value,
                    plusBtnBg: document.getElementById('plusBtnBgColor').value,
                    plusBtnIcon: document.getElementById('plusBtnIconColor').value,
                    sendBtnBg: document.getElementById('sendBtnBgColor').value,
                    sendBtnText: document.getElementById('sendBtnTextColor').value,

                    isRoundBtn: document.getElementById('useRoundBtnMode').checked,
                    stashIcon: document.getElementById('stashIconPreview').src,
                    sendIcon: document.getElementById('sendIconPreview').src
                };

                await db.userSettings.put({ id: 'simpleBubbleSettings', value: newSettings });
                applyGlobalBubbleColors(newSettings);
                hideModal(middleSettingsModal);
            });
        }

        const cancelMiddleBtn = document.getElementById('cancelMiddleSettingsBtn');
        if (cancelMiddleBtn) { cancelMiddleBtn.addEventListener('click', () => hideModal(middleSettingsModal)); }

        // （这是原本最下面的代码，不需要动它，只是让你确认位置）
        init().catch(console.error); 
      });
    </script>

    <!-- 把这些代码加在 </body> 标签之前 -->

    <!-- ================== 萌系图片选择弹窗 ================== -->
    <div id="imageChoiceModal" class="modal-overlay" style="display: none">
      <div class="modal-content cute-dialog">
        <h3>更换图片</h3>
        <p>请选择图片来源</p>
        <div class="modal-buttons">
          <button id="uploadLocalBtn">本地文件</button>
          <button id="uploadUrlBtn">URL链接</button>
        </div>
        <button id="closeChoiceModal" class="close-btn">&times;</button>
      </div>
    </div>
<!-- ================== 中间图标与气泡设置弹窗 (修复颜色版) ================== -->
<div id="middleSettingsModal" class="modal-overlay" style="display: none">
  <div class="modal-content" style="max-height: 85vh; overflow-y: auto;">
    <h3>聊天外观设置</h3>
    
    <!-- 1. 中间图标 -->
    <div class="settings-section-divider"><label>中间图标</label></div>
    <div class="settings-item-column">
      <div style="display: flex; align-items: center; gap: 15px; justify-content: center; margin-bottom: 10px;">
        <img id="middleIconPreview" src="" style="width: 60px; height: 60px; border-radius: 50%; object-fit: cover; border: 2px solid rgba(255,255,255,0.2);">
        <button id="changeMiddleIconBtn" style="padding: 6px 12px;">更换图标</button>
      </div>
    </div>

    <!-- 2. 气泡颜色 -->
    <div class="settings-section-divider"><label>气泡颜色</label></div>
    <div class="settings-item">
      <label>Char 背景</label>
      <div class="color-input-group"><input type="color" id="charBubbleBgColor"><input type="text" id="charBubbleBgColorHex" style="width: 70px;"></div>
    </div>
    <div class="settings-item">
      <label>Char 文字</label>
      <div class="color-input-group"><input type="color" id="charBubbleTextColor"><input type="text" id="charBubbleTextColorHex" style="width: 70px;"></div>
    </div>
    <div class="settings-item">
      <label>User 背景</label>
      <div class="color-input-group"><input type="color" id="userBubbleBgColor"><input type="text" id="userBubbleBgColorHex" style="width: 70px;"></div>
    </div>
    <div class="settings-item">
      <label>User 文字</label>
      <div class="color-input-group"><input type="color" id="userBubbleTextColor"><input type="text" id="userBubbleTextColorHex" style="width: 70px;"></div>
    </div>

    <!-- 3. 底部基础设置 -->
    <div class="settings-section-divider"><label>底部 - 基础配色</label></div>
    <div class="settings-item">
      <label>底栏背景</label>
      <div class="color-input-group"><input type="color" id="bottomBarBgColor"><input type="text" id="bottomBarBgColorHex" style="width: 70px;"></div>
    </div>
    <div class="settings-item">
      <label>输入框背景</label>
      <div class="color-input-group"><input type="color" id="inputBoxBgColor"><input type="text" id="inputBoxBgColorHex" style="width: 70px;"></div>
    </div>
    <div class="settings-item">
      <label>输入文字色</label>
      <div class="color-input-group"><input type="color" id="inputBoxTextColor"><input type="text" id="inputBoxTextColorHex" style="width: 70px;"></div>
    </div>
    <div class="settings-item">
      <label>左侧加号背景</label>
      <div class="color-input-group"><input type="color" id="plusBtnBgColor"><input type="text" id="plusBtnBgColorHex" style="width: 70px;"></div>
    </div>
    <div class="settings-item">
      <label>左侧加号图标</label>
      <div class="color-input-group"><input type="color" id="plusBtnIconColor"><input type="text" id="plusBtnIconColorHex" style="width: 70px;"></div>
    </div>

    <!-- ▼▼▼ 4. 发送/暂存按钮设置 (重点修复这里) ▼▼▼ -->
    <div class="settings-section-divider"><label>底部 - 发送/暂存按钮</label></div>
    
    <!-- 这里是你要回来的颜色设置！ -->
    <div class="settings-item">
      <label>按钮背景颜色</label>
      <div class="color-input-group"><input type="color" id="sendBtnBgColor"><input type="text" id="sendBtnBgColorHex" style="width: 70px;"></div>
    </div>
    <div class="settings-item">
      <label>按钮文字颜色</label>
      <div class="color-input-group"><input type="color" id="sendBtnTextColor"><input type="text" id="sendBtnTextColorHex" style="width: 70px;"></div>
    </div>

    <!-- 这里是形状和图片设置 -->
    <div class="settings-item" style="justify-content: flex-start; gap: 10px; margin-top: 15px; border-top: 1px dashed #ccc; padding-top: 10px;">
      <input type="checkbox" id="useRoundBtnMode" style="width: 20px; height: 20px;">
      <label for="useRoundBtnMode" style="margin: 0; cursor: pointer; font-weight: bold;">开启圆形图标模式</label>
    </div>
    <p style="font-size: 12px; opacity: 0.7; margin-bottom: 10px;">开启后按钮变圆，显示图片；关闭后显示文字。背景色均以上面设置为准。</p>

    <!-- 暂存按钮图 -->
    <div class="settings-item-column" id="stashIconArea">
      <div style="display: flex; align-items: center; justify-content: space-between;">
        <label>暂存图标</label>
        <div style="display: flex; align-items: center; gap: 10px;">
          <img id="stashIconPreview" src="" style="width: 32px; height: 32px; border-radius: 4px; border: 1px solid #ccc; object-fit: contain;">
          <button id="changeStashIconBtn" style="padding: 4px 8px; font-size: 12px;">上传</button>
        </div>
      </div>
    </div>

    <!-- 发送按钮图 -->
    <div class="settings-item-column" id="sendIconArea" style="margin-top: 5px;">
      <div style="display: flex; align-items: center; justify-content: space-between;">
        <label>发送图标</label>
        <div style="display: flex; align-items: center; gap: 10px;">
          <img id="sendIconPreview" src="" style="width: 32px; height: 32px; border-radius: 4px; border: 1px solid #ccc; object-fit: contain;">
          <button id="changeSendIconBtn" style="padding: 4px 8px; font-size: 12px;">上传</button>
        </div>
      </div>
    </div>
    <!-- ▲▲▲ 修复结束 ▲▲▲ -->

    <div class="modal-buttons" style="margin-top: 25px;">
      <button id="saveMiddleSettingsBtn" class="chat-send-btn api">保存并应用</button>
      <button id="cancelMiddleSettingsBtn">取消</button>
    </div>
  </div>
</div>

    <!-- ================== 萌系文本编辑弹窗 ================== -->
    <div id="textEditModal" class="modal-overlay" style="display: none">
      <div class="modal-content cute-dialog">
        <h3 id="textEditTitle">编辑内容</h3>
        <textarea id="textEditArea"></textarea>
        <div class="modal-buttons">
          <button id="saveTextBtn">保存</button>
          <button id="cancelTextBtn">取消</button>
        </div>
      </div>
    </div>
    <input type="file" id="imageFileInput" accept="image/*" style="display: none" />
    <!-- 把下面这两大块代码加在 </body> 标签之前 -->
    <input type="file" id="cardFileInput" accept=".png,.json" style="display: none" />
    <!-- ================== 全新的外观设置弹窗 ================== -->
    <div id="settingsModal" class="modal-overlay" style="display: none">
      <div class="modal-content" style="max-height: 80vh; overflow-y: auto">
        <h3>外观设置</h3>

        <!-- 壁纸设置 -->
        <div class="settings-item">
          <label>主屏幕壁纸</label>
          <div class="wallpaper-preview-container">
            <div id="wallpaperPreview" class="wallpaper-preview"></div>
            <button id="changeWallpaperBtn">更换</button>
          </div>
        </div>

        <!-- ▼▼▼ 新增：全局背景色调 ▼▼▼ -->
        <div class="settings-item">
          <label for="bgColorPicker">全局背景色调</label>
          <div class="color-input-group">
            <input type="color" id="bgColorPicker" />
            <input type="text" id="bgColorInput" placeholder="#0d0d0d" />
          </div>
        </div>
        <!-- ▲▲▲ 新增结束 ▲▲▲ -->

        <!-- 字体颜色设置 -->
        <div class="settings-item">
          <label for="fontColorPicker">全局字体色调</label>
          <div class="color-input-group">
            <input type="color" id="fontColorPicker" />
            <input type="text" id="fontColorInput" placeholder="#f0f0f0" />
          </div>
        </div>

        <!-- 小组件颜色设置 -->
        <div class="settings-item">
          <label for="bubbleColorPicker">组件颜色</label>
          <div class="color-input-group">
            <input type="color" id="bubbleColorPicker" />
            <input type="text" id="bubbleColorInput" placeholder="#ffffff" />
          </div>
        </div>

        <!-- 小组件透明度设置 -->
        <div class="settings-item">
          <label for="bubbleOpacitySlider">组件透明度</label>
          <input type="range" id="bubbleOpacitySlider" min="0" max="1" step="0.05" />
        </div>

        <!-- App 编辑列表 -->
        <div class="settings-section-divider">
          <label>应用编辑</label>
        </div>
        <ul id="editableAppList" class="editable-app-list">
          <!-- App列表将由JS动态生成在这里 -->
        </ul>

        <div class="modal-buttons">
          <button id="saveSettingsBtn">保存生效</button>
          <button id="cancelSettingsBtn">取消</button>
        </div>
      </div>
    </div>
    <!-- ================== 编辑单个App的弹窗 (简化版) ================== -->
    <div id="editAppModal" class="modal-overlay" style="display: none">
      <div class="modal-content">
        <h3>编辑应用名称</h3>
        <div class="settings-item-column">
          <label for="editAppName">应用名称</label>
          <input type="text" id="editAppName" class="styled-input" />
        </div>
        <div class="modal-buttons">
          <button id="saveAppChangesBtn">确认</button>
          <button id="cancelAppChangesBtn">取消</button>
        </div>
      </div>
    </div>
    <!-- ================== API 设置弹窗 ================== -->
    <div id="apiSettingsModal" class="modal-overlay" style="display: none">
      <div class="modal-content" style="max-height: 80vh; overflow-y: auto; text-align: left">
        <h3>API 设置</h3>

        <!-- API 核心信息 -->
        <div class="settings-item-column">
          <label for="apiUrlInput">API 地址</label>
          <input type="text" id="apiUrlInput" class="styled-input" placeholder="例如：https://api.openai.com/v1" />
        </div>
        <div class="settings-item-column">
          <label for="apiKeyInput">API Key</label>
          <input type="password" id="apiKeyInput" class="styled-input" placeholder="请输入你的 API Key" />
        </div>

        <!-- 模型列表 -->
        <div class="settings-item">
          <label for="modelSelect">选择模型</label>
          <select id="modelSelect" class="styled-input" style="flex-grow: 1; margin-right: 10px"></select>
          <button id="fetchModelsBtn" style="flex-shrink: 0">拉取模型</button>
        </div>

        <!-- 预设管理 -->
        <div class="settings-section-divider">
          <label>预设管理</label>
        </div>
        <div class="settings-item">
          <select id="presetSelect" class="styled-input" style="flex-grow: 1">
            <option value="">--选择一个预设--</option>
          </select>
        </div>
        <div class="settings-item-column">
          <label for="presetNameInput">新预设名称</label>
          <input type="text" id="presetNameInput" class="styled-input" placeholder="输入名称以保存或更新" />
        </div>
        <div class="modal-buttons" style="margin-top: 15px">
          <button id="saveAsPresetBtn">另存为</button>
          <button id="updatePresetBtn">更新预设</button>
          <button id="deletePresetBtn">删除预设</button>
        </div>

        <div class="modal-buttons" style="margin-top: 25px">
          <button id="closeApiSettingsBtn">关闭</button>
        </div>
      </div>
    </div>
    <!-- ================== QQ 通讯录页面 ================== -->
    <div id="qq-contacts-page" class="app-page">
      <div class="app-header">
        <button id="contacts-back-btn" class="back-btn">&lt;</button>
        <span class="header-title">通讯录</span>
        <div class="header-actions">
          <svg
            id="groupManagementBtn"
            xmlns="http://www.w3.org/2000/svg"
            width="24"
            height="24"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
            style="margin-right: 15px; cursor: pointer"
          >
            <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>
          </svg>
          <!-- 右上角列表SVG按钮 -->
          <svg
            id="qq-menu-btn"
            xmlns="http://www.w3.org/2000/svg"
            width="24"
            height="24"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
          >
            <circle cx="12" cy="12" r="1"></circle>
            <circle cx="12" cy="5" r="1"></circle>
            <circle cx="12" cy="19" r="1"></circle>
          </svg>
        </div>
      </div>

      <!-- 联系人列表 -->
      <div class="contacts-list">
        <!-- 联系人列表将由 JavaScript 动态生成在这里 -->
      </div>
    </div>

    <!-- ================== QQ 聊天详情页 ================== -->
    <div id="qq-chat-page" class="app-page">
      <!-- 聊天顶部栏 -->
      <div class="chat-header">
        <button id="chat-back-btn" class="back-btn">&lt;</button>
        <!-- 新的HTML结构 -->
        <div class="char-status-bar">
          <img
            id="chat-char-avatar"
            src="https://i.postimg.cc/h4yRTMGF/ed60bc4602ebd5cbc0d8961d6c4b4aac.jpg"
            class="header-avatar"
            alt="char avatar"
          />
          <img id="chat-middle-icon" src="https://picsum.photos/id/431/100" class="header-avatar" alt="middle icon" />
          <img
            id="chat-user-avatar"
            src="https://i.postimg.cc/ryn2xgwZ/5fc5b9ae74465344658ed8c7e508b8f5.jpg"
            class="header-avatar"
            alt="user avatar"
          />
        </div>
        <div class="chat-header-placeholder"></div>
        <!-- 占位用，保持flex布局平衡 -->
      </div>

      <!-- 聊天消息区域 -->
      <div class="chat-messages">
        <!-- 示例消息 -->
        <div class="message char-message">
          <img src="https://picsum.photos/id/1027/100" class="message-avatar" alt="avatar" />
          <div class="message-content">你好呀！今天有什么想聊的吗？</div>
        </div>
        <div class="message user-message">
          <div class="message-content">你好，我想问一下今天天气怎么样。</div>
          <img src="https://picsum.photos/id/1005/100" class="message-avatar" alt="avatar" />
        </div>
      </div>

      <!-- ▼▼▼ 找到 id="user-sticker-panel" 这个 div, 用下面的代码替换它 ▼▼▼ -->
      <div id="user-sticker-panel" class="chat-tool-panel">
        <div class="user-sticker-panel-header">
          <span>我的表情</span>
          <!-- 普通模式下的按钮 -->
          <div id="user-sticker-normal-buttons" style="display: flex; gap: 8px">
            <button id="user-sticker-bulk-add-btn">批量添加</button>
            <button id="manage-user-stickers-btn">管理</button>
          </div>
          <!-- 管理模式下的按钮 -->
          <div id="user-sticker-manage-buttons" style="display: none; gap: 8px">
            <button id="user-sticker-classify-btn">批量分类</button>
            <button id="user-sticker-delete-btn" style="background-color: #ff3b30; color: white">删除</button>
            <button id="user-sticker-cancel-manage-btn">取消</button>
          </div>
        </div>

        <!-- 新增：分类栏 -->
        <div id="user-sticker-category-tabs" class="sticker-category-tabs">
          <!-- 分类将由 JS 动态加载到这里 -->
        </div>

        <!-- 表情展示网格 -->
        <div
          id="user-sticker-grid"
          class="sticker-grid"
          style="padding: 10px; height: calc(100% - 85px); overflow-y: auto"
        >
          <!-- 用户表情包将由 JS 动态加载到这里 -->
        </div>
      </div>
      <!-- ▲▲▲ 替换完成 ▲▲▲ -->

      <!-- 主工具栏面板 (默认隐藏) -->
      <div id="chat-toolbar-panel" class="chat-tool-panel">
        <div class="toolbar-grid">
          <!-- 功能1: 表情包 -->
          <button id="toolbar-sticker-btn" class="toolbar-grid-item">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="28"
              height="28"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <path d="M8 14s1.5 2 4 2 4-2 4-2" />
              <line x1="9" y1="9" x2="9.01" y2="9" />
              <line x1="15" y1="9" x2="15.01" y2="9" />
              <circle cx="12" cy="12" r="10" />
            </svg>
            <span>表情</span>
          </button>
          <!-- ▼▼▼ 在这里添加新的发送图片按钮 ▼▼▼ -->
          <button id="toolbar-image-btn" class="toolbar-grid-item">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="28"
              height="28"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
              <circle cx="8.5" cy="8.5" r="1.5"></circle>
              <polyline points="21 15 16 10 5 21"></polyline>
            </svg>
            <span>图片</span>
          </button>
          <!-- ▲▲▲ 添加结束 ▲▲▲ -->
          <!-- 功能: 语音 (新) -->
          <button id="toolbar-voice-btn" class="toolbar-grid-item">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="28"
              height="28"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
              <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
              <line x1="12" y1="19" x2="12" y2="22"></line>
            </svg>
            <span>语音</span>
          </button>
          <!-- ▼▼▼ 在这里添加新的视频通话按钮 ▼▼▼ -->
          <button id="toolbar-video-call-btn" class="toolbar-grid-item">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="28"
              height="28"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <path
                d="M15.6 11.6L22 7v10l-6.4-4.6v-1zM4 5h9a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2z"
              ></path>
            </svg>
            <span>视频通话</span>
          </button>
          <!-- ▲▲▲ 添加结束 ▲▲▲ -->
          <button id="toolbar-transfer-btn" class="toolbar-grid-item">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="28"
              height="28"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <path d="M12 19v-7L7 5"></path>
              <path d="M17 5l-5 7"></path>
              <path d="M8 13h8"></path>
              <path d="M8 17h8"></path>
            </svg>
            <span>转账</span>
          </button>
          <!-- ▲▲▲ 添加结束 ▲▲▲ -->
          <button id="toolbar-gift-btn" class="toolbar-grid-item">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="28"
              height="28"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <polyline points="20 12 20 22 4 22 4 12"></polyline>
              <rect x="2" y="7" width="20" height="5"></rect>
              <line x1="12" y1="22" x2="12" y2="7"></line>
              <path d="M12 7H7.5a2.5 2.5 0 0 1 0-5C11 2 12 7 12 7z"></path>
              <path d="M12 7h4.5a2.5 2.5 0 0 0 0-5C13 2 12 7 12 7z"></path>
            </svg>
            <span>礼物</span>
          </button>
          <!-- 功能4: 占位 -->
          <div class="toolbar-grid-item placeholder"></div>
        </div>
      </div>
      <!-- ▲▲▲ 添加结束 ▲▲▲ -->

      <!-- 底部输入区域 -->
      <div class="chat-input-area">
        <!-- ▼▼▼ 在这里添加新的按钮 ▼▼▼ -->
        <button id="chat-toolbar-toggle" class="chat-tool-btn">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="24"
            height="24"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
          >
            <path d="M12 5v14M5 12h14" />
          </svg>
        </button>
        <!-- ▲▲▲ 添加结束 ▲▲▲ -->
        <input type="text" id="chat-input-box" placeholder="输入消息..." />
        <button id="chat-temp-send-btn" class="chat-send-btn">暂存</button>
        <button id="chat-api-send-btn" class="chat-send-btn api">发送</button>
      </div>
    </div>
    <!-- ================== Char 设置面板 ================== -->
    <div id="charSettingsModal" class="modal-overlay" style="display: none">
      <div class="modal-content" style="max-height: 80vh; overflow-y: auto; text-align: left">
        <h3>角色设置</h3>

        <div class="settings-item-column">
          <label>头像</label>
          <div style="display: flex; align-items: center; gap: 10px">
            <img
              id="charSettingsAvatarPreview"
              src=""
              style="width: 60px; height: 60px; border-radius: 50%; object-fit: cover; background-color: #333"
            />
            <button id="changeCharAvatarBtn">更换头像</button>
          </div>
        </div>

        <div class="settings-item-column">
          <label for="charRealName">角色本名</label>
          <input type="text" id="charRealName" class="styled-input" placeholder="角色的真实姓名" />
        </div>

        <div class="settings-item-column">
          <label for="charNickname">给Ta的备注 (显示在列表)</label>
          <input type="text" id="charNickname" class="styled-input" placeholder="你给角色起的昵称" />
        </div>

        <div class="settings-item-column">
          <label for="charGender">性别</label>
          <select id="charGender" class="styled-input">
            <option value="male">男</option>
            <option value="female">女</option>
            <option value="other">其他</option>
          </select>
        </div>

        <div class="settings-item-column">
          <label for="charPersona">人设 (Persona)</label>
          <textarea id="charPersona" class="styled-input" rows="4" placeholder="角色的性格、背景故事等..."></textarea>
        </div>

        <div class="settings-item-column">
          <label for="charMaxMemory">最大记忆条数</label>
          <input type="number" id="charMaxMemory" class="styled-input" value="50" />
        </div>
        <!-- ▼▼▼ 在这里添加新的代码块 ▼▼▼ -->
        <div class="settings-item-column">
          <label for="charMinReply">单次回消息数量区间</label>
          <div style="display: flex; align-items: center; gap: 10px">
            <input type="number" id="charMinReply" class="styled-input" value="1" min="1" style="width: 45%" />
            <span>到</span>
            <input type="number" id="charMaxReply" class="styled-input" value="2" min="1" style="width: 45%" />
          </div>
          <p style="font-size: 12px; color: var(--text-secondary-color); margin-top: 5px">
            AI将尝试在此范围内回复消息。
          </p>
        </div>
        <!-- ▲▲▲ 添加结束 ▲▲▲ -->

        <div class="settings-item-column">
          <label for="charGroup">好友分类</label>
          <!-- 下面这行 input 添加了 list 属性 -->
          <input
            list="group-list"
            id="charGroup"
            class="styled-input"
            placeholder="选择或新建分组"
            autocomplete="off"
          />
          <!-- 下面是新增的 datalist，它会为输入框提供建议选项 -->
          <datalist id="group-list">
            <!-- 选项将由 JavaScript 动态填充 -->
          </datalist>
        </div>

        <!-- ▼▼▼ 用下面的代码替换上面的 div.settings-item-column ▼▼▼ -->
        <div class="settings-item-column">
          <label>关联世界书</label>
          <div
            id="charWorldBookDisplay"
            class="styled-input"
            style="min-height: 44px; padding-top: 12px; cursor: pointer"
          >
            <span style="color: var(--text-secondary-color); font-style: italic">点击选择...</span>
          </div>
        </div>
        <!-- ▲▲▲ 替换完成 ▲▲▲ -->
        <div class="settings-section-divider">
          <label>扩展设定</label>
        </div>
        <div class="modal-buttons" style="justify-content: flex-start; gap: 10px">
          <button id="openNpcLibraryBtn">NPC库</button>
          <button id="openStickerLibraryBtn">表情包库</button>
          <button id="openBubbleEditorBtn">自定义气泡</button>
        </div>
        <div class="settings-section-divider">
          <label>工作与钱包</label>
        </div>

        <!-- 工作设定 -->
        <div class="settings-item-column">
          <label for="charProfession">职业</label>
          <input type="text" id="charProfession" class="styled-input" placeholder="例如：侦探、咖啡师、法师..." />
        </div>
        <div class="settings-item-column">
          <label for="charWorkSchedule">一周工作计划</label>
          <textarea
            id="charWorkSchedule"
            class="styled-input"
            rows="4"
            placeholder="周一：9-5点上班，处理委托&#10;周二：休息日，去图书馆..."
          ></textarea>
          <button
            id="generateWorkScheduleBtn"
            style="margin-top: 8px; font-size: 12px; padding: 4px 12px; border-radius: 20px"
          >
            AI 生成工作计划
          </button>
        </div>

        <!-- 钱包设定 -->
        <div class="settings-item-column">
          <label for="charInitialBalanceRange">初始余额区间 (可选)</label>
          <div style="display: flex; gap: 10px">
            <input type="text" id="charInitialBalanceRange" class="styled-input" placeholder="例如: 1000-5000" />
            <button id="generateInitialBalanceBtn" style="flex-shrink: 0; padding: 8px 15px">生成/重置余额</button>
          </div>
        </div>
        <!-- 在 charSettingsModal 中找到这块代码 -->
        <div class="settings-item-column">
          <label for="charCurrentBalance">当前余额</label>
          <div style="display: flex; align-items: center; gap: 10px">
            <input
              type="text"
              id="charCurrentBalance"
              class="styled-input"
              readonly
              style="background-color: rgba(0, 0, 0, 0.3)"
            />
            <!-- ▼▼▼ 在这里添加新按钮 ▼▼▼ -->
            <button id="viewTransactionLogBtn" style="flex-shrink: 0; padding: 8px 12px">查看记录</button>
            <!-- ▲▲▲ 添加结束 ▲▲▲ -->
          </div>
        </div>

        <!-- ▼▼▼ 在这里添加新的设置项 ▼▼▼ -->
        <div class="settings-section-divider">
          <label>通话设定</label>
          <button
            id="view-video-call-history-btn"
            style="
              background: none;
              border: 1px solid var(--capsule-bg);
              color: var(--text-color);
              padding: 2px 10px;
              border-radius: 20px;
              font-size: 12px;
              cursor: pointer;
              margin-left: 10px;
            "
          >
            通话记录
          </button>
        </div>
        <div class="settings-item-column">
          <label>视频通话图片</label>
          <div style="display: flex; align-items: center; gap: 10px">
            <img
              id="charVideoCallImagePreview"
              src=""
              style="width: 100px; height: 60px; border-radius: 8px; object-fit: cover; background-color: #333"
            />
            <button id="changeCharVideoCallImageBtn">更换</button>
          </div>
          <p style="font-size: 12px; color: var(--text-secondary-color); margin-top: 5px">若不设置，将使用角色头像。</p>
        </div>
        <!-- ▲▲▲ 添加结束 ▲▲▲ -->
        <div class="modal-buttons" style="margin-top: 20px">
          <button id="saveCharSettingsBtn">保存</button>
          <button id="cancelCharSettingsBtn">取消</button>
        </div>
      </div>
    </div>

    <!-- ================== User 设置面板 (V2 - 带钱包功能) ================== -->
    <div id="userSettingsModal" class="modal-overlay" style="display: none">
      <div class="modal-content" style="max-height: 80vh; overflow-y: auto; text-align: left">
        <h3>我的信息 (本次对话)</h3>

        <!-- 头像 -->
        <div class="settings-item-column">
          <label>我的头像 (本次对话)</label>
          <div style="display: flex; align-items: center; gap: 10px">
            <img
              id="userSettingsAvatarPreview"
              src=""
              style="width: 60px; height: 60px; border-radius: 50%; object-fit: cover; background-color: #333"
            />
            <button id="changeUserAvatarBtn">更换头像</button>
          </div>
        </div>

        <!-- 基础信息 -->
        <div class="settings-item-column">
          <label for="userName">我的名字</label>
          <input type="text" id="userName" class="styled-input" placeholder="你在此次对话中的名字" />
        </div>
        <div class="settings-item-column">
          <label for="userRelationToChar">我和Ta的关系</label>
          <input type="text" id="userRelationToChar" class="styled-input" placeholder="例如：朋友、恋人、同学..." />
        </div>
        <div class="settings-item-column">
          <label for="userGender">我的性别</label>
          <select id="userGender" class="styled-input">
            <option value="male">男</option>
            <option value="female">女</option>
            <option value="other">其他</option>
          </select>
        </div>
        <div class="settings-item-column">
          <label for="userPersona">我的人设 (Persona)</label>
          <textarea
            id="userPersona"
            class="styled-input"
            rows="4"
            placeholder="你在此次对话中的角色、身份..."
          ></textarea>
        </div>

        <!-- 通话设定 -->
        <div class="settings-section-divider">
          <label>通话设定</label>
        </div>
        <div class="settings-item-column">
          <label>我的视频通话图片</label>
          <div style="display: flex; align-items: center; gap: 10px">
            <img
              id="userVideoCallImagePreview"
              src=""
              style="width: 100px; height: 60px; border-radius: 8px; object-fit: cover; background-color: #333"
            />
            <button id="changeUserVideoCallImageBtn">更换</button>
          </div>
          <p style="font-size: 12px; color: var(--text-secondary-color); margin-top: 5px">若不设置，将使用我的头像。</p>
        </div>

        <!-- ▼▼▼ 全新的工作与钱包区域 ▼▼▼ -->
        <div class="settings-section-divider">
          <label>我的工作与钱包</label>
        </div>
        <div class="settings-item-column">
          <label for="userProfession">我的职业</label>
          <input type="text" id="userProfession" class="styled-input" placeholder="例如：学生、程序员、自由职业者..." />
        </div>
        <div class="settings-item-column">
          <label for="userDailySalary">每日工资</label>
          <input type="number" id="userDailySalary" class="styled-input" placeholder="输入纯数字，例如: 300" />
        </div>
        <div class="settings-item-column">
          <label for="userInitialBalance">设置初始余额</label>
          <div style="display: flex; gap: 10px">
            <input type="number" id="userInitialBalance" class="styled-input" placeholder="输入纯数字，例如: 5000" />
            <button id="setUserInitialBalanceBtn" style="flex-shrink: 0; padding: 8px 15px">设定/重置</button>
          </div>
        </div>
        <div class="settings-item-column">
          <label for="userCurrentBalance">当前余额</label>
          <div style="display: flex; align-items: center; gap: 10px">
            <input
              type="text"
              id="userCurrentBalance"
              class="styled-input"
              readonly
              style="background-color: rgba(0, 0, 0, 0.3)"
            />
            <button id="viewUserTransactionLogBtn" style="flex-shrink: 0; padding: 8px 12px">查看记录</button>
          </div>
        </div>
        <!-- ▲▲▲ 全新的工作与钱包区域结束 ▲▲▲ -->

        <!-- 人设预设 -->
        <div class="settings-section-divider" style="margin-top: 25px">
          <label>我的人设预设</label>
        </div>
        <div class="modal-buttons" style="margin-bottom: 15px; justify-content: flex-start">
          <button id="saveAsUserPresetBtn">保存当前信息为预设</button>
        </div>
        <ul id="userPresetsList" style="max-height: 150px; overflow-y: auto; padding: 5px; list-style: none; margin: 0">
          <!-- 预设列表将由JS动态生成在这里 -->
        </ul>

        <!-- 底部按钮 -->
        <div class="modal-buttons" style="margin-top: 20px">
          <button id="saveUserSettingsBtn">保存</button>
          <button id="cancelUserSettingsBtn">取消</button>
        </div>
      </div>
    </div>

    <!-- ================== 添加新人物弹窗 (新添加的) ================== -->
    <div id="addCharModal" class="modal-overlay" style="display: none">
      <div class="modal-content" style="max-height: 80vh; overflow-y: auto; text-align: left">
        <h3>添加新人物</h3>

        <div class="settings-item-column">
          <label>头像</label>
          <div style="display: flex; align-items: center; gap: 10px">
            <img
              id="newCharAvatarPreview"
              src="https://i.postimg.cc/h4yRTMGF/ed60bc4602ebd5cbc0d8961d6c4b4aac.jpg"
              style="width: 60px; height: 60px; border-radius: 50%; object-fit: cover; background-color: #333"
            />
            <button id="changeNewCharAvatarBtn">更换头像</button>
          </div>
          <p style="font-size: 12px; color: var(--text-secondary-color); margin-top: 5px">
            若不设置，将使用此默认头像。
          </p>
        </div>

        <div class="settings-item-column">
          <label for="newCharRealName">本名</label>
          <input type="text" id="newCharRealName" class="styled-input" placeholder="角色的真实姓名（可选）" />
        </div>

        <div class="settings-item-column">
          <label for="newCharNickname">备注 <span style="color: red">*</span></label>
          <input type="text" id="newCharNickname" class="styled-input" placeholder="显示在通讯录的名称（必填）" />
        </div>

        <div class="settings-item-column">
          <label for="newCharPersona">人设 (Persona)</label>
          <textarea
            id="newCharPersona"
            class="styled-input"
            rows="4"
            placeholder="角色的性格、背景故事等..."
          ></textarea>
        </div>

        <div class="modal-buttons" style="margin-top: 20px; flex-wrap: wrap">
          <button id="createCharBtn" style="flex-grow: 1">创建</button>
          <!-- ▼▼▼ 新增导入按钮 ▼▼▼ -->
          <button id="importCardBtn" style="flex-grow: 1; background-color: #30d158; color: white">导入角色卡</button>
          <!-- ▲▲▲ 新增结束 ▲▲▲ -->
          <button id="cancelAddCharBtn" style="width: 100%; margin-top: 10px">取消</button>
        </div>
      </div>
    </div>
    <!-- ================== NPC 库弹窗 ================== -->
    <div id="npcLibraryModal" class="modal-overlay" style="display: none">
      <div class="modal-content" style="max-height: 80vh; overflow-y: auto; text-align: left">
        <h3>NPC 库</h3>
        <p style="font-size: 13px; margin-top: -10px; margin-bottom: 15px">管理与该角色有关联的其他人物。</p>

        <div id="npcList" class="editable-app-list" style="margin-bottom: 20px">
          <!-- NPC 列表将由 JS 动态生成 -->
        </div>

        <div class="modal-buttons" style="justify-content: flex-start">
          <button id="addNewNpcBtn">创建新NPC</button>
          <button id="addExistingCharAsNpcBtn">选择已有角色</button>
        </div>

        <div class="modal-buttons" style="margin-top: 25px">
          <button id="closeNpcLibraryBtn">关闭</button>
        </div>
      </div>
    </div>

    <!-- ================== 编辑/创建 NPC 弹窗 ================== -->
    <div id="editNpcModal" class="modal-overlay" style="display: none">
      <div class="modal-content" style="max-height: 80vh; overflow-y: auto; text-align: left">
        <h3 id="editNpcModalTitle">创建新 NPC</h3>

        <!-- 用于选择已有角色的下拉框，默认隐藏 -->
        <div id="selectCharAsNpcSection" class="settings-item-column" style="display: none">
          <label for="existingCharSelect">选择角色</label>
          <select id="existingCharSelect" class="styled-input"></select>
        </div>

        <!-- 用于创建新NPC的输入框，默认显示 -->
        <div id="createNewNpcSection">
          <div class="settings-item-column">
            <label>NPC 头像</label>
            <div style="display: flex; align-items: center; gap: 10px">
              <img
                id="npcAvatarPreview"
                src="https://picsum.photos/seed/npc/100"
                style="width: 60px; height: 60px; border-radius: 50%; object-fit: cover; background-color: #333"
              />
              <button id="changeNpcAvatarBtn">更换</button>
            </div>
          </div>
          <div class="settings-item-column">
            <label for="npcNameInput">NPC 名字</label>
            <input type="text" id="npcNameInput" class="styled-input" placeholder="NPC的名字" />
          </div>
          <div class="settings-item-column">
            <label for="npcPersonaInput">NPC 人设</label>
            <textarea id="npcPersonaInput" class="styled-input" rows="3" placeholder="NPC的性格、背景..."></textarea>
          </div>
        </div>

        <!-- 通用关系输入框 -->
        <div class="settings-item-column">
          <label for="npcRelationInput">与主Char的关系</label>
          <input type="text" id="npcRelationInput" class="styled-input" placeholder="例如：朋友, 母亲, 对手" />
        </div>

        <div class="modal-buttons" style="margin-top: 20px">
          <button id="saveNpcBtn">保存</button>
          <button id="cancelNpcBtn">取消</button>
        </div>
      </div>
    </div>

    <!-- ================== 表情包库弹窗 ================== -->
    <div id="stickerLibraryModal" class="modal-overlay" style="display: none">
      <div
        class="modal-content"
        style="width: 90%; max-width: 380px; max-height: 80vh; display: flex; flex-direction: column"
      >
        <h3>表情包库</h3>

        <!-- Tab 切换 -->
        <div id="stickerTabs" style="display: flex; border-bottom: 1px solid #444; margin-bottom: 15px">
          <button class="sticker-tab-btn active" data-tab="exclusive">专属表情</button>
          <button class="sticker-tab-btn" data-tab="common">通用表情</button>
        </div>

        <!-- 表情包容器 -->
        <div class="sticker-content-container" style="flex-grow: 1; overflow-y: auto">
          <!-- 专属表情包 Tab -->
          <div id="exclusiveStickersTab" class="sticker-tab-content active">
            <div id="exclusiveStickerGrid" class="sticker-grid"></div>
          </div>
          <!-- 通用表情包 Tab -->
          <div id="commonStickersTab" class="sticker-tab-content">
            <div id="commonStickerGrid" class="sticker-grid"></div>
          </div>
        </div>

        <div class="modal-buttons" style="margin-top: 20px; flex-shrink: 0" id="stickerNormalButtons">
          <button id="addStickersBtn">批量添加</button>
          <button id="bulkManageStickersBtn">批量管理</button>
          <button id="closeStickerLibraryBtn">关闭</button>
        </div>
        <div class="modal-buttons" style="margin-top: 20px; flex-shrink: 0; display: none" id="stickerManageButtons">
          <button id="confirmDeleteStickersBtn" style="background-color: #ff3b30; color: white">确认删除</button>
          <button id="cancelManageStickersBtn">取消</button>
        </div>
      </div>
    </div>

    <!-- ================== 批量添加表情包弹窗 ================== -->
    <div id="addStickersModal" class="modal-overlay" style="display: none">
      <div class="modal-content">
        <h3 id="addStickersTitle">添加表情</h3>
        <p style="font-size: 13px; margin-bottom: 15px">
          每行一个，格式为“描述:URL”，例如：<br />开心:https://example.com/happy.png
        </p>
        <textarea id="stickerBulkAddArea" class="styled-input" style="height: 150px; resize: vertical"></textarea>
        <div class="modal-buttons">
          <button id="saveStickersBtn">确认添加</button>
          <button id="cancelAddStickersBtn">取消</button>
        </div>
      </div>
    </div>
    <!-- ▼▼▼ 把下面这个全新的弹窗代码添加到 </body> 之前 ▼▼▼ -->

    <!-- ================== 聊天气泡编辑器弹窗 (V3 - 超级版) ================== -->
    <div id="bubbleEditorModal" class="modal-overlay" style="display: none">
      <div
        class="modal-content"
        style="width: 95%; max-width: 420px; max-height: 85vh; display: flex; flex-direction: column"
      >
        <h3>自定义聊天气泡</h3>

        <!-- 实时预览区域 (结构不变) -->
        <div class="bubble-editor-preview-area">
          <div class="message char-message">
            <img src="https://picsum.photos/id/1027/100" class="message-avatar" alt="avatar" />
            <div class="message-content" id="charBubblePreview" style="position: relative; overflow: hidden">
              <span class="bubble-text">这是对方的气泡预览效果。</span>
            </div>
          </div>
          <div class="message user-message">
            <div class="message-content" id="userBubblePreview" style="position: relative; overflow: hidden">
              <span class="bubble-text">这是我的气泡预览效果。</span>
            </div>
            <img src="https://picsum.photos/id/1005/100" class="message-avatar" alt="avatar" />
          </div>
        </div>

        <!-- 编辑器核心区域 -->
        <div class="bubble-editor-controls">
          <!-- Tab 切换 -->
          <div id="bubbleEditorTabs" class="sticker-tabs" style="margin-bottom: 10px">
            <button class="sticker-tab-btn active" data-tab="visual">可视化编辑</button>
            <button class="sticker-tab-btn" data-tab="css">CSS代码</button>
          </div>

          <!-- 可视化编辑 Tab -->
          <div id="visualEditorTab" class="sticker-tab-content active" style="font-size: 13px; text-align: left">
            <div class="bubble-target-selector">
              <label><input type="radio" name="editTarget" value="char" checked /> 编辑对方气泡</label>
              <label><input type="radio" name="editTarget" value="user" /> 编辑我的气泡</label>
            </div>

            <!-- ▼▼▼ 背景设置 (大改版) ▼▼▼ -->
            <strong class="editor-section-title">背景</strong>
            <div class="settings-item-column">
              <label style="width: auto">背景类型</label>
              <select id="bgTypeSelect" class="styled-input visual-editor-control" data-control="bgType">
                <option value="solid">纯色</option>
                <option value="gradient">渐变</option>
                <option value="image">图片</option>
              </select>
            </div>

            <!-- 纯色控件 -->
            <div id="solidColorControls" class="control-group">
              <div class="settings-item">
                <label>颜色</label>
                <div class="color-input-group">
                  <input type="color" id="bubbleBgColor" class="visual-editor-control" data-control="solid.color" />
                  <input
                    type="text"
                    id="bubbleBgColorHex"
                    class="styled-input visual-editor-control"
                    data-control="solid.color"
                    style="width: 100px"
                  />
                </div>
              </div>
            </div>

            <!-- 渐变控件 -->
            <div id="gradientControls" class="control-group" style="display: none">
              <div class="settings-item">
                <label>起始色</label>
                <div class="color-input-group">
                  <input
                    type="color"
                    id="gradientStartColor"
                    class="visual-editor-control"
                    data-control="gradient.start"
                  />
                  <input
                    type="text"
                    id="gradientStartColorHex"
                    class="styled-input visual-editor-control"
                    data-control="gradient.start"
                    style="width: 100px"
                  />
                </div>
              </div>
              <div class="settings-item">
                <label>结束色</label>
                <div class="color-input-group">
                  <input type="color" id="gradientEndColor" class="visual-editor-control" data-control="gradient.end" />
                  <input
                    type="text"
                    id="gradientEndColorHex"
                    class="styled-input visual-editor-control"
                    data-control="gradient.end"
                    style="width: 100px"
                  />
                </div>
              </div>
              <div class="settings-item-column">
                <label>方向</label>
                <select
                  id="gradientDirection"
                  class="styled-input visual-editor-control"
                  data-control="gradient.direction"
                >
                  <option value="to right">线性: 从左到右 →</option>
                  <option value="to left">线性: 从右到左 ←</option>
                  <option value="to bottom">线性: 从上到下 ↓</option>
                  <option value="to top">线性: 从下到上 ↑</option>
                  <option value="to bottom right">线性: 到右下角 ↘</option>
                  <option value="to bottom left">线性: 到左下角 ↙</option>
                  <option value="radial-center-out">径向: 由内向外</option>
                  <option value="radial-edge-in">径向: 由外向内</option>
                </select>
              </div>
              <div class="settings-item">
                <label for="gradientBisection">启用二分背景</label>
                <input
                  type="checkbox"
                  id="gradientBisection"
                  class="visual-editor-control"
                  data-control="gradient.bisection"
                  style="width: 20px; height: 20px"
                />
              </div>
            </div>

            <!-- 图片控件 -->
            <div id="imageControls" class="control-group" style="display: none">
              <div class="settings-item-column">
                <label>图片 URL</label>
                <input
                  type="text"
                  id="imageUrlInput"
                  class="styled-input visual-editor-control"
                  data-control="image.url"
                  placeholder="粘贴图片链接..."
                />
              </div>
              <button id="uploadBgImageBtn" style="padding: 8px 15px; font-size: 13px">从本地上传</button>
            </div>
            <!-- ▲▲▲ 背景设置结束 ▲▲▲ -->

            <!-- 边框圆角 -->
            <strong class="editor-section-title">边框</strong>
            <div class="settings-item">
              <label>圆角半径</label>
              <input
                type="range"
                id="bubbleBorderRadius"
                min="0"
                max="50"
                value="18"
                class="visual-editor-control"
                data-control="borderRadius"
                data-unit="px"
              />
              <span id="bubbleBorderRadiusValue" style="width: 30px; text-align: right">18px</span>
            </div>
            <!-- ▼▼▼ 在这里插入新的毛玻璃效果控件 ▼▼▼ -->
            <strong class="editor-section-title">毛玻璃效果</strong>
            <div class="settings-item">
              <label for="glassEffectEnabled">启用效果</label>
              <input
                type="checkbox"
                id="glassEffectEnabled"
                class="visual-editor-control"
                data-control="glass.enabled"
                style="width: 20px; height: 20px"
              />
            </div>
            <!-- ▼▼▼ 用这个新版本替换旧的 id="glassEffectControls" div ▼▼▼ -->
            <div id="glassEffectControls" class="control-group">
              <!-- 新增：毛玻璃背景类型选择 -->
              <div class="settings-item-column" style="margin-bottom: 10px">
                <label style="width: auto">背景类型</label>
                <select id="glassBgTypeSelect" class="styled-input visual-editor-control" data-control="glass.bgType">
                  <option value="solid">纯色</option>
                  <option value="gradient">渐变</option>
                </select>
              </div>

              <!-- 毛玻璃纯色控件 -->
              <div id="glassSolidColorControls">
                <div class="settings-item">
                  <label>叠加颜色</label>
                  <div class="color-input-group">
                    <input
                      type="color"
                      id="glassEffectColor"
                      class="visual-editor-control"
                      data-control="glass.solid.color"
                    />
                    <input
                      type="text"
                      id="glassEffectColorHex"
                      class="styled-input visual-editor-control"
                      data-control="glass.solid.color"
                      style="width: 100px"
                    />
                  </div>
                </div>
              </div>

              <!-- 新增：毛玻璃渐变控件 -->
              <div id="glassGradientControls" style="display: none">
                <div class="settings-item">
                  <label>起始色</label>
                  <div class="color-input-group">
                    <input
                      type="color"
                      id="glassGradientStartColor"
                      class="visual-editor-control"
                      data-control="glass.gradient.start"
                    />
                    <input
                      type="text"
                      id="glassGradientStartColorHex"
                      class="styled-input visual-editor-control"
                      data-control="glass.gradient.start"
                      style="width: 100px"
                    />
                  </div>
                </div>
                <div class="settings-item">
                  <label>结束色</label>
                  <div class="color-input-group">
                    <input
                      type="color"
                      id="glassGradientEndColor"
                      class="visual-editor-control"
                      data-control="glass.gradient.end"
                    />
                    <input
                      type="text"
                      id="glassGradientEndColorHex"
                      class="styled-input visual-editor-control"
                      data-control="glass.gradient.end"
                      style="width: 100px"
                    />
                  </div>
                </div>
                <div class="settings-item-column">
                  <label>方向</label>
                  <select
                    id="glassGradientDirection"
                    class="styled-input visual-editor-control"
                    data-control="glass.gradient.direction"
                  >
                    <option value="to right">线性: →</option>
                    <option value="to bottom">线性: ↓</option>
                    <option value="to bottom right">线性: ↘</option>
                    <option value="radial-center-out">径向: 由内向外</option>
                  </select>
                </div>
              </div>

              <!-- 通用控件 -->
              <div class="settings-item">
                <label>不透明度</label>
                <input
                  type="range"
                  id="glassEffectOpacity"
                  min="0"
                  max="1"
                  step="0.05"
                  value="0.1"
                  class="visual-editor-control"
                  data-control="glass.opacity"
                />
                <span id="glassEffectOpacityValue" style="width: 35px; text-align: right">0.1</span>
              </div>
              <div class="settings-item">
                <label>模糊半径</label>
                <input
                  type="range"
                  id="glassEffectBlur"
                  min="0"
                  max="20"
                  value="10"
                  class="visual-editor-control"
                  data-control="glass.blur"
                  data-unit="px"
                />
                <span id="glassEffectBlurValue" style="width: 35px; text-align: right">10px</span>
              </div>
            </div>
            <!-- ▲▲▲ 替换结束 ▲▲▲ -->
            <!-- ▲▲▲ 插入结束 ▲▲▲ -->
            <button
              id="generateCssFromVisual"
              style="font-size: 12px; padding: 4px 10px; margin-top: 5px; float: right"
            >
              生成CSS到代码页
            </button>
          </div>

          <!-- CSS代码编辑 Tab -->
          <div id="cssEditorTab" class="sticker-tab-content">
            <p style="margin-bottom: 10px; font-size: 12px; color: var(--text-secondary-color)">
              在此处直接编写应用于 <code>.message-content</code> 的 CSS。<b>注意：手动修改不会同步回可视化编辑器。</b>
            </p>
            <textarea
              id="bubbleCssInput"
              class="styled-input"
              style="height: 120px; resize: vertical; font-family: monospace"
            ></textarea>
          </div>
        </div>

        <!-- 预设管理与应用 -->
        <div class="settings-section-divider" style="margin-top: 15px">
          <label>预设管理</label>
        </div>
        <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 15px">
          <select id="bubblePresetSelect" class="styled-input" style="flex-grow: 1">
            <option value="">-- 加载一个预设 --</option>
          </select>
          <button id="deleteBubblePresetBtn" style="padding: 8px 10px; background-color: #ff3b30; color: white">
            删除
          </button>
        </div>
        <div class="modal-buttons" style="justify-content: flex-start">
          <button id="saveBubbleAsPresetBtn">另存为新预设</button>
        </div>
        <div class="modal-buttons" style="margin-top: 25px">
          <button id="applyBubbleBtn" class="chat-send-btn api">应用到当前角色</button>
          <button id="closeBubbleEditorBtn">关闭</button>
        </div>
      </div>
    </div>
    <!-- ================== 分组管理弹窗 (新) ================== -->
    <div id="groupManagementModal" class="modal-overlay" style="display: none">
      <div class="modal-content" style="max-height: 80vh; overflow-y: auto; text-align: left">
        <h3>分组管理</h3>

        <div class="settings-item-column">
          <label for="newGroupNameInput">新增分组</label>
          <div style="display: flex; gap: 10px">
            <input type="text" id="newGroupNameInput" class="styled-input" placeholder="输入新分组名称" />
            <button id="addNewGroupBtn" style="flex-shrink: 0">添加</button>
          </div>
        </div>

        <div class="settings-section-divider">
          <label>分组列表</label>
        </div>
        <ul id="groupManagementList" class="editable-app-list" style="padding: 0; list-style: none; margin: 0">
          <!-- 分组列表将由JS动态生成 -->
        </ul>

        <div class="modal-buttons" style="margin-top: 25px">
          <button id="closeGroupManagementBtn">关闭</button>
        </div>
      </div>
    </div>

    <!-- ================== 删除分组确认弹窗 (新) ================== -->
    <div id="deleteGroupConfirmModal" class="modal-overlay" style="display: none">
      <div class="modal-content">
        <h3 id="deleteGroupConfirmTitle">确认删除</h3>
        <p id="deleteGroupConfirmText" style="margin-bottom: 20px">请选择删除方式：</p>
        <div class="modal-buttons" style="flex-direction: column; gap: 10px">
          <button id="deleteGroupAndCharsBtn">删除分组和该分组下所有角色</button>
          <button id="deleteGroupOnlyBtn">仅删除分组 (角色变为未分组)</button>
          <button id="cancelDeleteGroupBtn" style="margin-top: 10px">取消</button>
        </div>
      </div>
    </div>
    <!-- ================== 表情分类弹窗 (全新) ================== -->
    <div id="stickerCategoryModal" class="modal-overlay" style="display: none">
      <div class="modal-content" style="text-align: left">
        <h3>选择分类</h3>
        <div id="existing-categories-list" class="settings-item-column">
          <!-- 已有分类将由 JS 动态加载 -->
        </div>
        <div class="settings-section-divider">
          <label>或者，创建一个新分类</label>
        </div>
        <div class="settings-item-column">
          <label for="newStickerCategoryName">新分类名</label>
          <input type="text" id="newStickerCategoryName" class="styled-input" placeholder="输入新分类的名称" />
        </div>
        <div class="modal-buttons" style="margin-top: 20px">
          <button id="confirmCategoryBtn">确定</button>
          <button id="cancelCategoryBtn">取消</button>
        </div>
      </div>
    </div>
    <!-- ================== 删除分类确认弹窗 (全新) ================== -->
    <div id="deleteCategoryConfirmModal" class="modal-overlay" style="display: none">
      <div class="modal-content">
        <h3 id="deleteCategoryConfirmTitle">确认删除</h3>
        <p>请选择删除方式：</p>
        <div class="modal-buttons" style="flex-direction: column; gap: 10px">
          <button id="deleteCategoryOnlyBtn">仅删除分类 (表情移至“未分类”)</button>
          <button id="deleteCategoryAndStickersBtn" style="background-color: #ff3b30; color: white">
            删除分类和所有表情
          </button>
          <button id="cancelDeleteCategoryBtn" style="margin-top: 10px">取消</button>
        </div>
      </div>
    </div>
    <div id="sendImageChoiceModal" class="modal-overlay" style="display: none">
      <div class="modal-content">
        <h3>发送图片</h3>
        <p>请选择要发送的图片类型</p>
        <div class="modal-buttons" style="flex-direction: column; gap: 10px">
          <button id="sendRealImageBtn">发送真实图片</button>
          <button id="sendTextImageBtn">发送文字图</button>
        </div>
        <button id="cancelSendImageChoiceBtn" class="close-btn">&times;</button>
      </div>
    </div>
    <!-- ▼▼▼ 把这个全新的“文字图”弹窗代码添加到 </body> 之前 ▼▼▼ -->

    <!-- ================== 文字图描述输入弹窗 ================== -->
    <div id="textImageModal" class="modal-overlay" style="display: none">
      <div class="modal-content">
        <h3>发送文字图</h3>
        <p style="font-size: 14px; margin-bottom: 15px">请为你的文字图输入一段描述</p>
        <div class="settings-item-column">
          <textarea
            id="textImageDescriptionInput"
            class="styled-input"
            rows="3"
            placeholder="例如：一只猫猫在打哈欠..."
          ></textarea>
        </div>
        <div class="modal-buttons" style="margin-top: 20px">
          <button id="sendTextImageConfirmBtn" class="chat-send-btn api">确认发送</button>
          <button id="cancelTextImageBtn">取消</button>
        </div>
      </div>
    </div>
    <!-- ================== 语音输入弹窗 (新) ================== -->
    <div id="voiceInputModal" class="modal-overlay" style="display: none">
      <div class="modal-content">
        <h3>发送语音消息</h3>
        <p style="font-size: 14px; margin-bottom: 20px">🎙️ 请在这里输入你想通过语音发送的内容~</p>
        <div class="settings-item-column">
          <textarea id="voiceInputText" class="styled-input" rows="3" placeholder="说点什么吧..."></textarea>
        </div>
        <div class="modal-buttons" style="margin-top: 20px">
          <button id="sendVoiceConfirmBtn" class="chat-send-btn api">确认发送</button>
          <button id="cancelVoiceInputBtn">取消</button>
        </div>
      </div>
    </div>

    <!-- ▲▲▲ 添加结束 ▲▲▲ -->
    <!-- ================== 世界书列表页面 (新) ================== -->
    <div id="worldbook-list-page" class="app-page">
      <div class="app-header">
        <button id="worldbook-list-back-btn" class="back-btn">&lt;</button>
        <span class="header-title">世界书</span>
        <div class="header-actions"></div>
      </div>
      <div id="worldbook-list-container" style="flex-grow: 1; overflow-y: auto">
        <!-- 世界书列表将由JS动态生成 -->
      </div>
      <div class="add-worldbook-btn-container">
        <button id="addNewWorldBookBtn" class="add-worldbook-btn">+ 新建世界书</button>
      </div>
    </div>

    <!-- ================== 世界书详情页面 (新) ================== -->
    <div id="worldbook-detail-page" class="app-page">
      <div class="app-header">
        <button id="worldbook-detail-back-btn" class="back-btn">&lt;</button>
        <span id="worldbook-detail-title" class="header-title">世界书详情</span>
        <div class="header-actions"></div>
      </div>
      <div class="worldbook-entry-list" id="worldbook-entry-list-container">
        <!-- 世界书条目将由JS动态生成 -->
      </div>
      <div class="add-worldbook-btn-container">
        <button id="addNewEntryBtn" class="add-worldbook-btn">+ 新建条目</button>
      </div>
    </div>

    <!-- ================== 编辑/新建世界书条目弹窗 (新) ================== -->
    <div id="editWorldBookEntryModal" class="modal-overlay" style="display: none">
      <div class="modal-content" style="max-height: 80vh; overflow-y: auto; text-align: left">
        <h3 id="editWorldBookEntryTitle">新建条目</h3>
        <div class="settings-item-column">
          <label for="entryNameInput">条目名称/Comment <span style="color: red">*</span></label>
          <input type="text" id="entryNameInput" class="styled-input" placeholder="例如：主角设定" />
        </div>
        <div class="settings-item-column">
          <label for="entryKeysInput">关键词 (Key)</label>
          <input type="text" id="entryKeysInput" class="styled-input" placeholder="多个关键词用英文逗号 , 分隔" />
        </div>
        <div class="settings-item-column">
          <label for="entryContentInput">内容 (Content)</label>
          <textarea id="entryContentInput" class="styled-input" rows="5" placeholder="输入具体的设定内容"></textarea>
        </div>
        <div class="settings-item-column">
          <label for="entryOrderInput">顺序 (Order)</label>
          <input type="number" id="entryOrderInput" class="styled-input" value="100" />
        </div>
        <div class="settings-item-column">
          <label for="entryProbabilityInput">触发概率 (Probability)</label>
          <input type="number" id="entryProbabilityInput" class="styled-input" value="100" min="0" max="100" />
        </div>
        <div class="modal-buttons" style="margin-top: 20px">
          <button id="saveWorldBookEntryBtn">保存</button>
          <button id="cancelWorldBookEntryBtn">取消</button>
        </div>
      </div>
    </div>
    <!-- ================== 关联世界书弹窗 (新) ================== -->
    <div id="associateWorldBookModal" class="modal-overlay" style="display: none">
      <div class="modal-content">
        <h3>关联世界书</h3>
        <p style="font-size: 13px; margin-bottom: 15px">请为当前角色选择需要关联的世界书：</p>

        <ul id="worldbook-selection-list">
          <!-- 世界书选择列表将由JS动态生成 -->
        </ul>

        <div class="modal-buttons" style="margin-top: 20px">
          <button id="saveWorldBookAssociationBtn">保存</button>
          <button id="cancelWorldBookAssociationBtn">取消</button>
        </div>
      </div>
    </div>
    <!-- ▼▼▼ 把这个全新的视频通话UI代码添加到 </body> 之前 ▼▼▼ -->
    <!-- ================== 视频通话 UI 界面 (新) ================== -->
    <div id="video-call-screen" style="display: none">
      <div id="video-call-timer">00:00</div>
      <!-- 大屏画面 (背景) -->
      <div id="video-call-large-view"></div>

      <!-- 小屏画面 (浮动) -->
      <div id="video-call-small-view"></div>

      <!-- 对方信息/头像 (无图模式) -->
      <div id="video-call-char-info">
        <img src="" alt="char avatar" />
        <span id="video-call-char-name"></span>
      </div>

      <!-- 对话内容区域 -->
      <div id="video-call-dialogue-overlay">
        <!-- 对话内容会由 JS 动态添加 -->
      </div>

      <!-- 底部控制栏 -->
      <div id="video-call-controls">
        <button id="video-reroll-btn" class="video-control-btn">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="24"
            height="24"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
          >
            <polyline points="23 4 23 10 17 10"></polyline>
            <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
          </svg>
          <span>重Roll</span>
        </button>
        <button id="video-switch-btn" class="video-control-btn">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="24"
            height="24"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
          >
            <path
              d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"
            ></path>
          </svg>
          <span>切屏</span>
        </button>
        <button id="video-chat-btn" class="video-control-btn">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="24"
            height="24"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
          >
            <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
          </svg>
          <span>聊天</span>
        </button>
        <button id="video-hangup-btn" class="video-control-btn hangup">
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
            <path
              d="M13.29 12l4.35-4.35a.996.996 0 1 0-1.41-1.41L11.88 10.59 7.53 6.24a.996.996 0 1 0-1.41 1.41L10.47 12l-4.35 4.35a.996.996 0 1 0 1.41 1.41L11.88 13.41l4.35 4.35a.996.996 0 1 0 1.41-1.41L13.29 12z"
            ></path>
          </svg>
          <span>挂断</span>
        </button>
      </div>
    </div>
    <!-- ▼▼▼ 用这个新版本替换旧的 id="video-call-invite-modal" ▼▼▼ -->
    <!-- ================== 视频通话呼叫/来电弹窗 (修正版) ================== -->
    <div id="video-call-invite-modal" class="modal-overlay" style="display: none">
      <div class="modal-content">
        <!-- 角色信息区域 (通用) -->
        <div
          id="video-call-char-info-waiting"
          style="display: flex; flex-direction: column; align-items: center; gap: 15px; margin-bottom: 20px"
        >
          <img
            id="waiting-char-avatar"
            src=""
            alt="char avatar"
            style="width: 80px; height: 80px; border-radius: 50%; border: 2px solid rgba(255, 255, 255, 0.2)"
          />
          <span id="waiting-char-name" style="color: var(--text-color); font-size: 18px; font-weight: bold"></span>
        </div>

        <!-- 状态文本 (通用) -->
        <p id="video-call-invite-text" style="margin-bottom: 20px">...</p>

        <!-- 【来电按钮组】 (默认隐藏) -->
        <div id="incoming-call-buttons" class="modal-buttons" style="display: none">
          <button id="accept-video-call-btn" style="background-color: #30d158; color: white">接听</button>
          <button id="reject-video-call-btn" style="background-color: #ff3b30; color: white">拒绝</button>
        </div>

        <!-- 【呼出按钮组】 -->
        <div id="outgoing-call-button" class="modal-buttons">
          <button id="cancel-video-call-btn" style="margin-top: 15px; width: 100%">挂断</button>
        </div>
      </div>
    </div>

    <!-- ================== 视频通话记录列表弹窗 (新) ================== -->
    <div id="videoCallHistoryModal" class="modal-overlay" style="display: none">
      <div class="modal-content" style="text-align: left">
        <h3>通话记录</h3>
        <div id="call-history-list" style="max-height: 60vh; overflow-y: auto">
          <!-- 通话记录列表会由JS动态生成在这里 -->
        </div>
        <div class="modal-buttons" style="margin-top: 20px">
          <button id="closeCallHistoryBtn">关闭</button>
        </div>
      </div>
    </div>

    <!-- ================== 单次通话内容查看弹窗 (新) ================== -->
    <div id="callTranscriptModal" class="modal-overlay" style="display: none">
      <div class="modal-content" style="text-align: left; max-height: 80vh; display: flex; flex-direction: column">
        <h3 id="transcript-modal-title">通话详情</h3>
        <div
          id="transcript-modal-content"
          style="
            flex-grow: 1;
            overflow-y: auto;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 15px;
            font-size: 14px;
            line-height: 1.6;
          "
        >
          <!-- 单次通话的详细内容会由JS动态生成在这里 -->
        </div>
        <div class="modal-buttons" style="margin-top: 20px">
          <button id="closeTranscriptBtn">关闭</button>
        </div>
      </div>
    </div>
    <!-- ▼▼▼ 用这个新版本替换旧的 id="video-call-invite-modal" ▼▼▼ -->
    <!-- ================== 视频通话呼叫/来电弹窗 (新版本) ================== -->
    <div id="video-call-invite-modal" class="modal-overlay" style="display: none">
      <div class="modal-content">
        <!-- 角色信息区域 (通用) -->
        <div
          id="video-call-char-info-waiting"
          style="display: flex; flex-direction: column; align-items: center; gap: 15px; margin-bottom: 20px"
        >
          <img
            id="waiting-char-avatar"
            src=""
            alt="char avatar"
            style="width: 80px; height: 80px; border-radius: 50%; border: 2px solid rgba(255, 255, 255, 0.2)"
          />
          <span id="waiting-char-name" style="color: var(--text-color); font-size: 18px; font-weight: bold"></span>
        </div>

        <!-- 状态文本 (通用) -->
        <p id="video-call-invite-text" style="margin-bottom: 20px">...</p>

        <!-- 【新增】来电按钮组 (默认隐藏) -->
        <div id="incoming-call-buttons" class="modal-buttons" style="display: none">
          <button id="accept-video-call-btn" style="background-color: #30d158; color: white">接听</button>
          <button id="reject-video-call-btn" style="background-color: #ff3b30; color: white">拒绝</button>
        </div>

        <!-- 【修改】呼出按钮 (现在在一个 div 里) -->
        <div id="outgoing-call-button" class="modal-buttons">
          <button id="cancel-video-call-btn" style="margin-top: 15px; width: 100%">挂断</button>
        </div>
      </div>
    </div>
    <!-- ================== 交易记录弹窗 (新) ================== -->
    <div id="transactionLogModal" class="modal-overlay" style="display: none">
      <div class="modal-content" style="text-align: left">
        <h3>余额变动记录</h3>
        <ul id="transaction-log-list">
          <!-- 记录将由 JS 动态生成在这里 -->
        </ul>
        <div class="modal-buttons" style="margin-top: 20px">
          <button id="closeTransactionLogBtn">关闭</button>
        </div>
      </div>
    </div>
    <!-- ▲▲▲ 添加结束 ▲▲▲ -->
    <!-- ================== 用户交易记录弹窗 (新) ================== -->
    <div id="userTransactionLogModal" class="modal-overlay" style="display: none">
      <div class="modal-content" style="text-align: left">
        <h3>我的余额变动记录</h3>
        <ul id="user-transaction-log-list">
          <!-- 记录将由 JS 动态生成在这里 -->
        </ul>
        <div class="modal-buttons" style="margin-top: 20px">
          <button id="closeUserTransactionLogBtn">关闭</button>
        </div>
      </div>
    </div>
    <!-- ================== 转账输入弹窗 (新) ================== -->
    <div id="transferModal" class="modal-overlay" style="display: none">
      <div class="modal-content" style="text-align: left">
        <h3>发起转账</h3>
        <p style="font-size: 14px; margin-bottom: 20px">
          向 <span id="transferRecipientName" style="font-weight: bold; color: var(--accent-color)"></span> 转账
        </p>
        <div class="settings-item-column">
          <label for="transferAmountInput">转账金额 (¥)</label>
          <input type="number" id="transferAmountInput" class="styled-input" placeholder="0.00" />
        </div>
        <div class="settings-item-column">
          <label for="transferRemarkInput">转账备注 (可选)</label>
          <input type="text" id="transferRemarkInput" class="styled-input" placeholder="恭喜发财~" />
        </div>
        <div class="modal-buttons" style="margin-top: 20px">
          <button id="confirmTransferBtn" class="chat-send-btn api">确认转账</button>
          <button id="cancelTransferBtn">取消</button>
        </div>
      </div>
    </div>

    <!-- ================== 转账状态详情弹窗 (新) ================== -->
    <div id="transferStatusModal" class="modal-overlay" style="display: none">
      <div class="modal-content" style="text-align: left">
        <h3 id="transferStatusTitle">转账详情</h3>
        <ul id="transfer-status-list" style="list-style: none; padding: 10px 0; color: var(--text-secondary-color)">
          <!-- 详情将由 JS 动态生成 -->
        </ul>
        <div class="modal-buttons" style="margin-top: 20px">
          <button id="closeTransferStatusBtn">关闭</button>
        </div>
      </div>
    </div>
    <!-- ▲▲▲ 添加结束 ▲▲▲ -->
    <!-- ================== 礼物商店页面 (新) ================== -->
    <div id="gift-shop-page" class="app-page">
      <div class="app-header">
        <button id="gift-shop-back-btn" class="back-btn">&lt;</button>
        <span class="header-title">礼物商店</span>
        <div class="header-actions">
          <button
            id="open-cart-btn"
            style="background: none; border: none; color: white; position: relative; cursor: pointer"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="24"
              height="24"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            >
              <circle cx="9" cy="21" r="1"></circle>
              <circle cx="20" cy="21" r="1"></circle>
              <path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"></path>
            </svg>
            <span
              id="cart-item-count"
              style="
                position: absolute;
                top: -5px;
                right: -8px;
                background-color: red;
                color: white;
                border-radius: 50%;
                width: 18px;
                height: 18px;
                font-size: 11px;
                display: flex;
                align-items: center;
                justify-content: center;
                font-weight: bold;
              "
              >0</span
            >
          </button>
        </div>
      </div>
      <div class="gift-shop-controls" style="padding: 15px; display: flex; gap: 10px; flex-shrink: 0">
        <button id="ai-generate-gifts-btn" class="chat-send-btn api" style="flex: 1">AI 生成礼物</button>
        <button id="ai-search-gifts-btn" class="chat-send-btn" style="flex: 1">AI 搜索礼物</button>
      </div>
      <div id="gift-list-container" style="flex-grow: 1; overflow-y: auto; padding: 0 15px 15px 15px">
        <!-- 礼物列表将由JS动态生成 -->
      </div>
    </div>

    <!-- ================== 购物车弹窗 (新) ================== -->
    <div id="shopping-cart-modal" class="modal-overlay" style="display: none">
      <div class="modal-content" style="text-align: left; max-height: 80vh; display: flex; flex-direction: column">
        <h3>我的购物车</h3>
        <ul id="cart-items-list" style="list-style: none; padding: 0; margin: 0; flex-grow: 1; overflow-y: auto">
          <!-- 购物车项目将由JS动态生成 -->
        </ul>
        <div class="settings-section-divider" style="margin-top: auto">
          <div style="display: flex; justify-content: space-between; align-items: center; font-size: 16px">
            <span>总计:</span>
            <span id="cart-total-price" style="font-weight: bold; color: var(--accent-color)">¥ 0.00</span>
          </div>
        </div>
        <div class="modal-buttons" style="margin-top: 20px">
          <button id="checkout-btn" class="chat-send-btn api">结算送出</button>
          <button id="close-cart-btn">关闭</button>
        </div>
      </div>
    </div>
    <!-- ================== 🎮 字体游戏机 (最终萌化版) 🎮 ================== -->
    <div id="fontManagerModal" class="modal-overlay" style="display: none">
      <div class="modal-content">
        <!-- 头部 -->
        <div class="cute-header">
          <!-- 删掉了 span 标签，现在的装饰由 CSS 的 ::before 生成 -->
          <h3>字体小屋</h3>
          <button id="closeFontManagerBtn" class="cute-close-btn">×</button>
        </div>

        <!-- 导航 Tabs -->
        <div class="cute-tabs" id="fontManagerTabs">
          <button class="cute-tab-btn active" data-tab="library">Library</button>
          <button class="cute-tab-btn" data-tab="add-one">+ New</button>
          <button class="cute-tab-btn" data-tab="add-batch">Batch</button>
        </div>

        <!-- Tab 1: 字体库列表 -->
        <div id="tab-library" class="cute-tab-content active">
          <!-- ▼▼▼ 新增：字体大小调节区域 ▼▼▼ -->
          <div class="cute-range-container">
            <div class="cute-range-header">
              <span>SIZE ADJUST (字体大小)</span>
              <span id="fontSizeValueDisplay" style="color: #a0c4ff">+0px</span>
            </div>
            <!-- 范围从 -2 到 8，步长为 1 -->
            <input type="range" id="fontSizeSlider" class="cute-range" min="-2" max="8" step="1" value="0" />
          </div>
          <!-- ▲▲▲ 新增结束 ▲▲▲ -->

          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px">
            <span style="font-size: 11px; color: #aaa; font-weight: bold">● 已保存的字体</span>
            <button
              id="resetFontBtn"
              style="
                border: none;
                background: none;
                color: #a0c4ff;
                font-size: 11px;
                cursor: pointer;
                font-weight: bold;
              "
            >
              [ ↺ Reset ]
            </button>
          </div>
          <div id="fontListContainer" class="font-list-container">
            <!-- 列表由 JS 生成 -->
          </div>
        </div>

        <!-- Tab 2: 添加单个 -->
        <div id="tab-add-one" class="cute-tab-content">
          <div class="cute-input-group">
            <label class="cute-label">NAME 🏷️</label>
            <input type="text" id="newFontName" class="cute-input" placeholder="取个名字吧ಣ" />
          </div>
          <div class="cute-input-group">
            <label class="cute-label">URL 🔗</label>
            <input type="text" id="newFontUrl" class="cute-input" placeholder="http://..." />
          </div>
          <button id="addNewFontBtn" class="cute-btn-primary">START IMPORT !</button>
        </div>

        <!-- Tab 3: 批量导入 -->
        <div id="tab-add-batch" class="cute-tab-content">
          <div class="batch-tip">
            -> ᴗ <- 格式提示：<br />
            <code>Name : URL</code>
          </div>
          <textarea
            id="batchFontInput"
            class="cute-textarea"
            placeholder="名字 : http://...&#10;名字 : http://..."
          ></textarea>
          <button id="batchAddFontBtn" class="cute-btn-primary">RUN BATCH >></button>
        </div>
      </div>
    </div>
  </body>
</html>
